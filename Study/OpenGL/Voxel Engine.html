<!DOCTYPE html>



<html>
<head>
    <meta charset="UTF-8">
    <title>Voxel Engine</title>
    <link rel="icon" href="https://biisairo.github.io/static/favicon.ico" type="image/x-icon">
</head>
<body>
        <header>
        <nav>
            <ul>
                

                <li><a href="https://biisairo.github.io/">Home</a></li>
                
                    <li><a href="https://biisairo.github.io/About/">About</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/">Study</a></li>
                
                    <li><a href="https://biisairo.github.io/Contact/">Contact</a></li>
                
            </ul>
        </nav>

            <style>
 
html, body {
    height: 100%;
    margin: 0;
}

body {
    display: flex;
    flex-direction: column;
    max-width: 720px;
    margin: 0 auto;
    padding: 2rem 1rem;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
                Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
    line-height: 1.6;
    background: #222831;
    color: #EEEEEE;
}

header, footer {
    text-align: center;
    margin-bottom: 2rem;
}

nav ul {
    list-style: none;
    padding: 0;
    display: flex;
    justify-content: space-between;
    align-items: flex-end;  
    flex-wrap: wrap;
    gap: 1rem;
}

nav li:first-child {
    margin-right: auto;  
}

nav li:not(:first-child) {
    margin-left: 0;
}

nav li:first-child a {
    color: #EEEEEE;
    font-size: 1.5em;
    text-decoration: none;  
}

nav li:first-child a:hover {
    color: #aadadf;  
}

nav a {
    color: #00ADB5;
    text-decoration: underline;
    transition: color 0.3s ease;
}

nav a:hover {
    color: #66C1C9;
    text-decoration: none;
}

main a,
article a,
footer a {
    color: #33d3c8;
    text-decoration: underline;
    transition: color 0.3s ease;
}

main a:hover,
article a:hover,
footer a:hover {
    color: #66C1C9;
    text-decoration: none;
}

 
main {
    flex: 1;
    margin-bottom: 2rem;
}

h1, h2, h3 {
    line-height: 1.3;
    margin-top: 2rem;
    margin-bottom: 1rem;
    color: #00ADB5;
}

ul {
    padding-left: 1.5rem;
}

article {
    margin-top: 2rem;
    border: 1px solid #33d3c8;
    padding: 1rem;
    border-radius: 5px;
}

footer p {
    font-size: 0.9rem;
    color: #AAAAAA;
}

    </style>

    </header>

    <main>
        
            
                <h2>하위 그룹</h2>
                <ul>
                    
                        <li><a href="https://biisairo.github.io/Study/OpenGL/Skeleton%20hierarchy/">Skeleton hierarchy</a></li>
                    
                        <li><a href="https://biisairo.github.io/Study/OpenGL/%ec%bf%bc%ed%84%b0%eb%8b%88%ec%96%b8%20%ed%9a%8c%ec%a0%84/">쿼터니언 회전</a></li>
                    
                        <li><a href="https://biisairo.github.io/Study/OpenGL/OpenGL/">OpenGL</a></li>
                    
                        <li><a href="https://biisairo.github.io/Study/OpenGL/VBO,%20VAO,%20EBO/">VBO, VAO, EBO</a></li>
                    
                        <li><a href="https://biisairo.github.io/Study/OpenGL/light%20casters/">light casters</a></li>
                    
                        <li><a href="https://biisairo.github.io/Study/OpenGL/blending/">blending</a></li>
                    
                        <li><a href="https://biisairo.github.io/Study/OpenGL/cubemap/">cubemap</a></li>
                    
                        <li><a href="https://biisairo.github.io/Study/OpenGL/advanced%20glsl/">advanced glsl</a></li>
                    
                        <li><a href="https://biisairo.github.io/Study/OpenGL/blinn%20phong/">blinn phong</a></li>
                    
                        <li><a href="https://biisairo.github.io/Study/OpenGL/gamma%20correction/">gamma correction</a></li>
                    
                        <li><a href="https://biisairo.github.io/Study/OpenGL/shadow%20mapping/">shadow mapping</a></li>
                    
                        <li><a href="https://biisairo.github.io/Study/OpenGL/normal%20mapping/">normal mapping</a></li>
                    
                        <li><a href="https://biisairo.github.io/Study/OpenGL/parallax%20mapping/">parallax mapping</a></li>
                    
                        <li><a href="https://biisairo.github.io/Study/OpenGL/High%20Dynamic%20Range/">High Dynamic Range</a></li>
                    
                        <li><a href="https://biisairo.github.io/Study/OpenGL/bloom/">bloom</a></li>
                    
                </ul>
            
        

        
            <h2>하위 페이지</h2>
            <ul>
                
                    <li><a href="https://biisairo.github.io/Study/OpenGL/obj%20mtl%20file.html">obj mtl file</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/OpenGL/%ec%b0%b8%ea%b3%a0%ec%9e%90%eb%a3%8c.html">참고자료</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/OpenGL/function.html">function</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/OpenGL/%ec%b4%88%ea%b8%b0%ed%99%94.html">초기화</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/OpenGL/basic%20function.html">basic function</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/OpenGL/Shader.html">Shader</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/OpenGL/Texture.html">Texture</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/OpenGL/Transform.html">Transform</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/OpenGL/Coordinate%20System.html">Coordinate System</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/OpenGL/Camera.html">Camera</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/OpenGL/Color.html">Color</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/OpenGL/Materials.html">Materials</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/OpenGL/Lighting%20map.html">Lighting map</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/OpenGL/depth%20test.html">depth test</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/OpenGL/stencil%20test.html">stencil test</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/OpenGL/face%20culling.html">face culling</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/OpenGL/framebuffers.html">framebuffers</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/OpenGL/advanced%20data.html">advanced data</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/OpenGL/geometry%20shader.html">geometry shader</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/OpenGL/instancingmd.html">instancingmd</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/OpenGL/anti%20aliasing.html">anti aliasing</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/OpenGL/point%20shadow.html">point shadow</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/OpenGL/mapping.html">mapping</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/OpenGL/Voxel%20Engine.html">Voxel Engine</a></li>
                
            </ul>
        
        
        
            
            <article>
                <h1>Voxel Engine</h1>
<p>참고자료</p>
<p><a href="https://sites.google.com/site/letsmakeavoxelengine/home">https://sites.google.com/site/letsmakeavoxelengine/home</a></p>
<h1>voxel</h1>
<p>2차원 그래픽에서의 픽셀을 3차원에서 표현한 것</p>
<p>pixel + volume 의 합성어</p>
<p>폴리곤은 vertex 를 사용해 만들어진 삼각형으로 물체를 구성</p>
<p>복셀은 모양이 동일한 정육면체를 모아 물체를 구성</p>
<ul>
<li>연산이 많아지게 되며 물체의 크기가 커지거나, 많아지게 되면 속도가 떨어짐</li>
</ul>
<p>폴리곤이 표면의 표현에 집중되어 있다면 복셀은 공간의 특성값을 가짐</p>
<p>입체적인 물체의 구현에 합리적</p>
<h1>Block</h1>
<p>하나의 블럭 = 하나의 복셀</p>
<p>각 블럭에 대한 데이터를 저장할 필요가 있으며 해당 데이터는 수많은 복셀을 저장해야 하므로 최소한의 정보를 가지는 것이 좋음</p>
<ul>
<li>normal 같은 값은 복셀의 정점에서 빠르게 구할 수 있으므로 저장하지 않음</li>
</ul>
<p>추가로 필요한 정보는 해당 블록이 활성화 되어있는지의 여부</p>
<ul>
<li>해당 활성화 여부는 랜더링 시 해당 블록을 랜더링 해야하는지 알 수 있음</li>
</ul>
<pre><code class="language-cpp">class Block {
	public:
	...
	bool isActive();
	void setActive(bool active);
	...

	private:
	bool _active;
	BlockType _blockType;
}
</code></pre>
<p>block type</p>
<ul>
<li>각 블럭이 정보값을 가지고 있는 것이 아닌 블럭의 유형만 저장</li>
</ul>
<pre><code class="language-cpp">enum BlockType {
	BlockType_Default = 0,
	BlockType_Grass,
	...
}
</code></pre>
<h1>Chunk</h1>
<p>한번에 랜더링에 그려지는 공간 단위</p>
<p>각각의 복셀을 한번씩 랜더링 하는 것이 아닌 여러 복셀의 집합인 청크를 단위로 랜더링 함</p>
<pre><code class="language-cpp">class Chunk {
	public:
	...
	void Update(float dt);
	void createMesh();
	void Render(...);
	...

	private:
	Block*** _blocks;
}

Chunk::Chunk() { // Create the blocks
	m_pBlocks = new Block **[CHUNK_SIZE];
	for (int i = 0; i &lt; CHUNK_SIZE; i++) {
		m_pBlocks[i] = new Block *[CHUNK_SIZE];
		for (int j = 0; j &lt; CHUNK_SIZE; j++) {
			m_pBlocks[i][j] = new Block[CHUNK_SIZE];
		}
	}
}

Chunk::~Chunk() { // Delete the blocks
	for (int i = 0; i &lt; CHUNK_SIZE; ++i) {
		for (int j = 0; j &lt; CHUNK_SIZE; ++j) {
			delete[] m_pBlocks[i][j];
		}
		delete[] m_pBlocks[i];
	}
	delete[] m_pBlocks;
}

void Chunk::createMesh() {
	for (int ...
		for (int ...
			for (int ...
				if (_Blocks[i][j][k].isActive())
					createCube();
}
</code></pre>
<ul>
<li>
<p>createCube</p>
<ul>
<li>큐브의 8개의 점을 사용해 chunk 의 avo 의 abo 에 mesh 를 생성</li>
</ul>
<pre><code class="language-cpp">void Chunk::createCube() {
	Vector3d p1(x - Block::BLOCK_RENDER_SIZE, y - Block::BLOCK_RENDER_SIZE, z + Block::BLOCK_RENDER_SIZE);
	Vector3d p2(x + Block::BLOCK_RENDER_SIZE, y - Block::BLOCK_RENDER_SIZE, z + Block::BLOCK_RENDER_SIZE);
	Vector3d p3(x + Block::BLOCK_RENDER_SIZE, y + Block::BLOCK_RENDER_SIZE, z + Block::BLOCK_RENDER_SIZE);
	Vector3d p4(x - Block::BLOCK_RENDER_SIZE, y + Block::BLOCK_RENDER_SIZE, z + Block::BLOCK_RENDER_SIZE);
	Vector3d p5(x + Block::BLOCK_RENDER_SIZE, y - Block::BLOCK_RENDER_SIZE, z - Block::BLOCK_RENDER_SIZE);
	Vector3d p6(x - Block::BLOCK_RENDER_SIZE, y - Block::BLOCK_RENDER_SIZE, z - Block::BLOCK_RENDER_SIZE);
	Vector3d p7(x - Block::BLOCK_RENDER_SIZE, y + Block::BLOCK_RENDER_SIZE, z - Block::BLOCK_RENDER_SIZE);
	Vector3d p8(x + Block::BLOCK_RENDER_SIZE, y + Block::BLOCK_RENDER_SIZE, z - Block::BLOCK_RENDER_SIZE);
	Vector3d n1;
	unsigned int v1;
	unsigned int v2;
	unsigned int v3;
	unsigned int v4;
	unsigned int v5;
	unsigned int v6;
	unsigned int v7;
	unsigned int v8;
	float r = 1.0 f;
	float g = 1.0 f;
	float b = 1.0 f;
	float a = 1.0 f; // Front     
	n1 = Vector3d(0.0 f, 0.0 f, 1.0 f);
	v1 = m_pRenderer-&gt;AddVertexToMesh(m_meshID, p1, n1, r, g, b, a);
	v2 = m_pRenderer-&gt;AddVertexToMesh(m_meshID, p2, n1, r, g, b, a);
	v3 = m_pRenderer-&gt;AddVertexToMesh(m_meshID, p3, n1, r, g, b, a);
	v4 = m_pRenderer-&gt;AddVertexToMesh(m_meshID, p4, n1, r, g, b, a);
	m_pRenderer-&gt;AddTriangleToMesh(m_meshID, v1, v2, v3);
	m_pRenderer-&gt;AddTriangleToMesh(m_meshID, v1, v3, v4); // Back     
	n1 = Vector3d(0.0 f, 0.0 f, -1.0 f);
	v5 = m_pRenderer-&gt;AddVertexToMesh(m_meshID, p5, n1, r, g, b, a);
	v6 = m_pRenderer-&gt;AddVertexToMesh(m_meshID, p6, n1, r, g, b, a);
	v7 = m_pRenderer-&gt;AddVertexToMesh(m_meshID, p7, n1, r, g, b, a);
	v8 = m_pRenderer-&gt;AddVertexToMesh(m_meshID, p8, n1, r, g, b, a);
	m_pRenderer-&gt;AddTriangleToMesh(m_meshID, v5, v6, v7);
	m_pRenderer-&gt;AddTriangleToMesh(m_meshID, v5, v7, v8); // Right     
	n1 = Vector3d(1.0 f, 0.0 f, 0.0 f);
	v2 = m_pRenderer-&gt;AddVertexToMesh(m_meshID, p2, n1, r, g, b, a);
	v5 = m_pRenderer-&gt;AddVertexToMesh(m_meshID, p5, n1, r, g, b, a);
	v8 = m_pRenderer-&gt;AddVertexToMesh(m_meshID, p8, n1, r, g, b, a);
	v3 = m_pRenderer-&gt;AddVertexToMesh(m_meshID, p3, n1, r, g, b, a);
	m_pRenderer-&gt;AddTriangleToMesh(m_meshID, v2, v5, v8);
	m_pRenderer-&gt;AddTriangleToMesh(m_meshID, v2, v8, v3); // left     
	n1 = Vector3d(-1.0 f, 0.0 f, 0.0 f);
	v6 = m_pRenderer-&gt;AddVertexToMesh(m_meshID, p6, n1, r, g, b, a);
	v1 = m_pRenderer-&gt;AddVertexToMesh(m_meshID, p1, n1, r, g, b, a);
	v4 = m_pRenderer-&gt;AddVertexToMesh(m_meshID, p4, n1, r, g, b, a);
	v7 = m_pRenderer-&gt;AddVertexToMesh(m_meshID, p7, n1, r, g, b, a);
	m_pRenderer-&gt;AddTriangleToMesh(m_meshID, v6, v1, v4);
	m_pRenderer-&gt;AddTriangleToMesh(m_meshID, v6, v4, v7); // Top     
	n1 = Vector3d(0.0 f, 1.0 f, 0.0 f);
	v4 = m_pRenderer-&gt;AddVertexToMesh(m_meshID, p4, n1, r, g, b, a);
	v3 = m_pRenderer-&gt;AddVertexToMesh(m_meshID, p3, n1, r, g, b, a);
	v8 = m_pRenderer-&gt;AddVertexToMesh(m_meshID, p8, n1, r, g, b, a);
	v7 = m_pRenderer-&gt;AddVertexToMesh(m_meshID, p7, n1, r, g, b, a);
	m_pRenderer-&gt;AddTriangleToMesh(m_meshID, v4, v3, v8);
	m_pRenderer-&gt;AddTriangleToMesh(m_meshID, v4, v8, v7); // Bottom     
	n1 = Vector3d(0.0 f, -1.0 f, 0.0 f);
	v6 = m_pRenderer-&gt;AddVertexToMesh(m_meshID, p6, n1, r, g, b, a);
	v5 = m_pRenderer-&gt;AddVertexToMesh(m_meshID, p5, n1, r, g, b, a);
	v2 = m_pRenderer-&gt;AddVertexToMesh(m_meshID, p2, n1, r, g, b, a);
	v1 = m_pRenderer-&gt;AddVertexToMesh(m_meshID, p1, n1, r, g, b, a);
	m_pRenderer-&gt;AddTriangleToMesh(m_meshID, v6, v5, v2);
	m_pRenderer-&gt;AddTriangleToMesh(m_meshID, v6, v2, v1);
}
</code></pre>
</li>
<li>
<p>이후 chunk 의 position 을 기준으로 만들어진 청크의 mesh 를 랜더링</p>
</li>
<li>
<p>매번 block 가 업데이트 될 때 마다 청크를 update 하고 랜더링 해야함</p>
<ul>
<li>청크의 크기가 너무 크면 하나의 청크를 랜더링 하는데에 시간이 너무 오래 걸림</li>
<li>청크의 크기가 너무 작으면 너무 많은 청크를 랜더링 해야 함</li>
</ul>
</li>
</ul>
<h1>chunk optimization</h1>
<h2>skip covered triangles</h2>
<ul>
<li>매 face 를 추가할 때 옆에 붙은 block 가 있는지 확인 한 후 추가</li>
<li>옆에 block 이 있어 해당 face 가 보이지 않는 경우 추가하지 않음</li>
</ul>
<h2>skip empty chunk</h2>
<ul>
<li>해당 청크가 비어있는 경우 구축, 랜더링 과정을 생략</li>
</ul>
<h2>skip covered chunk</h2>
<ul>
<li>주변이 완전히 다른 청크로 덮여 보이지 않는 경우 랜더링 하지 않음</li>
</ul>
<h2>frustum culling</h2>
<ul>
<li>절두체 컬링</li>
<li>보고 있는 방향의 물체만 랜더링</li>
<li>물체가 절두체에 들어있는지 확인하는 작업에 cpu 시간이 오래걸림</li>
</ul>
<h2>octree frustum culling</h2>
<ul>
<li>octree 를 사용</li>
</ul>

            </article>
            
        
    </main>

        <footer>
        <p>Generated by SuGo</p>
    </footer>

</body>
</html>


