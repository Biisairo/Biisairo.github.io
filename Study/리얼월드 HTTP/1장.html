<!DOCTYPE html>



<html>
<head>
    <meta charset="UTF-8">
    <title>1장</title>
    <link rel="icon" href="https://biisairo.github.io/static/favicon.ico" type="image/x-icon">
</head>
<body>
        <header>
        <nav>
            <ul>
                

                <li><a href="https://biisairo.github.io/">Home</a></li>
                
                    <li><a href="https://biisairo.github.io/About/">About</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/">Study</a></li>
                
                    <li><a href="https://biisairo.github.io/Contact/">Contact</a></li>
                
            </ul>
        </nav>

            <style>
 
html, body {
    height: 100%;
    margin: 0;
}

body {
    display: flex;
    flex-direction: column;
    max-width: 720px;
    margin: 0 auto;
    padding: 2rem 1rem;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
                Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
    line-height: 1.6;
    background: #222831;
    color: #EEEEEE;
}

header, footer {
    text-align: center;
    margin-bottom: 2rem;
}

nav ul {
    list-style: none;
    padding: 0;
    display: flex;
    justify-content: space-between;
    align-items: flex-end;  
    flex-wrap: wrap;
    gap: 1rem;
}

nav li:first-child {
    margin-right: auto;  
}

nav li:not(:first-child) {
    margin-left: 0;
}

nav li:first-child a {
    color: #EEEEEE;
    font-size: 1.5em;
    text-decoration: none;  
}

nav li:first-child a:hover {
    color: #aadadf;  
}

nav a {
    color: #00ADB5;
    text-decoration: underline;
    transition: color 0.3s ease;
}

nav a:hover {
    color: #66C1C9;
    text-decoration: none;
}

main a,
article a,
footer a {
    color: #33d3c8;
    text-decoration: underline;
    transition: color 0.3s ease;
}

main a:hover,
article a:hover,
footer a:hover {
    color: #66C1C9;
    text-decoration: none;
}

 
main {
    flex: 1;
    margin-bottom: 2rem;
}

h1, h2, h3 {
    line-height: 1.3;
    margin-top: 2rem;
    margin-bottom: 1rem;
    color: #00ADB5;
}

ul {
    padding-left: 1.5rem;
}

article {
    margin-top: 2rem;
}

footer p {
    font-size: 0.9rem;
    color: #AAAAAA;
}

    </style>

    </header>

    <main>
        
            
        

        
            <h2>하위 페이지</h2>
            <ul>
                
                    <li><a href="https://biisairo.github.io/Study/%eb%a6%ac%ec%96%bc%ec%9b%94%eb%93%9c%20HTTP/1%ec%9e%a5.html">1장</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%eb%a6%ac%ec%96%bc%ec%9b%94%eb%93%9c%20HTTP/2%ec%9e%a5.html">2장</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%eb%a6%ac%ec%96%bc%ec%9b%94%eb%93%9c%20HTTP/3%ec%9e%a5.html">3장</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%eb%a6%ac%ec%96%bc%ec%9b%94%eb%93%9c%20HTTP/4%ec%9e%a5.html">4장</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%eb%a6%ac%ec%96%bc%ec%9b%94%eb%93%9c%20HTTP/5%ec%9e%a5.html">5장</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%eb%a6%ac%ec%96%bc%ec%9b%94%eb%93%9c%20HTTP/6%ec%9e%a5.html">6장</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%eb%a6%ac%ec%96%bc%ec%9b%94%eb%93%9c%20HTTP/7%ec%9e%a5.html">7장</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%eb%a6%ac%ec%96%bc%ec%9b%94%eb%93%9c%20HTTP/8%ec%9e%a5.html">8장</a></li>
                
            </ul>
        
        
        
        <article>
            <h1>1장</h1>
<h1>HTTP/1.0 신택스</h1>
<ul>
<li>매서드와 경로</li>
<li>헤더</li>
<li>바디</li>
<li>스테이터스 코드</li>
</ul>
<h2>1. HTTP 역사</h2>
<ul>
<li>IETF (the Internet Engineering Task Force) : 인터넷의 상호 접속성을 향상시키는 것을 목표로 만들어진 임의 단체</li>
<li>RFC (Request For Comments)
<ul>
<li>IETF 가 만든 규약 문서</li>
<li>통신의 상호접속성 유지를 위한 공통화된 사양서 모음</li>
</ul>
</li>
<li>IANA (Internet Assigned Numbers Authority)
<ul>
<li>포트번호와 파일타입(Content-Type) 등 웹에 관한 데이터베이스를 관리하는 단체</li>
<li>통신타입(프로토콜) 이 아닌 파일타입(데이터) 와 같은 정보를 관리</li>
</ul>
</li>
<li>W3C (World Wide Web Consortium)
<ul>
<li>웹 관련 표준화를 하는 비영리 단체</li>
<li>통신 규격이 아닌 브라우저에 특화된 기능을 담당</li>
<li>HTML 의 사양정첵, server-sent events, 웹소켓 등, API 를 동반하는 통신 프로토콜 담당</li>
</ul>
</li>
<li>WHATWG (Web Hypertext Application Technology Working Group) : 웹 관련 규격을 논의하는 단체. W3C 와 겸하는 멤버가 많다</li>
</ul>
<h2>2. HTTP/0.9</h2>
<p>단순히 경로를 통해 텍스트 정보가 담긴 파일을 가져오는 프로토콜로 시작 clint 에서 요청(<strong>request</strong>)을 하면 server 가 웹사이트 내용을 반환(<strong>response</strong>)해 준다</p>
<h2>3. HTTP/0.9 -&gt; HTTP/1.0</h2>
<h3>0.9 에서의 한계</h3>
<ul>
<li>하나의 문서밖에 전송하지 못함</li>
<li>HTML 문서가 아닌 형식을 콘텐츠를 전달할 수 없음</li>
<li>client 에서는 검색을 제외한 요청을 할 수 없음</li>
<li>새로운 정보의 전송, 갱신, 삭제할 수 없음</li>
<li>서버의 응답상태 알 수 없음</li>
</ul>
<h3>1.0 에서 추가된 것</h3>
<ul>
<li>요청 시 메서드 추가 : GET</li>
<li>요청 시 HTTP 버전 추가 : HTTP/1.0</li>
<li>요청시 헤더의 추가 : Host, User-Agent, Accept</li>
<li>응답 시 HTTP 버전과 스테이터스 코드 추가</li>
<li>응답 시 헤더의 추가 : Host, User-Agent, Accept</li>
</ul>
<h2>4. HTTP 와 전자메일 - 헤더</h2>
<ul>
<li>파일명(key):값 의 형식으로 본문 맨 앞에 부가</li>
<li>한줄에 하나의 값</li>
<li>본문과 헤더 사이에 하나의 빈줄</li>
<li>대, 소문자를 구별하지 않음</li>
<li>서버, 클라이언트 사이에 필요한 추가정보, 지시, 명령, 당부 등이 적힘</li>
<li>예시
<ul>
<li>client to server
<ul>
<li>User-Agent : 클라이언트가 자신의 애플리케이션의 이름을 적는 곳</li>
<li>Referer : 서버에서 참고하는 추가 정보, 클라이언트가 요청을 보낼 때 보고있던 페이지의 url 을 보내게 된다</li>
<li>Authorization
<ul>
<li>서버에 인증정보 전달</li>
<li>RFC 표준
<ul>
<li>Basic</li>
<li>Digest</li>
<li>Aearer</li>
</ul>
</li>
<li>아마존 웹 서비스나 깃허브 API 등 자체 표준</li>
</ul>
</li>
</ul>
</li>
<li>server to client
<ul>
<li>Content-Type : 파일의 종류를 지정, MIME 식별자를 사용</li>
<li>Content-Length : 바디의 크기, 압축이 이루어 지는 경우 압축 된 크기</li>
<li>Content-Encoding : 압축이 이루어 지는 경우 압축 형식</li>
<li>Date : 문서 날짜</li>
<li>이 밖의 X- 로 시작되는 헤더 : 각 애플리케이션에서 자유롭게 사용</li>
</ul>
</li>
</ul>
</li>
<li>이외에는 IANA 사이트에서 찾아보기</li>
</ul>
<h3>MIME type</h3>
<p>파일의 종류를 구별하는 문자열 - 초기에 전자메일을 위해 만들어짐</p>
<p>OS 에서는 - 윈도우 : 파일의 확장자 - mac os : resource fork 라는 이름의 파일의 메타데이터 를 보고 파일 종류를 판단함</p>
<p>브라우저에서는 MIME 타입이라는 식별자를 사용해 파일의 종류를 구분함 - 예시 : HTML 파일을 response 받았을때의 content-type - <code>Content-Type: text/html; charset=utf-8</code></p>
<h3>content-type 의 보안</h3>
<p>인터넷 익스플로러의 경우 옵션에 따라 MIME 타입이 아닌 내용을 보고 파일 형식을 추측함 - content sniffig</p>
<p>실제 보내는 형식이 아닌 다른 형식으로 추측을 할 수 있기때문에 막는것이 추세 - <code>X-Content-Type-Options: nosniff</code></p>
<h2>5. HTTP 의 조상 뉴스그룹</h2>
<p>HTTP 가 생기기 이전 프로토콜인 NNTP 를 사용 여기서 method, status code 두개의 기능이 HTTP 에 도입됨</p>
<h3>method</h3>
<p>지정된 주소에 있는 리소스에 대한 조작을 지시함 - GET : 서버와 헤더에 콘텐트 요청 - HEAD : 서버에 헤더만 요청 - POST : 새로운 문서 투고 - PUT : 이미 존재하는 url 의 문서를 갱신 - DELETE : 지정된 url 의 문서를 삭제</p>
<h3>status code</h3>
<p>세자리 숫자로 구성되었으며 서버의 응답을 한눈에 파악할 수 있음 - 100 번대 : 처리가 계속됨 - 200 번대 : 성공시의 응답 - 300 번대 : 서버에서 클라이언트로의 명령, 오류가 아니라 정상처리, 리디렉트나 캐시이용을 지시 - 400 번대 : 클라이언트가 보낸 요청에 오류가 있음을 알림 - 500 번대 : 서버 내부에서 오류가 발생함</p>
<h2>6. 리디렉트</h2>
<p>300 번대 스테이터스코드 일부는 서버가 브라우저에 리디렉트를 지시함 300 이외의 경우는 <code>Location</code> 헤더를 사용해 리디렉트 할 곳을 서버에서 클라이언트에 전달 - 301, 302, 303, 307, 308 다섯가지가 있다</p>
<p>301, 308 : 요청된 페이지가 다른 페이지로 이동했을때 사용, 영구적으로 이동 302, 307 : 일시적인 이동, 모바일 전용사이트나 관리페이지를 표시 303 : 요청된 페이지에 반환할 컨텐츠가 없거나 원래 반환해야 할 페이지가 따로 있을 때 사용, 영구적 이동</p>
<p>클라이언트는 300 번대 status code 가 반환 되면 Location 헤더 값을 보고 다시 서버에 요청함</p>
<h2>7. URL</h2>
<p>URI : URL 과 URN 을 포함 URL (Uniform Resource Locator) : 위치를 지정 URN (Uniform Resource Name) : 이름 규칙을 사용</p>
<p>사실상 URN 을 거의 사용하지 않으므로 URI 와 URL 을 동일시 할 수 있음</p>
<h3>구조</h3>
<p><code>https://profile.intra.42.fr/users/131666/resumes/7746</code> <code>스키마://호스트명/경로</code></p>
<ul>
<li>스키마 : https</li>
<li>호스트명 : profile.intra.42.fr</li>
<li>경로 : users/131666/resumes/7746</li>
</ul>
<p>이외에 URL 사양에 포함되는 모든 요소가 들어간 예제 <code>스키마://사용자:패스워드@호스트명:포트/경로#프래그먼트?쿼리</code></p>
<p>스키마 - 종류 : http, https, mailto, file, ftp, 등 - 브라우저가 스키마를 보고 적절한 접속 방법을 선택</p>
<p>호스트명 - 실제 통신을 하는 곳 - 하나의 호스트에 65535 개의 포트가 있으며 각각의 포트를 이용해 복수의 서버를 구동할 수 있음 - HTTP 는 80, HTTPS 는 443 을 사용함</p>
<p>사용자:패스워드 - ftp 등에서 사용되곤 함 - 위의 방식은 Basic 인증 방식으로 통신 내용이 보이거나 접속 로그가 남으면 패스워드가 누출될수 있기에 잘 사용하지 않음</p>
<p>프래그먼트 - HTML 페이지 내 링크에 앵커를 지정하는데 쓰임</p>
<p>쿼리 - 검색 용어를 지정하거나 표시할 웹에 특정 파라미터를 부여하는데 사용</p>
<p>URL 을 주소를 지정하지만 <strong>사용자가 읽는 문장</strong></p>
<p>URL 의 길이에는 제한이 없으나 인터넷 익스플로러가 한번에 2083자 까지만 다룰 수 있어 <strong>대체로 2000자</strong> 의 규격이 생기게 됨</p>
<h3>국제화</h3>
<p>원래는 영, 숫자와 하이픈(-) 만 사용할 수 있었지만 퓨니코드가 구현된 브라우저는 인코딩을 해 다른 언어들도 사용할 수있게됨 퓨니코드는 xn- 으로 시작된 문자열을 생성</p>
<h2>8. BODY</h2>
<p>헤더의 끝에 빈 줄을 넣으면 그 뒤의 내용을 전부 바디가 됨</p>
<p>HTTP 응답에서의 body는 한번 응답에 하나의 파일을 반환함 form 이나 XMLHttpRequest 를 사용해 클라이언트에서 서버로 데이터를 전송 할때도 요청에 body 가 포함되는 것 외에는 같음 이때 읽어올 바이트의 수는 Content-Length 헤더로 지정</p>
<h3>GET 요청에서의 body</h3>
<p>GET 이나 HEAD 요청에서는 body 를 포함하는 것이 <strong>기대되지 않음</strong></p>
<p>하지만 <strong>어떤 요청의 메세지라도 바디의 포함이 허용되어있으며 이를 염두에 두고 해석해야함</strong></p>

        </article>
        
    </main>

        <footer>
        <p>Generated by SuGo</p>
    </footer>

</body>
</html>


