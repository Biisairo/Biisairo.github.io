<!DOCTYPE html>



<html>
<head>
    <meta charset="UTF-8">
    <title>5장</title>
    <link rel="icon" href="https://biisairo.github.io/static/favicon.ico" type="image/x-icon">
</head>
<body>
        <header>
        <nav>
            <ul>
                

                <li><a href="https://biisairo.github.io/">Home</a></li>
                
                    <li><a href="https://biisairo.github.io/About/">About</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/">Study</a></li>
                
                    <li><a href="https://biisairo.github.io/Contact/">Contact</a></li>
                
            </ul>
        </nav>

            <style>
 
html, body {
    height: 100%;
    margin: 0;
}

body {
    display: flex;
    flex-direction: column;
    max-width: 720px;
    margin: 0 auto;
    padding: 2rem 1rem;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
                Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
    line-height: 1.6;
    background: #222831;
    color: #EEEEEE;
}

header, footer {
    text-align: center;
    margin-bottom: 2rem;
}

nav ul {
    list-style: none;
    padding: 0;
    display: flex;
    justify-content: space-between;
    align-items: flex-end;  
    flex-wrap: wrap;
    gap: 1rem;
}

nav li:first-child {
    margin-right: auto;  
}

nav li:not(:first-child) {
    margin-left: 0;
}

nav li:first-child a {
    color: #EEEEEE;
    font-size: 1.5em;
    text-decoration: none;  
}

nav li:first-child a:hover {
    color: #aadadf;  
}

nav a {
    color: #00ADB5;
    text-decoration: underline;
    transition: color 0.3s ease;
}

nav a:hover {
    color: #66C1C9;
    text-decoration: none;
}

main a,
article a,
footer a {
    color: #33d3c8;
    text-decoration: underline;
    transition: color 0.3s ease;
}

main a:hover,
article a:hover,
footer a:hover {
    color: #66C1C9;
    text-decoration: none;
}

 
main {
    flex: 1;
    margin-bottom: 2rem;
}

h1, h2, h3 {
    line-height: 1.3;
    margin-top: 2rem;
    margin-bottom: 1rem;
    color: #00ADB5;
}

ul {
    padding-left: 1.5rem;
}

article {
    margin-top: 2rem;
    border: 1px solid #33d3c8;
    padding: 1rem;
    border-radius: 5px;
}

footer p {
    font-size: 0.9rem;
    color: #AAAAAA;
}

    </style>

    </header>

    <main>
        
            
        

        
            <h2>하위 페이지</h2>
            <ul>
                
                    <li><a href="https://biisairo.github.io/Study/%eb%a6%ac%ec%96%bc%ec%9b%94%eb%93%9c%20HTTP/1%ec%9e%a5.html">1장</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%eb%a6%ac%ec%96%bc%ec%9b%94%eb%93%9c%20HTTP/2%ec%9e%a5.html">2장</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%eb%a6%ac%ec%96%bc%ec%9b%94%eb%93%9c%20HTTP/3%ec%9e%a5.html">3장</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%eb%a6%ac%ec%96%bc%ec%9b%94%eb%93%9c%20HTTP/4%ec%9e%a5.html">4장</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%eb%a6%ac%ec%96%bc%ec%9b%94%eb%93%9c%20HTTP/5%ec%9e%a5.html">5장</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%eb%a6%ac%ec%96%bc%ec%9b%94%eb%93%9c%20HTTP/6%ec%9e%a5.html">6장</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%eb%a6%ac%ec%96%bc%ec%9b%94%eb%93%9c%20HTTP/7%ec%9e%a5.html">7장</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%eb%a6%ac%ec%96%bc%ec%9b%94%eb%93%9c%20HTTP/8%ec%9e%a5.html">8장</a></li>
                
            </ul>
        
        
        
            
            <article>
                <h1>5장</h1>
<h1>HTTP/2 의 신택스 : 프로토콜 재정의</h1>
<h2>1. HTTP/2</h2>
<ul>
<li>스트림을 사용해 바이너리 데이터를 다중으로 송수신</li>
<li>스트림 내 우선순위 설정과 서버 사이드에서 데이터 통신을 하는 서버사이드 푸시 구현</li>
<li>헤더 압축</li>
</ul>
<p>기존의 HTTP 가 제공하는 네개의 기본요소들은 바뀌지 않음</p>
<p>이전 버전에서 바뀌면서 달라진 점은 통신의 고속화</p>
<p>프로토콜의 개선사항 - 캐시 (age-max) - 통신 자체를 취소 - 캐시 (ETag, Date) - 변경이 없으면 바디 전송을 취소 - Keep-Alive - 액세스마다 연결에 걸리는 시간을 줄임 - 압축 - 응답 바디크기 절감 - 청크 - 응답 전송 시작이 빨라짐 - 파이프라이닝 - 통신 다중화</p>
<h3>스트림을 이용한 통신 고속화</h3>
<p>HTTP/2 의 최대 변경점을 기존 텍스트 기반 프로토콜에서 바이너리 기반 프로토콜로 변화했다는 점 각각의 데이터는 프레임 단위로 송수신이 됨</p>
<p>스트림 - 가상의 TCP 소켓 - 프레임에 따라 간단히 만들고 닫을 수 있음 - 일반 TCP 소켓과 같은 핸드셰이크가 필요없음</p>
<h3>HTTP/2.0 의 애플리케이션 계층</h3>
<p>데이터를 바이너리화 TCP 소켓 레이어는 데이터를 프레임 단위로 분리할 수 있어 수신측의 버퍼를 비우기 쉽고 통신 상대에게 다음 데이터를 고속으로 보내줄 수 있음</p>
<h3>플로 컨트롤</h3>
<p>스트림을 효율적으로 흐르게 하기위해 이용되는 통신량 제어 처리 통신 속도가 지나치게 차이나는 기기의 조합으로 인한 사태를 방지</p>
<h3>서버 푸시</h3>
<p>우선운위가 높은 컨텐츠를 클라이언트가 요구하기 전에 전송할 수 있게 됨 웹소켓처럼 양방향 통신을 실현하는 것이 아닌 css, js, 이미지 등 웹 페이지를 구성하는 파일을 다운로드 하는데 이용</p>
<p>푸시된 컨텐츠는 사전에 캐시로 들어가며 클라이언트가 해당 컨텐츠를 요청하면 캐시에서 사용</p>
<h3>HPACK 을 이용한 헤더 압축</h3>
<p>HTTP 에서 헤더에 자주 사용하는 이름이나 결과를 미리 사전에 등록 해 두고 사용하는 식으로 압축을 함</p>
<h3>SPDY, QUIC</h3>
<p>SPDY - 구글이 개발한 HTTP 대체 프로토콜로 HTTP/2 전신이며 그대로 HTTP/2 로 구현됨 - HTTP 의 전송속도를 높이기 위해 개발</p>
<p>QUIC - 위의 SPDY 를 더 빠르게 만들기 위함 프로토콜 - TCP 와 UDP 를 통합해 더 적은 횟수로 통신을 가능하게 함</p>
<h2>2. Fetch API</h2>
<p>XMLHttpRequest 와 같이 서버 액세스를 하는 함수 js 에서 사용</p>
<ul>
<li>XMLHttpRequest 보다 서버 밖으로의 액세스 등 CORS 제어가 쉬워짐</li>
<li>js 의 비동기 처리방식인 Promise 를 따름</li>
<li>캐시 제어 가능</li>
<li>리다이렉트 제어 가능</li>
<li>리퍼러 정책 설정 가능</li>
<li>Service Work 내에서 이용 가능</li>
</ul>
<h3>사용법</h3>
<ol>
<li>XMLHttpRequest 처럼 객체를 만드는 것이 아닌 fetch 함수를 호출한다</li>
<li>두번째 인자로 옵션 객체를 넣어준다</li>
<li>.then() 함수에 서버 응답이 돌아온 후에 호출되는 콜백을 넘겨준다</li>
<li>위의 .then() 을 실행한 후 promise 를 반환하면 다시 .then() 을 호출한다</li>
</ol>
<p>CORS 안전 메서드 - GET - HEAD - POST 금지 메서드 - CONNECT - TRACE - TRACK</p>
<h3>fetch 만이 할 수 있는 것</h3>
<p>캐시 제어</p>
<p>[[Programming/http/fetch cache.png|500]]</p>
<p>리다이렉트 제어</p>
<p>[[Programming/http/fetch redirect.png|500]]</p>
<p>Service Work 대응 - 현재 service work 에서 외부로 접속</p>
<h2>3. server-sent events</h2>
<p>HTML5 의 기능 기술적으로 HTTP/1.1 의 청크 형식을 이용한 통신 기능을 바탕으로 만등러짐</p>
<p>청크의 <strong>조금씩 전송</strong> 한다는 특징을 응용해 서버에서 임의의 시점에 클라이언트에 이벤트를 통지</p>
<p>HTTP 는 기본적으로 <strong>클라이언트의 요청-&gt;서버의 응답</strong> 으로 이루어진 모델 통신의 시작은 클라이언트가 결정하며 클라이언트의 1회 요청에 서버는 1회 응답하는 것이 기본</p>
<p>서버에서 정보를 돌려주는 방식은 <strong>코멧</strong> 방식이 있다 클라이언트에서 정기적으로 서버에서 이벤트를 검출(폴링)하거나 요청을 받은 상태에서 응답을 보류하는(롱 폴링) 방법이 사용됨</p>
<p>server-sent events 는 롱 폴링 방식과 청크 방식응 조합해 한번의 요청에 대해 서버에서 여러번의 이벤트를 전송함</p>
<p>검증된 청크 방식을 사용하여 프록시 지원도 포함하고있어 하위호환에도 문제가 없음</p>
<p>청크방식을 이용하긴 하나 HTTP 위에 별도의 텍스트 프로토콜을 실어 사용 이것은 이벤트 스트림으로 불리며 MIME type 은 text/event-stream</p>
<p>네 종류의 태그를 사용 - id - 이벤트를 식별하는 ID - 재전송 처리에 사용 - event - 이벤트 이름 - data - 이벤트와 함께 보낼 데이터 - retry - 재접속 대기시간 (ms)</p>
<p>js 에서는 server-sent events 에 EventSource 클래스를 사용하여 액세스함</p>
<h2>4. 웹 소켓</h2>
<p>서버/클라이언트간에 오버헤드가 적은 양방향 통신을 지원 통신이 확립되면 서버/클라이언트 사이에서 일대일 통신을 수행</p>
<p>프레임 단위로 송수신 하며 상대방이 정해져 있으므로 전송할 곳의 관한 정보는 가지지 않음 - HTTP 에서 body 만 보내는 것과 같음</p>
<h3>웹 소켓은 스테이트 풀</h3>
<p>스테이트풀 통신 - 서버가 클라이언트의 상태를 보존함을 의미 - 둘간의 통신에서 이전의 요청이 다음의 요청에 영향을 미치게 된다 - 서버가 이전 통신에 관해 기억하고 있기 때문에 이전 통신의 정보를 다시금 보낼 필요가 없어 적은 오버헤드로 통신이 가능하다</p>
<h3>js 의 클라이언트 API</h3>
<p>웹소켓은 HTTP 의 하위 레이어인 TCP 소켓에 가까운 기능을 제공하는 API 통신은 서버가 수신을 기다리는 상태에서 <strong>반드시</strong>클라이언트쪽에서 접속함</p>
<ol>
<li>서버가 특정 IP 주소, 포트번호로 시작한다 (Listen)</li>
<li>클라이언트가 서버에 통신을 시작한다고 선언한다 (Connect)</li>
<li>클라이언트가 보낸 접속 요청을 서버가 받아들인다 (Accept)</li>
<li>서버에는 소켓 클래스의 인스턴스가 넘어온다</li>
<li>서버가 받아서 처이라면 클라이언트의 소켓 인스턴스는 송, 수신을 할 수 있게된다</li>
</ol>
<h3>접속</h3>
<p>프로토콜 업그레이드를 사용</p>
<p>클라이언트에서 서버로 연결 요청을 보냄 이때 upgrade 헤더를 이용해 websocket 으로 업그레이드를 요청</p>
<h3>Socket.IO</h3>
<p>socket.io 라는 라이브러리를 사용해 쉽게 사용 가능</p>
<ul>
<li>웹소켓을 사용할 수 없는 상황에서는 XMLHttpRequest 에 의한 롱 폴링을 사용해 웹소켓을 에뮬레이션</li>
<li>웹소켓 단절 시 자동으로 재접속</li>
<li>서버에서 클라이언트가 기대하는 절차로 XMLHttpRequest 통신을 핸들링할 수 있다</li>
</ul>
<p>당시에는 웹소켓이 활발하게 사용되지 않아 하위호환성을 위해 많이 사용했지만 이제는 굳이…?</p>
<h2>5. WebRTC : Web real time communication</h2>
<p>지금까지의 프로토콜은 클라이언트/서버의 통신만을 위한 프로토콜 이었다면 WebRTC 는 클라이언트 끼리의 P2P 통신에도 이용됨 실시간 커뮤니케이션의 줄임말로 화상전화와 같은 실시간 통신을 위해 개발됨 사용법은 <strong><a href="https://webrtc.org/?hl=ko">https://webrtc.org/?hl=ko</a></strong> 확인</p>
<p>사용의 목적이 다르기 때문에 사용되는 기능도 다르다 TCP 가 아닌 실시간에 더 최적화 된 UDP 사용</p>
<h3>활용사례</h3>
<p>client to client - 화상통화 시스템 - 제전송처리, 통신량의 제한을 직접 구현하는 UDP 를 사용 - 단 보안을 위해 UDP 용 TLS 인 DTSL 로 암호화 - 스크린 공유 - 파일교환 - 중앙 서버를 이용하지 않는 화상 회의 - 온라인게임</p>
<p>client to server - 고객센터 - IP 전화 - 중앙 서버를 이용한 화상회의</p>
<h2>6. HTTP 웹 푸시</h2>
<p>웹사이트에서 스마트폰의 앱과 같은 알람기능을 제공하는 기능 지금까지의 기능들은 모두 브라우저가 활성화 되어 있는 것을 전제로 작동함</p>
<p>웹 푸시는 브라우저가 그 시점에 실행되어 있지 않거나 오프라인 이어도 사용자에게 알림을 보낼 수 있음 service worker 를 사용</p>
<p>현재의 푸시 서비스와 연계하여 구현 됨</p>
<ol>
<li>브라우저에서 푸시 서비스 이용을 등록함
<ul>
<li>푸시 알림은 사용자의 허가가 필요한 opt-in 방식</li>
</ul>
</li>
<li>사용자가 허가하면 푸시 서비스에 등록</li>
<li>활성화 되면 service worker 로 등록한 push 이벤트 알람이 오게 됨</li>
</ol>
<ul>
<li>사용자가 push 알림을 승인하게 되면 푸시 서비스에 가입하게 되며 키를 생성함
<ul>
<li>키의 정보는 푸시 서비스가 브라우저를 식별하는데에 사용</li>
</ul>
</li>
<li>브라우저가 키를 서버에 보내면 서버는 알림을 특정 브라우저로 보낼 수 있게 됨</li>
<li>서버는 브라우저에서 온 키를 이용해 푸시 서비스를 요청</li>
</ul>

            </article>
            
        
    </main>

        <footer>
        <p>Generated by SuGo</p>
    </footer>

</body>
</html>


