<!DOCTYPE html>



<html>
<head>
    <meta charset="UTF-8">
    <title>8 가상메모리</title>
    <link rel="icon" href="https://biisairo.github.io/static/favicon.ico" type="image/x-icon">
</head>
<body>
        <header>
        <nav>
            <ul>
                

                <li><a href="https://biisairo.github.io/">Home</a></li>
                
                    <li><a href="https://biisairo.github.io/About/">About</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/">Study</a></li>
                
                    <li><a href="https://biisairo.github.io/Contact/">Contact</a></li>
                
            </ul>
        </nav>

            <style>
 
html, body {
    height: 100%;
    margin: 0;
}

body {
    display: flex;
    flex-direction: column;
    max-width: 720px;
    margin: 0 auto;
    padding: 2rem 1rem;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
                Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
    line-height: 1.6;
    background: #222831;
    color: #EEEEEE;
}

header, footer {
    text-align: center;
    margin-bottom: 2rem;
}

nav ul {
    list-style: none;
    padding: 0;
    display: flex;
    justify-content: space-between;
    align-items: flex-end;  
    flex-wrap: wrap;
    gap: 1rem;
}

nav li:first-child {
    margin-right: auto;  
}

nav li:not(:first-child) {
    margin-left: 0;
}

nav li:first-child a {
    color: #EEEEEE;
    font-size: 1.5em;
    text-decoration: none;  
}

nav li:first-child a:hover {
    color: #aadadf;  
}

nav a {
    color: #00ADB5;
    text-decoration: underline;
    transition: color 0.3s ease;
}

nav a:hover {
    color: #66C1C9;
    text-decoration: none;
}

main a,
article a,
footer a {
    color: #33d3c8;
    text-decoration: underline;
    transition: color 0.3s ease;
}

main a:hover,
article a:hover,
footer a:hover {
    color: #66C1C9;
    text-decoration: none;
}

 
main {
    flex: 1;
    margin-bottom: 2rem;
}

h1, h2, h3 {
    line-height: 1.3;
    margin-top: 2rem;
    margin-bottom: 1rem;
    color: #00ADB5;
}

ul {
    padding-left: 1.5rem;
}

article {
    margin-top: 2rem;
}

footer p {
    font-size: 0.9rem;
    color: #AAAAAA;
}

    </style>

    </header>

    <main>
        
            
        

        
            <h2>하위 페이지</h2>
            <ul>
                
                    <li><a href="https://biisairo.github.io/Study/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/2%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%20%ea%b0%9c%ec%9a%94.html">2 운영체제 개요</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/3%20%ec%bb%b4%ed%93%a8%ed%84%b0%20%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98%20%eb%8f%99%ec%9e%91%20%ec%9b%90%eb%a6%ac.html">3 컴퓨터 시스템의 동작 원리</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/4%20%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8%ec%9d%98%20%ea%b5%ac%ec%a1%b0%ec%99%80%20%ec%8b%a4%ed%96%89.html">4 프로그램의 구조와 실행</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/5%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%ea%b4%80%eb%a6%ac.html">5 프로세스 관리</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/6%20CPU%20%ec%8a%a4%ec%bc%80%ec%a4%84%eb%a7%81.html">6 CPU 스케줄링</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/7%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%ea%b4%80%eb%a6%ac.html">7 메모리 관리</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/8%20%ea%b0%80%ec%83%81%eb%a9%94%eb%aa%a8%eb%a6%ac.html">8 가상메모리</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/9%20%eb%94%94%ec%8a%a4%ed%81%ac%20%ea%b4%80%eb%a6%ac.html">9 디스크 관리</a></li>
                
            </ul>
        
        
        
        <article>
            <h1>8. 가상메모리</h1>
<h2>0.</h2>
<ul>
<li>가상 메모리 (virtual memory)
<ul>
<li>0번지 부터 시작하는 프로세스 자기만의 메모리 주소 공간</li>
</ul>
</li>
<li>각각의 프로세서는 가상 메모리를 가지고 있으며 실제 사용될때는 이를 물리 메모리나 스왑 영역에 올려서 사용한다</li>
</ul>
<h2>1. 요구 페이징 (demand paging)</h2>
<ul>
<li>프로그램 실행 시 당장 사용할 페이지만 메모리에 올려 사용하는 방식</li>
<li>특정 페이지를 cpu 의 요청에 따라 메모리에 적재</li>
<li>실제 사용중인 부분만 메모리에 적재하고 다른 부분은 스왑 영역에 존재</li>
<li>유효-무효 비트를 사용해 해당 페이지가 메모리에 올라와 있는지 표시</li>
<li>페이지 부재 (page fault)
<ul>
<li>cpu 가 참조 하려는 페이지가 메모리에 올라와있지 않은 (유효-무효 비트가 무효인) 상황</li>
</ul>
</li>
<li>요구 페이징의 페이지 부재 처리
<ul>
<li>cpu 가 무효 페이지에 접근 요청</li>
<li>MMU 가 페이지 부제 트랩 (page fault trap) 발생</li>
<li>cpu 커널모드 진입</li>
<li>운영체제의 페이지 부제 처리 루틴 (page fault handler) 실행</li>
<li>적법한 페이지인지 확인
<ul>
<li>사용하지 않는 영역의 페이지에 접근하거나 해당 페이지에 대한 접근 원한을 위반한경우 (protection violation) 프로세스를 종료시킴</li>
</ul>
</li>
<li>적법한 페이지로의 접근인 경우 물리적 메모리에서 비어있는 프레임을 할당받아 페이지를 적재
<ul>
<li>비어있는 프레임이 없는 경우 사용하지 않는 프로세스의 페이지를 스왑 공간으로 이동(스왑 아웃)</li>
</ul>
</li>
<li>페이지 부재처리는 디스크-메모리간에 데이터 이동이 필요해 많은 시간이 걸림
<ul>
<li>cpu 제어권을 뺏긴 봉쇄상태에서 진행됨</li>
</ul>
</li>
<li>데이터의 이동이 끝난 뒤 해당 페이지의 유효-무효 비트를 유효로 설정한 뒤 해당 프로세스를 준비 큐로 이동</li>
</ul>
</li>
<li>요구 페이징의 성능
<ul>
<li>페이지 부재의 발생 빈도에 따라 성능차이가 결정 됨</li>
</ul>
</li>
</ul>
<h2>2. 페이지 교체 (page replacement)</h2>
<ul>
<li>페이지 부제가 발생했을 시 메모리에 남은 프레임이 없을때 이미 적재된 페이지를 스왑 아웃 하는 과정</li>
<li>교체 알고리즘 (replacement algorithm)
<ul>
<li>페이지 교체시 어떤 페이지를 스왑 아웃할지를 결정하는 알고리즘</li>
<li>페이지 부제율을 최소화 하는 것이 목표</li>
<li>가까운 시일에 참조될 가능성이 적은 페이지를 스왑아웃 하는 것이 좋음</li>
</ul>
</li>
<li>페이지 참조열 (page reference string)
<ul>
<li>참조되는 페이지들의 번호를 시간의 순서에 따라 나열한 것</li>
<li>해당 번호의 페이지가 이미 메모리에 적재되어있으면 메모리에 적중 (hit) 되었다고 함</li>
<li>메모리에 없는 경우 페이지 부재가 발생한 것</li>
</ul>
</li>
<li>최적 페이지 교체
<ul>
<li>빌레디의 최적 알고리즘 (Belady’s optomal algorithm)</li>
<li>미래에 어떤 페이지가 참조될 지 알고있는 상황에서 사용
<ul>
<li>오프라인 알고리즘</li>
<li>↔ 온라인 알고리즘</li>
</ul>
</li>
<li>페이지 교체 시 적재되어있는 페이지 중 가장 나중에 참조가 되는 페이지를 스왑 아웃</li>
<li>실제 시스템에서는 어떤 페이지를 참조할 지 모르기때문에 실제로 사용할 수 있는 알고리즘은 아님</li>
<li>어떠한 알고리즘 보다 적은 페이지 부재율을 보장하며 다른 알고리즘의 성능에 대한 상한선을 나타냄</li>
</ul>
</li>
<li>선입 선출 알고리즘
<ul>
<li>페이지 교체 시 제일 먼저 올라온 페이지를 스왑아웃</li>
<li>물리적 메모리에 제일 먼저 적재된 페이지를 스왑아웃</li>
<li>먼저 들어온 페이지를 자주 참조하는 경우 잦은 스왑아웃이 생김</li>
</ul>
</li>
<li>LRU (least recently used) 알고리즘
<ul>
<li>시간 지역성 (temporal locality)
<ul>
<li>최근에 참조된 페이지가 가까운 미래에 다시 참조될 가능성이 높은 성질</li>
</ul>
</li>
<li>가장 오래전에 참조 된 페이지를 스왑아웃</li>
</ul>
</li>
<li>LFU (least frequently used) 알고리즘
<ul>
<li>페이지의 참조 횟수로 교체시킬 페이지를 정하는 방식</li>
<li>적재 되어있는 페이지 중 과거에 참조 횟수가 가장 적었던 페이지를 스왑아웃</li>
<li>incache-LFU
<ul>
<li>페이지가 물리적 메모리에 적재된 이후부터 카운트</li>
<li>해당 페이지가 스왑아웃 되고 다시 적재되면 1부터 다시 카운트함</li>
</ul>
</li>
<li>perfect-LFU
<ul>
<li>메모리에 적재된 여부와 상관 없이 실제 해당 페이지를 참조한 횟수를 카운트</li>
<li>메모리에서 쫒겨난 페이지들의 참조기록까지 전부 보관하고 있어야 하기때문에 상대적으로 오버헤드가 큼</li>
</ul>
</li>
</ul>
</li>
<li>클럭 (clock) 알고리즘
<ul>
<li>LRU, LFU 는 페이지의 참조시각, 참조횟수를 보관, 기록하고 비교해야 함으로 운영체제에 시공간적인 오버헤드가 생김</li>
<li>하드웨어의 지원을 통해 오버헤드를 줄이는 방법</li>
<li>NUR(not used recently), NRU(not recently used) 라고도 불림</li>
<li>최근에 참조된 것이 아닌, 참조가 된지 오래된 페이지 중 하나를 골라 스왑아웃</li>
<li>LRU 처럼 가장 오래되었다는 것을 보장하지는 않으나 하드웨어의 지원으로 훨씬 빠른 속도가 나오게 되어 많은 시스템에서 사용함</li>
<li>참조 비트 (reference bit)
<ul>
<li>각 프레임마다 하나씩 존재</li>
<li>프레임의 페이지가 참조될 때 하드웨어에 의해 1 로 세팅됨</li>
</ul>
</li>
<li>페이지 프레임의 참조 비트를 순차적으로 확인</li>
<li>참조비트가 1인 페이지는 0으로 초기화</li>
<li>참조 비트가 0인 페이지부터 스왑아웃</li>
<li>시곗바늘처럼 프레임들을 순차적으로 돌면서 스왑아웃시킬 페이지를 탐색</li>
<li>모든 프레임을 한번씩 확인할 시간동안 페이지를 메모리에 유지시켜 둠으로서 페이지 부재율을 줄이도록 설계됨
<ul>
<li>2차 기회 알고리즘 (second chance algorithm) 이라고도 부름</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>3. 페이지 프레임의 할당</h2>
<ul>
<li>여러개의 프로세스가 실행되고 있는 상황에서 어느 프로세스에 얼마만큼의 메모리를 할당 해 주어야 하는지를 결정해야 함</li>
<li>균등 할당 (equal allocation) 알고리즘
<ul>
<li>모든 프로세스에 균등한 프레임을 할당</li>
</ul>
</li>
<li>비례 할당 (proportional allocation) 알고리즘
<ul>
<li>프로세스의 크기에 비례해 프레임을 할당</li>
</ul>
</li>
<li>우선순위 할당 (priority allocation) 알고리즘
<ul>
<li>CPU 에서 당장 실행될 프로세스와 그렇지 않은 프로세스를 구분하여 전자쪽에 더 많은 프레임을 할당</li>
</ul>
</li>
<li>실제로는 위의 알고리즘 뿐만 아니라 다른 정보들을 추가로 사용하여 할당하게 됨</li>
</ul>
<h2>4. 전역교체와 지역교체</h2>
<ul>
<li>전역교체 (global replacement)
<ul>
<li>모든 페이지 프레임이 교체대상이 됨</li>
<li>전체 메모리를 각 프로세스가 공유하며 교체 알고리즘에 따라 할당되는 메모리의 양이 가변적으로 바뀜</li>
<li>전역으로 페이지 프레임을 관리하기 때문에 스왑 아웃되는 페이지가 수행중인 프로세스의 페이지와 다를 수 있음</li>
</ul>
</li>
<li>지역교체 (local replacement)
<ul>
<li>현재 수행중인 프로세스에게 할당 된 프레임만 교체가 됨</li>
<li>프로세스마다 페이지 프레임을 미리 할당하는것이 전제</li>
<li>프로세스별로 페이지를 관리하기 때문에 프로세스에게 할당된 프레임 내에서만 스왑할 수 있음</li>
</ul>
</li>
</ul>
<h2>5. 스레싱 (thrashing)</h2>
<ul>
<li>프로세스가 적은 양의 프레임을 할당 받아 페이지 부재율 (page fault rate) 이 증가해 CPU 이용률 (CPU utilization) 이 떨어지는 현상</li>
<li>준비 큐에 프로세스가 존재하는 경우는 CPU 를 사용중이라는 뜻 이기 때문에 CPU 사용률이 높다</li>
<li>모든 프로세스가 I/O 작업을 함에 따라 CPU 를 사용하지 않게되는 경우 준비 큐가 비게되고 CPU 사용량이 줄게 된다</li>
<li>CPU 사용량이 낮으면 운영체제는 메모리에 올라가는 프로세스의 양을 늘린다</li>
<li>다중 프로그래밍의 정도 (Multi-Programming Degree: MPD)
<ul>
<li>메모리에 동시에 올라가 있는 프로세스의 수</li>
</ul>
</li>
<li>MPD 가 늘어나면 프로세스당 할당하는 프레임의 수가 줄어든다</li>
<li>할당받은 프레임의 수가 줄어들면 페이지 부재가 늘어난다</li>
<li>페이지 부제가 늘어남에 따라 스왑 인, 아웃이 늘어나고 이는 더 많은 I/O 입출력을 동반한다</li>
<li>위와같은 상황이 반복적으로 일어나며 CPU 이용률이 떨어지는 현상을 스레싱이라고 한다</li>
<li>해결방안
<ul>
<li>워킹셋 (working-set) 알고리즘
<ul>
<li>지역성 집합 (locality set)
<ul>
<li>프로세스를 일정시간 동안 특정 주소영역을 집중적으로 참조하는 경향이 있음</li>
<li>이때 집중적으로 참조되는 페이지들의 집합</li>
</ul>
</li>
<li>지역성 집합이 메모리에 동시에 올라갈 수 있도록 보장하는 메모리 관리 알고리즘</li>
<li>워킹셋 (working-set)
<ul>
<li>프로세스가 일정 시간동안 원활히 수행되기 위해 한꺼번에 메모리에 올라와 있어야 하는 페이지들의 집합</li>
</ul>
</li>
<li>프로세스의 워킹셋이 한번에 메모리에 올라갈 수 있는 경우에만 프레임을 할당함</li>
<li>그렇지 않은 경우 프로세스에 할당된 프레임을 전부 반납시킨 뒤 프로세스의 주소공간 전체를 스왑 아웃 함</li>
</ul>
</li>
<li>페이지 부재 빈도 (page-fault frequency: PFF) 알고리즘
<ul>
<li>프로세스의 페이지 부재율을 주기적으로 조사한 값을 이용하여 프로세스에 할당할 메모리 양을 동적으로 조절하는 방식</li>
<li>특정 프로세스의 페이지 부재율이 정해둔 상한선을 넘어가면 프로세스에 할당된 프레임이 부족하다고 판단하여 추가 할당을 하게 됨</li>
<li>이때 남은 프레임이 없으면 일부 프로세스를 스왑 아웃 시킴</li>
<li>반대로 프로세스의 페이지 부재율이 정해둔 하한선 아래로 내려가면 프로세스에 할당된 프레임이 과하다고 판단하여 할당된 프레임의 수를 줄임</li>
</ul>
</li>
</ul>
</li>
</ul>

        </article>
        
    </main>

        <footer>
        <p>Generated by SuGo</p>
    </footer>

</body>
</html>


