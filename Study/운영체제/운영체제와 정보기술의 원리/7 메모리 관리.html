<!DOCTYPE html>



<html>
<head>
    <meta charset="UTF-8">
    <title>7 메모리 관리</title>
    <link rel="icon" href="https://biisairo.github.io/static/favicon.ico" type="image/x-icon">
</head>
<body>
        <header>
        <nav>
            <ul>
                

                <li><a href="https://biisairo.github.io/">Home</a></li>
                
                    <li><a href="https://biisairo.github.io/About/">About</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/">Study</a></li>
                
                    <li><a href="https://biisairo.github.io/Contact/">Contact</a></li>
                
            </ul>
        </nav>

            <style>
 
html, body {
    height: 100%;
    margin: 0;
}

body {
    display: flex;
    flex-direction: column;
    max-width: 720px;
    margin: 0 auto;
    padding: 2rem 1rem;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
                Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
    line-height: 1.6;
    background: #222831;
    color: #EEEEEE;
}

header, footer {
    text-align: center;
    margin-bottom: 2rem;
}

nav ul {
    list-style: none;
    padding: 0;
    display: flex;
    justify-content: space-between;
    align-items: flex-end;  
    flex-wrap: wrap;
    gap: 1rem;
}

nav li:first-child {
    margin-right: auto;  
}

nav li:not(:first-child) {
    margin-left: 0;
}

nav li:first-child a {
    color: #EEEEEE;
    font-size: 1.5em;
    text-decoration: none;  
}

nav li:first-child a:hover {
    color: #aadadf;  
}

nav a {
    color: #00ADB5;
    text-decoration: underline;
    transition: color 0.3s ease;
}

nav a:hover {
    color: #66C1C9;
    text-decoration: none;
}

main a,
article a,
footer a {
    color: #33d3c8;
    text-decoration: underline;
    transition: color 0.3s ease;
}

main a:hover,
article a:hover,
footer a:hover {
    color: #66C1C9;
    text-decoration: none;
}

 
main {
    flex: 1;
    margin-bottom: 2rem;
}

h1, h2, h3 {
    line-height: 1.3;
    margin-top: 2rem;
    margin-bottom: 1rem;
    color: #00ADB5;
}

ul {
    padding-left: 1.5rem;
}

article {
    margin-top: 2rem;
}

footer p {
    font-size: 0.9rem;
    color: #AAAAAA;
}

    </style>

    </header>

    <main>
        
            
        

        
            <h2>하위 페이지</h2>
            <ul>
                
                    <li><a href="https://biisairo.github.io/Study/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/2%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%20%ea%b0%9c%ec%9a%94.html">2 운영체제 개요</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/3%20%ec%bb%b4%ed%93%a8%ed%84%b0%20%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98%20%eb%8f%99%ec%9e%91%20%ec%9b%90%eb%a6%ac.html">3 컴퓨터 시스템의 동작 원리</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/4%20%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8%ec%9d%98%20%ea%b5%ac%ec%a1%b0%ec%99%80%20%ec%8b%a4%ed%96%89.html">4 프로그램의 구조와 실행</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/5%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%ea%b4%80%eb%a6%ac.html">5 프로세스 관리</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/6%20CPU%20%ec%8a%a4%ec%bc%80%ec%a4%84%eb%a7%81.html">6 CPU 스케줄링</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/7%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%ea%b4%80%eb%a6%ac.html">7 메모리 관리</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/8%20%ea%b0%80%ec%83%81%eb%a9%94%eb%aa%a8%eb%a6%ac.html">8 가상메모리</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/9%20%eb%94%94%ec%8a%a4%ed%81%ac%20%ea%b4%80%eb%a6%ac.html">9 디스크 관리</a></li>
                
            </ul>
        
        
        
        <article>
            <h1>7. 메모리 관리</h1>
<h2>0.</h2>
<ul>
<li>n비트 컴퓨터에서는 2^n 개의 주소를 가지고 있음
<ul>
<li>현재 우리가 쓰는 64bit 의 컴퓨터에는 2^64 개의 주소를 가질 수 있음</li>
<li>과거에 쓰던 32bit 컴퓨터는 2^32 개, 즉 4294967296 개의 주소를 가질 수 있으며 이는 약 4GB
<ul>
<li>과거의 컴퓨터가 4GB 램까지밖에 지원을 안하던 이유</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>1. 주소 바인딩 (address binding)</h2>
<ul>
<li>논리적 주소(logical address), 가상 주소 (virtual address)
<ul>
<li>프로그램이 메모리에 적재될 때 생성되는 해당 프로세스를 위한 독자적인 주소공간</li>
<li>논리적 주소는 각 프로세스마다 독립적으로 할당 되며 0부터 시작되는 독자적인 주소공간을 가짐</li>
</ul>
</li>
<li>물리적 주소 (physical address)
<ul>
<li>물리적 메모리에 실제 올라가는 위치</li>
<li>낮은 영역에는 운영체제가, 높은 영역에는 사용자 프로세스가 올라감</li>
</ul>
</li>
<li>프로그램이 실행되기 위해서는 프로그램이 물리적 메모리에 올라가 있어야 하며 CPU 가 기계어 명령을 수행하기 위해 논리적 메모리를 참조하면 해당 논리적 주소가 물리적 주소에 어느 위치에 매핑되어 있는지를 알아야 한다</li>
<li>주소 바인딩
<ul>
<li>프로세스의 논리적 주소와 물리적 주소를 연결시켜 주는 작업</li>
</ul>
</li>
<li>컴파일 타임 바인딩 (compile time binding)
<ul>
<li>프로그램을 컴파일할 때 결정되는 방식</li>
<li>컴파일 시점에 프로그램의 물리적 메모리의 주소가 결정됨</li>
<li>프로그램이 정대 주소로 적재된다는 뜻에서 절대코드(absolute code)를 생성하는 바인딩 방식 이라고도 함</li>
<li>메모리 주소를 바꾸기 위해서는 다시 컴파일을 해 주어야 함</li>
<li>현대의 방식에서는 잘 사용하지 않는 방식</li>
</ul>
</li>
<li>로드 타임 바인딩 (load time binding)
<ul>
<li>프로그램이 실행될 때 결정되는 방식</li>
<li>로더 (loader)
<ul>
<li>사용자 프로그램을 메모리에 적재시키는 프로그램</li>
<li>로더의 책임 하에 물리적 메모리 주소가 프로그램에 부여되며 프로그램이 종료될 때 까지 고정됨</li>
</ul>
</li>
<li>컴파일러가 재배치 가능 코드(relocatable code)를 생성한 경우 가능한 방식</li>
</ul>
</li>
<li>실행시간 바인딩 (execution time binding, run time binding)
<ul>
<li>프로그램이 실행을 시작한 후에도 프로그램이 위치한 물리적 메모리가 변경될 수 있는 방식</li>
<li>CPU 가 주소를 참조할 때 마다 해당 데이터가 어디에 존재하는지 주소 매핑 테이블(address mapping table)을 이용해 바인딩을 점검</li>
<li>기준 레지스터, 한계 레지스터, MMU(memory management unit)과 같은 하드웨어적인 지원이 필요
<ul>
<li>MMU
<ul>
<li>논리적 주소를 물리적 주소로 매핑 해주는 하드웨어 장치</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>MMU 기법 (MMU scheme)
<ul>
<li>기준 레지스터, 재배치 레지스터 (relocation register)
<ul>
<li>프로세스의 물리적 메모리의 시작 주소를 가지고 있는 레지스터</li>
</ul>
</li>
<li>한계 레지스터 (limit register)
<ul>
<li>프로세스가 본인의 메모리 공간을 넘어서는 주소를 참조하려는지를 체크할 때 사용</li>
<li>프로세스의 논리적 주소의 최댓값을 가짐</li>
<li>프로세스의 메모리 크기를 가지고 있는 레지스터</li>
</ul>
</li>
<li>특정 프로세스의 논리적 주소를 참조하려고 할 때 논리적 주소와 기준 레지스터의 주소값을 더해 물리적 주소를 알아낸다</li>
<li>프로그램의 주소 공간이 물리적 메모리에 연속적으로 적재되는 것으로 가정</li>
<li>실제 환경에서는 메모리에 여러 프로세스의 데이터가 동시에 올라가 있을 수 있음
<ul>
<li>논리적 주소와 기준 레지스터의 값을 더한 경우가 다른 프로세스의 영역을 침범할 수 있음
<ul>
<li>메모리 보안 (memory protection) 이 이루어 지지 않는 경우</li>
</ul>
</li>
</ul>
</li>
<li>cpu 가 메모리 참조 요청을 했을 때 해당 주소가 한계 레지스터의 값보다 큰지 확인하여 물리적 메모리에 대해 보안을 하게 됨</li>
<li>MMU 기법으로 메모리를 참조하는 순서
<ul>
<li>CPU 가 프로세스의 특정 논리적 주소값에 대해 참조 요청을 보냄</li>
<li>한계 레지스터를 확인하여 주소값이 참조 가능한 위치인지를 확인</li>
<li>논리적 주소값이 한계 레지스터의 값보다 큰 경우 프로그램을 종료</li>
<li>참조가 가능한 경우 기준 레지스터의 값과 논리적 주소값을 더해 접근을 허락</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>2. 메모리 관리와 관련된 용어</h2>
<ul>
<li>동적 로딩 (dynamic loading)
<ul>
<li>다중 프로그래밍 환경에서 메모리 사용의 효율을 높이기 위한 방법</li>
<li>프로세스가 시작될 때 프로세스의 주소공간 전체를 메모리에 올리는 것이 아닌 필요한 부분을 그때그때 메모리에 적재하는 방식</li>
</ul>
</li>
<li>동적 연결 (dynamic linking)
<ul>
<li>연결 (linking)
<ul>
<li>소스코드를 컴파일해서 생기는 목적파일 (object file) 과 다른 라이브러리파일들을 묶어 하나의 실행 파일로 만드는 작업</li>
</ul>
</li>
<li>목적파일과 라이브러리 파일의 연결을 프로그램의 실행시 까지 미루는 방식</li>
<li>파일을 실행할 때, 즉 프로세스가 실행될 때 라이브러리 함수를 호출하면 그때그때 라이브러리가 연결된다</li>
<li>스텁 (stub)
<ul>
<li>실행 파일이 라이브러리를 호출할 때 해당 라이브러리의 위치를 찾도록 도와주는 코드</li>
</ul>
</li>
<li>실행 시 스텁이 해당 라이브러리가 메모리에 적재되어있는지 확인 후</li>
<li>메모리에 라이브러리가 적재되어 있으면 직접 해당위치를 참조하여 사용</li>
<li>적재되어있지 않으며 저장장치에서 라이브러리를 찾은 후 적재하여 사용한다</li>
<li>다수의 프로세스가 공통된 라이브러리를 사용하는 경우 라이브러리를 한번만 적재하여 사용하므로 메모리 관리에 효율적이다</li>
<li>정적 연결 (static linking)
<ul>
<li>동적 연결과 대비되는 방법</li>
<li>목적파일과 라이브러리 파일이 컴파일 시에 연결이 되어 실행파일이 생긴다</li>
<li>동일한 라이브러리를 각각의 실행파일마다 가지고 있게되어 메모리의 낭비가 생길 수 있다</li>
</ul>
</li>
</ul>
</li>
<li>중첩 (overlays)
<ul>
<li>프로세스의 주소공간을 분할해 실제 필요한 부분만 메모리에 적재하는 기법
<ul>
<li>동적 로딩과 유사</li>
</ul>
</li>
<li>동적 로딩과 다르게 여러 프로그램을 올리지 않는 과거에 하나의 프로세스조차 전부 메모리에 올리기 힘든 시절 만들어짐</li>
<li>동적 로딩은 다중 프로그래밍 환경에서 메모리의 이용률을 향상시키기 위해 프로세스에서 당장 필요한 부분을 그때그때 적재하여 사용한것
<ul>
<li>더 많은 프로세스를 메모리에 올리기 위해 사용</li>
</ul>
</li>
<li>중첩은 메모리의 용량보다 큰 프로세스를 사용하기 위해 고안한 기법</li>
<li>과거에는 프로그래머가 직접 구현하였으며 이를 수작업 중첩 (manual overlays) 라고 불렀음</li>
</ul>
</li>
<li>스와핑 (swapping)
<ul>
<li>메모리에 올라온 프로세스의 주소공간을 디스크의 스왑 영역 (swap area) 에 일시적으로 내려놓는 것</li>
<li>스왑 영역 (swap area)
<ul>
<li>백킹 스토어 (backing store) 라고도 부름</li>
</ul>
</li>
<li>프로세스가 종료되어 메모리에서 내리는 것이 아닌 특정한 이유로 수행중인 프로세스를 잠시 저장하는 것</li>
<li>스왑 인 (swap in)
<ul>
<li>디스크에서 메모리로 올리는 작업</li>
</ul>
</li>
<li>스왑 아웃 (swap out)
<ul>
<li>메모리에서 디스크로 내리는 작업</li>
</ul>
</li>
<li>스와핑이 되는 과정
<ul>
<li>스와퍼 (swapper) 라는 이름의 중기 스케줄러에 의해 스왑 아웃 시킬 프로세스를 선정</li>
<li>현재 메모리에 올라와 있는 주소공간을 통채로 스왑 영역에 스왑 아웃</li>
</ul>
</li>
<li>메모리에 적재되어있는 프로세스의 수를 관리, 조절하는 역할</li>
</ul>
</li>
</ul>
<h2>3. 물리적 메모리의 할당 방식</h2>
<ul>
<li>연속 할당 (contiguous allocation)
<ul>
<li>각각의 프로세스를 메모리의 연속적인 공간에 올리는 방식</li>
<li>물리적 메모리를 분할하여 하나의 분할에 하나의 프로세스를 적재</li>
<li>고정 분할 (fixed partition allocation)
<ul>
<li>물리적 메모리를 고정된 크기의 분할로 미리 나누어 두는 방식</li>
<li>내부조각, 외부조각이 발생할 수 있음
<ul>
<li>프로그램의 크기와 분할의 크기에 따라 남는 메모리가 생길 수 있음</li>
</ul>
</li>
</ul>
</li>
<li>가변 분할 (variable partition allocation)
<ul>
<li>프로그램이 실행되고 종료되는 순서에 따라 분할을 관리하는 방식</li>
<li>외부 조각이 발생할 수 있음
<ul>
<li>새롭게 시작하는 프로그램의 크기보다 남은 메모리의 크기가 작으면 해당 부분의 메모리가 낭비됨</li>
</ul>
</li>
<li>동적 메모리 할당 문제 (dynamic memory storage-allocation problem)
<ul>
<li>프로세스를 할당시킬 때 메모리의 어느 위치에 할당할지를 결정하는 문제</li>
<li>최초 적합 방법 (first-fit)
<ul>
<li>메모리에 남아있는 가용공간을 차례대로 살피면서 프로그램에 적재될 수 있는 최초 가용공간에 프로세스를 적재하는 방식</li>
<li>시간적인 측면에서 효율적</li>
</ul>
</li>
<li>최적 적합 방법 (best-fit)
<ul>
<li>가용 공간들의 리스트에서 프로세스보다 큰 가용공간 중 제일 작인 공간을 사용하는 방식</li>
<li>모든 가용 공간을 탐색해야 하므로 시간적 오버헤드가 발생하고 아주 작은 가용공간이 생길 수 있음</li>
<li>공간적인 측면에서 효율적</li>
</ul>
</li>
<li>최악 적합 방법 (worst-fit)
<ul>
<li>최적 적합과 반대로 가용 메모리 공간 중 가장 큰 공간에 적재하는 방식</li>
<li>큰 프로세스를 담을 수 있는 가용 공간을 빨리 소진하게 됨</li>
</ul>
</li>
</ul>
</li>
<li>컴팩션 (compaction)
<ul>
<li>외부조각 문제를 해결하기 위한 방법</li>
<li>물리적 메모리 중 프로세스에 의해 사용중인 공간을 한쪽으로 몰아서 큰 가용공간을 만드는 방식</li>
<li>현재 사용중인 프로세스의 메모리 위치를 이동시켜야 하기 때문에 많은 비용이 든다</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>불연속 할당 (noncontiguous allocation)
<ul>
<li>하나의 프로세스를 물리적 메모리의 여러 영역에 분산 적재 하는 방식</li>
<li>페이징 기법 (paging)
<ul>
<li>프로세스의 주소공간을 일정한 크기의 페이지(page) 로 나누어 적재시키는 방식</li>
</ul>
</li>
<li>세그먼테이션 기법 (segmentation)
<ul>
<li>프로그램의 주소 공간을 코드, 데이터, 스택 등 의미있는 단위인 세그먼트로 나누어 세그먼트 단위로 적재하는 방식</li>
</ul>
</li>
<li>페이지드 세그먼테이션 기법 (paged segmentation)
<ul>
<li>각각의 세그먼트를 다시 페이지로 나누어 적재하는 방식</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>4. 페이징 기법</h2>
<ul>
<li>프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누어 물리적 메모리의 서로 다른 위치에 페이지를 적재하는 방식</li>
<li>프로세스의 모든 메모리를 한번에 올릴 필요가 없으며 일부는 스왑공간에 일부를 메모리에 적재하게 됨</li>
<li>물리적 메모리를 페이지와 동일한 크기의 프레임 (frame) 으로 미리 나누어 분할해 둠</li>
<li>페이지와 같은 크기로 분할하기 때문에 빈 프레임이 있으면 언제나 페이지를 적재할 수 있음</li>
<li>페이징 기법에서의 주소 변환 방식
<ul>
<li>페이지 테이블 (page table)
<ul>
<li>특정 프로세스의 몇번째 페이지가 물리적 메모리의 어느 프레임에 적재되어있는지 저장된 테이블</li>
</ul>
</li>
</ul>
</li>
<li>주소 변환 기법
<ul>
<li>cpu 가 사용하는 논리적 주소를 페이지 번호(p)와 페이지 오프셋(d) 으로 나누어 주소변환을 하게 됨</li>
<li>페이지 번호는 페이지 테이블에서의 인덱스로 사용됨</li>
<li>페이지 테이블에는 해당 페이지번호의 물리적 메모리의 기준 주소, 즉 시작위치가 저장되어 있음</li>
<li>페이지 번호로 물리적 메모리의 시작 주소를 구한 뒤 오프셋 만큼 이동해 해당 메모리의 위치를 알 수 있음</li>
</ul>
</li>
<li>페이지 테이블의 구현
<ul>
<li>페이징 기법에서 주소 변환을 위해 사용하는 자료 구조</li>
<li>페이지 테이블 기준 레지스터 (page-table base register)
<ul>
<li>메모리 내에서 페이지 테이블의 시작 위치</li>
</ul>
</li>
<li>페이지 테이블 길이 레지스터 (page-table length register)
<ul>
<li>페이지 테이블의 크기</li>
</ul>
</li>
<li>cpu 가 메모리에 접근하기 위해서는 페이지 테이블과 실제 메모리에 접근하는 두번의 메모리 접근이 필요하기 때문에 오버헤드가 발생</li>
<li>오버헤드를 막기 위해 페이지 테이블을 TLB(Translation Look-aside Buffer) 라고 하는 접근이 빠른 주소 변환용 하드웨어 캐시를 사용하기도 함</li>
<li>TLB 또한 가격이 비싸기 때문에 많은 정보를 담을 수 없으며 자주 사용되는 주소에 대해서만 저장을 함</li>
<li>우선 TLB 에서 테이블을 확인한 후 정보가 없으면 메인 메모리에 있는 테이블에서 정보를 얻게 됨</li>
<li>TLB 에는 페이지 테이블과 다르게 페이지 번호와 프레임 번호가 쌍으로 저장됨
<ul>
<li>모든 페이지에 대한 프레임 정보를 가진 것이 아닌 특정 페이지에 대한 프레임 정보가 저장되기 때문</li>
</ul>
</li>
</ul>
</li>
<li>계층적 페이징
<ul>
<li>메모리의 크기와 프로그램의 크기가 커지면서 관리해야 할 페이지, 프레임의 수가 늘어남</li>
<li>모든 페이지를 관리하기 위한 테이블을 만들면 테이블의 크기가 늘어나 사용할 수 있는 메모리의 양이 줄어들게 됨</li>
<li>2단계 페이징 기법
<ul>
<li>외부 페이지 테이블 (outer page table)</li>
<li>내부 페이지 테이블 (inner page table)</li>
<li>사용 되지 않는 주소공간에 대해서는 외부 페이지 테이블의 항목을 NULL 로 설정하며, 이에 대응되는 내부 페이지 테이블을 아예 작성하지 않음</li>
<li>주소 공간에 접근을 위해 접근해야 하는 테이블이 늘어나 시간적으로는 손해를 볼 수 있음</li>
<li>2개의 페이지 번호(p1, p2)와 오프셋(d)를 사용</li>
<li>외부 페이지 테이블에서 p1 만큼 떨어진 위치에서 내부 페이지 테이블을 불러오고</li>
<li>내부 페이지 테이블에서 p2 만큼 떨어진 위치에서 물리적 메모리의 시작주소를 불러옴</li>
<li>마지막으로 물리적 메모리의 시작주소에서 d 만큼 떨어진 위치를 참조함</li>
</ul>
</li>
<li>프로세스의 주소 공간이 커질수록 테이블에 의한 메모리 공간의 낭비도 커져 2단계가 아닌 그 이상의 다단계 테이블을 사용하게 됨</li>
<li>다단계 테이블을 사용하면 시간적인 오버헤드가 늘며 이를 해결하기 위해 TLB를 사용함</li>
</ul>
</li>
<li>역페이지 테이블
<ul>
<li>페이징 기법에서 메모리 낭비가 발생하는 이유는 프로세스의 모든 페이지에 대해 테이블을 만들어야 하기 때문</li>
<li>페이지 테이블에는 각각의 프로세스의 논리적 주소의 어느 부분이 물리적 메모리에 어디에 저장되어 있는지를 저장</li>
<li>이와 반대로 물리적 주소에 대해 페이지 테이블을 만드는 것이 역페이지 테이블</li>
<li>각각 프로세스별로 페이지를 만드를 것이 아닌 시스템에서 하나의 페이지 테이블을 만들어 공간을 절약</li>
<li>페이지 테이블에는 프로세스번호(pid) 와 해당 프로세스의 논리적 페이지 번호(p)를 저장함</li>
</ul>
</li>
<li>공유 페이지 (shared paging)
<ul>
<li>공유코드 (shared code)
<ul>
<li>재진입 가능 코드(re-entrant code), 순수 코드 (pure code)</li>
<li>여러 프로세스에 의해 공통으로 사용될 수 있도록 작성된 코드</li>
<li>읽기 전용</li>
<li>모든 프로세스의 같은 논리적 주소 공간에 위치해야 함</li>
</ul>
</li>
<li>공유 코드를 담고 있는 페이지를 말함</li>
<li>여러 프로세스에 의해 공유되기 때문에 물리적 메모리에 하나만 적재되어 공간 효율이 늘어남</li>
<li>사유 페이지 (private page)
<ul>
<li>공유 페이지와 반대되는 말</li>
<li>프로세스들이 공유하지 않고 독자적으로 사용하는 페이지</li>
</ul>
</li>
</ul>
</li>
<li>메모리 보호
<ul>
<li>보호 비트 (protection bit)
<ul>
<li>각 페이지에 대한 접근 권한의 내용</li>
<li>다름 프로세스에 의해 접근될 수는 없으므로 ‘누가’ 접근하는지에 대한 정보는 필요 없음</li>
<li>각 페이지에 대해 ‘어떠한’ 접근을 허용하는지에 대한 정보가 저장</li>
<li>각 페이지에 대해 읽기-쓰기/읽기전용 등의 접근 권한을 저장함</li>
</ul>
</li>
<li>유효-무효 비트 (valid-invalid bit)
<ul>
<li>페이지의 내용이 유효한지에 대한 내용이 저장</li>
<li>‘유효’ 인 경우 해당 프레임에 페이지가 존재한다는 뜻으로 접근이 허용됨</li>
<li>‘무효’ 인 경우 프로세스가 해당 주소부분을 사용하지 않거나 물리적 메모리에 있는게 아닌 스왑 영역에 있어 해당 메모리에 대해 접근권한이 없음</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>5. 세그먼테이션</h2>
<ul>
<li>프로세스를 code, data, stack 으로 나누는 것과 같이 기능, 의미단위로 나누는 것</li>
<li>적게는 프로세스 전체를 하나의 세그먼트로, 많게는 각각의 함수 하나하나를 세그먼트로 나눌 수 있음</li>
<li>메모리를 특정 크기가 아닌 논리적인 단위로 나누는 것이기 때문에 각각의 세그먼트의 크기가 다름</li>
<li>프로세스를 단위별로 나누어 적재한다는 것에서 페이징 기법과 유사</li>
<li>각각의 나눠진 세그먼트의 크기가 달라 이를 관리하기 위한 부가적인 오버헤드가 필요</li>
<li>논리적 주소를 세그먼트 번호, 오프셋 으로 나누어 관리</li>
<li>세그먼트 테이블
<ul>
<li>기준점 (base)
<ul>
<li>물리적 메모리에서 해당 세그먼트의 시작위치를 저장</li>
</ul>
</li>
<li>한계점 (limit)
<ul>
<li>세그먼트의 크기를 저장</li>
</ul>
</li>
</ul>
</li>
<li>세그먼트 테이블 기준 레지스터 (segment-table base register)
<ul>
<li>메모리 내에서 세그먼트 테이블의 시작 위치</li>
</ul>
</li>
<li>세그먼트 테이블 길이 레지스터 (segment-table length register)
<ul>
<li>프로세스의 주소 공간이 총 몇개의 세그먼트로 구성되는지, 즉 세그먼트의 갯수</li>
</ul>
</li>
<li>세그먼테이션 기법에서 논리적 주소를 물리적 주소로 변환시
<ul>
<li>요청된 세그먼트 번호가 세그먼트 테이블 길이 레지스터에 저장된 값보다 작은지 확인</li>
<li>큰 경우 존재하지 않는 세그먼트에 대한 접근 요청임</li>
<li>논리적 주소의 오프셋 값이 세그먼트의 길이보다 작은지 확인</li>
</ul>
</li>
<li>페이징 기법과 동일하게 세그먼트 테이블에 보호비트와 유효비트를 사용</li>
<li>공유 세그먼트를 사용하며 공유 세그먼트는 해당 세그먼트를 공유하는 프로세스의 주소 공간에 동일한 주소 공간에 있어야 함</li>
<li>의미 단위로 나누기 때문에 공유, 보안적인 측면에서 페이징 기법보다 유리</li>
<li>세그먼트의 크기가 균일하지 않기 때문에 물리적 메모리에서 외부 조각이 생길 수 있음</li>
</ul>
<h2>6. 페이지드 세그먼테이션</h2>
<ul>
<li>페이징 기법과 세그먼테이션 기법의 장점을 합친 기법</li>
<li>프로그램을 의미단위인 세그먼트로 나누며 각 세그먼트는 동일한 크기 페이지들의 집합으로 구성되어있음</li>
<li>실제 물리적 메모리에 적재될 때는 페이지 단위로 적재</li>
<li>논리적 주소를 물리적 주소로 변환하기 위해 외부의 세그먼트 테이블과 각각 세그먼트 내부의 페이지 테이블을 사용</li>
</ul>

        </article>
        
    </main>

        <footer>
        <p>Generated by SuGo</p>
    </footer>

</body>
</html>


