<!DOCTYPE html>



<html>

<head>
    <meta charset="UTF-8">
    <title>Code Complete</title>
    <link rel="icon" href="https://biisairo.github.io/static/favicon.ico" type="image/x-icon">
</head>

<script>
    function toggleSection(id) {
        const section = document.getElementById(id);
        const header = section.previousElementSibling;

        if (section.style.display === 'none') {
            section.style.display = 'block';
            header.innerHTML = header.innerHTML.replace('▶', '▼');
        } else {
            section.style.display = 'none';
            header.innerHTML = header.innerHTML.replace('▼', '▶');
        }
    }
</script>

<body>
    <header>
    <nav>
        <ul>
            

            <li><a href="https://biisairo.github.io/">Home</a></li>
            
            <li><a href="https://biisairo.github.io/About/">About</a></li>
            
            <li><a href="https://biisairo.github.io/Study/">Study</a></li>
            
            <li><a href="https://biisairo.github.io/Contact/">Contact</a></li>
            
        </ul>
    </nav>

    <style>
     
    html,
    body {
        height: 100%;
        margin: 0;
    }

    body {
        display: flex;
        flex-direction: column;
        max-width: 720px;
        margin: 0 auto;
        padding: 2rem 1rem;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
            Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        line-height: 1.6;
        background: #222831;
        color: #EEEEEE;
    }

    header,
    footer {
        text-align: center;
        margin-bottom: 2rem;
    }

    nav ul {
        list-style: none;
        padding: 0;
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
         
        flex-wrap: wrap;
        gap: 1rem;
    }

    nav li:first-child {
        margin-right: auto;
         
    }

    nav li:not(:first-child) {
        margin-left: 0;
    }

    nav li:first-child a {
        color: #EEEEEE;
        font-size: 1.5em;
        text-decoration: none;
         
    }

    nav li:first-child a:hover {
        color: #aadadf;
         
    }

    nav a {
        color: #00ADB5;
        text-decoration: underline;
        transition: color 0.3s ease;
    }

    nav a:hover {
        color: #66C1C9;
        text-decoration: none;
    }

    main a,
    article a,
    footer a {
        color: #33d3c8;
        text-decoration: underline;
        transition: color 0.3s ease;
    }

    main a:hover,
    article a:hover,
    footer a:hover {
        color: #66C1C9;
        text-decoration: none;
    }

     
    main {
        flex: 1;
        margin-bottom: 2rem;
    }

    h1,
    h2,
    h3 {
        line-height: 1.3;
        margin-top: 2rem;
        margin-bottom: 1rem;
        color: #00ADB5;
    }

    h2[onclick] {
        user-select: none;
    }


    ul {
        padding-left: 1.5rem;
    }

    article {
        margin-top: 2rem;
        border: 1px solid #33d3c8;
        padding: 1rem;
        border-radius: 5px;
    }

    footer p {
        font-size: 0.9rem;
        color: #AAAAAA;
    }
</style>

</header>

    <main>
        
        
        

        
        <h2 onclick="toggleSection('pages')" style="cursor: pointer;">▶ 하위 페이지</h2>
        <div id="pages" style="display: none;">
            <ul>
                
                <li><a href="https://biisairo.github.io/Study/%ec%b1%85/Code%20Complete.html">Code Complete</a></li>
                
            </ul>
        </div>
        

        
        
        <article>
            <h1>Code Complete</h1>
<p>세미나 진도</p>
<p>31장 9시</p>
<ul>
<li>
<p>강조 색</p>
<p>이상함</p>
<p>공감</p>
<p>이해안감</p>
</li>
</ul>
<h1>5장 구현 설계</h1>
<p>설계</p>
<ul>
<li>컴퓨터 소프트웨어에 대한 명세를 동작 가능한 소프트웨어로 변환하기 위한 스키마에 대한 개념, 고안, 계획을 의미</li>
<li>코드를 작성하고 디버깅하기 위한 요구 사항들을 결합하는 작업</li>
</ul>
<h2>1. 설계의 문제점</h2>
<p>문제</p>
<ul>
<li>해결해야만 정의할 수 있는 문제</li>
<li>문제를 정확하게 정의하기 위해서는 문제를 한번 해결 해야함</li>
<li>작동하는 솔루션을 만들기 위해서는 문제를 두번 해결해야 한다는 의미</li>
</ul>
<p>실수를 많이하고 실수를 고치는 것이 설계의 핵심</p>
<p>서로 상충되는 특징, 자원을 고려해 균형을 맞추는 일</p>
<p>디자인 재검토, 토론, 코드를 작성하고 수정하는 경험을 통해 진화하고 발전한다</p>
<h2>2. 설계의 핵심 개념</h2>
<p>복잡성 관리</p>
<ul>
<li>본질과 비본질
<ul>
<li>본질 : 사물이 그러한 사물이 되기 위한 필수 속성</li>
<li>비본질 : 사물이 가질수도 있는 속성</li>
<li>소프트웨어의 비본질(언어, 언어의 문법, 언어 사용의 어려움) 은 해결됨</li>
<li>소프트웨어의 본질
<ul>
<li>현실의 제약, 연관된 개념들의 복잡성</li>
</ul>
</li>
<li>복잡성 관리의 중요성</li>
<li>컴퓨터 프로그램 전부를 머리에 담을 수 없으며 한번에 한 부분을 집중할 수 있도록 프로그램을 구성 하여야 함</li>
<li>시스템 전체를 서브시스템으로 나누어 복잡성을 감소시킴</li>
</ul>
</li>
<li>복잡성을 해결하기 위한 방법
<ul>
<li>한 번에 처리해야 하는 본질적인 복잡성의 양을 최소화</li>
<li>비본질적인 복잡성이 불필요하게 증가하지 않도록</li>
</ul>
</li>
<li>바람직한 설계 - 품질 특성
<ul>
<li>복잡성 최소화
<ul>
<li>간단하고 이해하기 쉬운 설계</li>
</ul>
</li>
<li>유지 관리의 편리함</li>
<li>느슨한 결합
<ul>
<li>다른 부분들 과의 연결을 최소화</li>
</ul>
</li>
<li>확장성</li>
<li>재사용성</li>
<li>높은 팬인(fan-in)
<ul>
<li>주어진 클래스를 사용하는 클래스의 수가 많은 것을 의미</li>
</ul>
</li>
<li>낮은 팬아웃(fan-out)
<ul>
<li>주어진 클래스가 다른 클래스를 적게 사용하는 것을 의미</li>
</ul>
</li>
<li>이식성</li>
<li>간결성
<ul>
<li>더이상 추가적인 부분이 없도록 설계하는 것</li>
</ul>
</li>
<li>계층화</li>
<li>표준기술 사용</li>
</ul>
</li>
<li>설계 수준
<ul>
<li>소프트웨어 시스템
<ul>
<li>서브시스템/패키지로 분할
<ul>
<li>패키지 내에서 클래스로 분할
<ul>
<li>클래스 내에서 데이터와 루틴으로 분할
<ul>
<li>내부 루틴 설계</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>1 수준 : 소프트웨어 시스템
<ul>
<li>전체 시스템</li>
</ul>
</li>
<li>2 수준 : 서브시스템/패키지로 분할
<ul>
<li>프로그램을 주요 서브시스템으로 어떻게 분할할지, 각각의 서브시스템들이 서로를 어떻게 이용할 지를 결정</li>
<li>각각의 서브시스템이 서로 어떻게 커뮤니케이션 하는지에 대한 규칙을 결정</li>
<li>가장 간단한 관계는 서브시스템이 서로의 루틴을 호출하는 것</li>
<li>가장 복잡한 관계는 서브시스템의 클래스가 다른 서브시스템의 클래스를 상속받는 것</li>
<li>순환관계를 끊는 것이 범용적인 규칙</li>
<li>공통적인 서브시스템
<ul>
<li>비즈니스 규칙</li>
<li>사용자 인터페이스</li>
<li>데이터베이스 접근</li>
<li>시스템 의존성</li>
</ul>
</li>
</ul>
</li>
<li>3 수준 : 클래스로 분할
<ul>
<li>모든 서브시스템이 개별적인 클래스로 최소 단위로 분해되었음을 보장해야 함</li>
<li>각 클래스가 시스템의 나머지 부분과 상호작용하는 세부 방법도 정의
<ul>
<li>인터페이스의 정의</li>
</ul>
</li>
<li>객체와 클래스의 차이점
<ul>
<li>클래스 - 프로그램 코드에서 보게 되는 정적인 것</li>
<li>객체 : 프로그램을 실행할 때 생성되는 특정 값을 갖는 무언가
<ul>
<li>db 에서의 스키마/인스턴스와 같은 차이</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>4 수준 : 루틴으로 분할
<ul>
<li>각 클래스를 루틴로 분할</li>
<li>클래스의 private 루틴을 상세하게 설계</li>
<li>인터페이스의 이해와 이에 따른 인터페이스의 변경</li>
</ul>
</li>
<li>5 수준 : 내부 루틴 설계
<ul>
<li>개별 루틴의 상세 기능 구현</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>3. 빌딩 블록의 설계 : 발견적 학습</h2>
<p>객체를 설계하는 단계</p>
<ul>
<li>객체와 특성(메서드와 데이터)을 규명
<ul>
<li>객체는 실세계의 엔티티에 기반을 두게 됨</li>
<li>직원, 고객 등등…</li>
</ul>
</li>
<li>각 객체가 할 수 있는 일을 결정</li>
<li>각 객체가 다른 객체에게 허용하는 것을 결정
<ul>
<li>포함, 상속관계</li>
</ul>
</li>
<li>각 객체가 다른 객체에게 보일 것을 결정, 즉 public, private 인 부분은 결정</li>
<li>각 객체의 public 인터페이스를 정의</li>
</ul>
<p>추상화</p>
<ul>
<li>잘 만들어진 클래스의 인터페이스 - 해당 클래스의 내부적인 작업에는 신경 쓸 필요가 없게 만들어진 인터페이스</li>
<li>추상화가 잘 되어있는 경우 관련없는 세부사항을 무시할 수 있게 되며 복잡성을 줄일 수 있다
<ul>
<li>집 - 창문, 문, 벽 등을 구성하는 방법에 대한 추상화</li>
<li>문 - 나무, 손잡이, 경첩 등을 구성하는 방법에 대한 추상화</li>
</ul>
</li>
<li>객체를 높은 수준에서 볼 수 있도록 하는 것</li>
</ul>
<p>캡슐화</p>
<ul>
<li>다른 수준에서 객체를 볼 수 없도록 하는 것</li>
<li>복잡한 부분을 볼 수 없도록 함으로써 복잡성을 관리
<ul>
<li>집을 볼 수 있지고 문이 열려있는지 닫혀있는지에 대한 상태는 볼 수 있지만 문의 재질은 알 수 없도록 함</li>
</ul>
</li>
</ul>
<p>상속</p>
<ul>
<li>객체들 간의 유사성과 차이점을 정의하는 것</li>
<li>상위 개념에서의 일반적인 특성을 정의하고 이를 상속받는 하위 개념을 추가로 정의
<ul>
<li>나무 → 문 → 여닫이문</li>
</ul>
</li>
</ul>
<p>정보 은닉</p>
<ul>
<li>캡슐화, 모듈화, 추상화의 시작</li>
<li>정보, 복잡성을 감추는데 중점을 둠</li>
<li>비밀
<ul>
<li>변수, 파일의 포맷, 구현, 외부에 차단 될 필요가 있는 영역</li>
</ul>
</li>
<li>비밀 보장권
<ul>
<li>클래스는 비밀들을 숨기고 비밀 보장권을 보호해야 함</li>
<li>가시성 : 클래스를 설계할 때 어떤 기능들이 노출되어야 하고 어떤 기능들이 비밀로 남겨져야 하는지를 정의하여야 함</li>
</ul>
</li>
<li>예시
<ul>
<li>메서드, 변수 등 정보에 직접 접근을 방지</li>
<li>변수의 타입을 typedef 를 활용하여 특정하는 것을 방지
<ul>
<li>typedef int IdType</li>
</ul>
</li>
</ul>
</li>
<li>비밀의 종류
<ul>
<li>복잡성을 감추기 위해 특별히 다룰 필요가 없는 데이터를 숨기는 것</li>
<li>변경이 발생했을 때 변경의 원인을 감추는 것</li>
</ul>
</li>
<li>정보 은닉의 장애물
<ul>
<li>정보의 지나친 배분
<ul>
<li>상수에 정보를 숨겨서 한 곳에서만 값을 관리하여 해결</li>
<li>전역 데이터에 대한 접근을 관리하여 해결</li>
</ul>
</li>
<li>순환 참조</li>
<li>클래스 데이터를 전역 데이터로 사용하는 것</li>
<li>성능 손해</li>
</ul>
</li>
<li>정보 은닉의 가치
<ul>
<li>이 클래스에서 무엇을 숨겨야 하는가?</li>
<li>내가 무엇을 숨겨야 하지?</li>
</ul>
</li>
</ul>
<p>변경될 수 있는 영역 규명</p>
<ul>
<li>변경에 대비하는 단계
<ul>
<li>변경될 것처럼 보이는 항목을 규명
<ul>
<li>요구 사항 개발이 잘 수행 되었다면 잠재적인 변경의 가능성을 포함하고있을 것</li>
</ul>
</li>
<li>변경될 것 같은 항목을 분류
<ul>
<li>위에서 규명한 변하기 쉬운 요소들을 고유한 클래스로 분류</li>
</ul>
</li>
<li>변경될 것처럼 보이는 항목을 고립
<ul>
<li>변화될 부분과 고정된 부분들 분리시키고 해당 변경이 클래스 내부에 제한되어 외부에 영향을 주지 않도록 설계</li>
<li>해당 클래스를 사용하는 외부의 클래스는 변경을 알아서는 안됨</li>
</ul>
</li>
</ul>
</li>
<li>변경될 수 있는 영역
<ul>
<li>비즈니스 규칙</li>
<li>하드웨어 의존성
<ul>
<li>다른 하드웨어 환경을 대비</li>
</ul>
</li>
<li>입출력
<ul>
<li>파일 포맷 등의 변경을 대비</li>
</ul>
</li>
<li>비표준 언어 기능
<ul>
<li>해당 확장기능을 사용하지 않는 환경을 대비</li>
</ul>
</li>
<li>어려운 설계, 구현 부분
<ul>
<li>오류, 수정을 대비</li>
</ul>
</li>
<li>상태 변수
<ul>
<li>bool 변수 사용 금지 - 열거형을 사용
<ul>
<li>상태가 추가되는 것을 대비</li>
</ul>
</li>
</ul>
</li>
<li>데이터 크기 제약</li>
</ul>
</li>
<li>변경의 정도 예상하기
<ul>
<li>변경이 예상되지 않는 부분만 클래스에서 큰 영향을 가지도록</li>
</ul>
</li>
</ul>
<p>느슨한 결합</p>
<ul>
<li>결합
<ul>
<li>클래스, 루틴이 다른 클래스와 루틴과 얼마나 밀접하게 연관되어 있는지</li>
</ul>
</li>
<li>모듈
<ul>
<li>클래스, 루틴을 가리키는 말</li>
</ul>
</li>
<li>모듈간의 결합
<ul>
<li>하나의 모듈이 다른 모듈을 사용하는 것</li>
<li>모듈간의 결합이 서로 쉽게 사용할 수 있도록 느슨하게 결합되어야 함</li>
</ul>
</li>
<li>모듈이 다른 모듈에 최대한 의존하지 않도록 해야함</li>
<li>결합의 기준
<ul>
<li>크기
<ul>
<li>모듈간의 연결 수</li>
</ul>
</li>
<li>가시성
<ul>
<li>모듈 간 연결의 현저함</li>
<li>얼마나 연결이 눈에 띄는지</li>
</ul>
</li>
<li>유연성
<ul>
<li>모듈간의 연결을 얼마나 쉽게 변경할 수 있는가</li>
<li>다른 모듈이 어떤 모듈을 쉽게 호출할 수 있도록</li>
</ul>
</li>
</ul>
</li>
<li>결합의 종류
<ul>
<li>간단한-데이터-매개변수 결함</li>
<li>간단한-객체 결합</li>
<li>객체-매개변수 결합
<ul>
<li>객체와 객체간에서 다른 객체를 전달하는 경우</li>
<li>받는 객체가 주어진 객체에 대해 알고 있어야 함</li>
</ul>
</li>
<li>의미론적인 결합
<ul>
<li>한 모듈이 다른 모듈의 내부 작동에 대한 지식을 사용하고 있는 경우</li>
</ul>
</li>
</ul>
</li>
<li>느슨한 결합은 모듈이 추가적인 추상화 수준을 제공할 수 있도록 함</li>
</ul>
<p>설계 패턴의 사용</p>
<ul>
<li>설계 패턴 - 흔히 발생하는 문제들을 해결하기 위해 이미 만들어진 해결책의 핵심 부분</li>
<li>이미 만들어진 추상화를 제공함으로 복잡성을 줄임
<ul>
<li>코드에 대한 과한 설명 없이 사용하는 설계 패턴을 토대로 설명이 가능해짐</li>
</ul>
</li>
<li>널리 사용되는 해결책을 규정함으로 오류를 줄임
<ul>
<li>이미 만들어진 솔루션을 사용</li>
</ul>
</li>
<li>설계에 알맞은 설계 패턴을 찾는 과정에서 오는 발견적 학습</li>
<li>원활한 의사소통</li>
</ul>
<p>다른 발견적 학습</p>
<ul>
<li>강한 응집력을 목표로
<ul>
<li>루틴, 코드가 얼마나 중심적인 목적을 지원하고 있는지, 해당 클래스가 얼마나 집중되어 있는지</li>
</ul>
</li>
<li>계층을 만들어라
<ul>
<li>최상위의 추상적인 항목에서 점차 상세하고 구체적인 낮은 계층으로 이루어진 구조</li>
<li>복잡성 관리를 달성하는 도구</li>
</ul>
</li>
<li>클래스 계약의 형식화</li>
<li>책임의 할당
<ul>
<li>객체에 책임을 할당</li>
</ul>
</li>
<li>테스트를 위한 설계</li>
<li>실패를 피하라
<ul>
<li>과거의 성공만 확인하지 말고 실패를 고려한다</li>
</ul>
</li>
<li>바인딩 시간을 의식해라
<ul>
<li>바인딩 시간 - 특정 값이 변수에 연결되는 시간</li>
</ul>
</li>
<li>제어의 중심점을 만들어라
<ul>
<li>클래스, 루틴, 전처리기 매크로, #include 파일, 명명된 상수 등</li>
</ul>
</li>
<li>주먹구구식 기법의 사용
<ul>
<li>작동하는 주먹구구식 해결법이 작동하지 않는 우아한 해결법 보다 낫다</li>
</ul>
</li>
<li>다이어그램
<ul>
<li>그림을 사용하여 높은 수준의 추상화를 할 수 있다</li>
</ul>
</li>
<li>설계의 모듈화
<ul>
<li>각 루틴, 클래스를 블랙박스처럼 만들어 내부를 랑 수 없도록</li>
</ul>
</li>
<li>발견적 학습에 대한 요약
<ul>
<li>실세계의 객체를 찾아라</li>
<li>일관성있는 추상화를 구성하라</li>
<li>세부사항을 캡슐화하라</li>
<li>상속이 설계를 단순화 하는 경우 상속하라</li>
<li>비밀을 숨겨라</li>
<li>변경을 규명하라</li>
<li>느슨한 결합을 유지하라</li>
<li>널리 사용되는 설계 패턴을 찾아라</li>
<li>강한 응집력을 목표하라</li>
<li>계층을 만들어라</li>
<li>클래스 계약을 형식화하라</li>
<li>책임을 할당하라</li>
<li>태스트를 위해 설계하라</li>
<li>실패를 피하라</li>
<li>바인딩 시간을 의식적으로 선택하라</li>
<li>제어의 중심점을 만들어라</li>
<li>주먹구구식 기법의 사용을 고려하라</li>
<li>다이어그램을 그려라</li>
<li>설계의 모듈화를 유지하라</li>
</ul>
</li>
</ul>
<p>발견적 접근 방법을 위한 지침</p>
<ul>
<li>문제를 해결하는 방법
<ul>
<li>문제의 이해</li>
<li>계획의 고안</li>
<li>계획의 실행</li>
<li>검토</li>
</ul>
</li>
</ul>
<h2>4. 설계 방법</h2>
<p>반복</p>
<ul>
<li>설계를 반복하고 다른 접근 방법을 시도해본다</li>
<li>고수준 문제를 작업함으로써 전체적인 저수준의 세부사항을 고려하는데 도움을 준다</li>
<li>저수준 문제를 작업함으로써 얻는 세부사항은 고수준에서의 현실적인 기초를 제공한다</li>
</ul>
<p>분할 정복</p>
<ul>
<li>프로그램을 서로 다른 관심의 영역으로 나누고 각 부분을 개별적으로 처리한다</li>
</ul>
<p>하향식, 상향식 설계 접근 방법</p>
<ul>
<li>하향식 설계
<ul>
<li>분해 전략</li>
<li>보다 쉽다</li>
<li>구현의 세부사항을 뒤로 미뤄둔다</li>
<li>높은 추상화 수준에서 설계를 시작</li>
<li>기본 클래스, 구체적이지 않은 요소를 정의하면서 시작</li>
<li>한번에 특정한 만큼만 집중할 수 있도록 도와줌</li>
<li>계속해서 여러 수준에서 분해하고 작업하기를 반복</li>
<li>분해하는 것 보다 코드를 작성하는 것이 쉬울 때 까지 분해를 반복한다</li>
</ul>
</li>
<li>상향식 설계
<ul>
<li>결합 전략</li>
<li>전형적인 유틸리티를 초기에 규명해 간결하고 잘 구성된 설계가 될 수 있음</li>
<li>구체적인 것 부터 시작해 일반적인 쪽으로 작업</li>
<li>하향식 접근 방식이 너무 추상적인 경우, 보다 명백한 무언가로 작업해야 하는 경우</li>
<li>이 시스템이 무엇을 해야 하는지에 대해서 내가 무엇을 알고 있는지</li>
<li>객체의 구체적인 책임을 규명</li>
<li>공통적인 객체를 규명하고 서브시스템 구조, 패키지, 객체 내에서의 합성, 상속을 사용해 객체들을 그룹화</li>
<li>다음 상위수준에서 같은 작업을 반복</li>
</ul>
</li>
</ul>
<p>프로토타이핑</p>
<ul>
<li>세부 구현을 제대로 이해하기 전에는 설계가 잘 작동하는 지 알 수 없는 경우가 있을 수 있음</li>
<li>특정 설계 질문에 답하기 위한 최소한의 임시 코드</li>
<li>사용하고 버리는 코드로서 취급해야함
<ul>
<li>프로토타이핑을 위해 작성한 코드를 시스템에 포함시키려고 하면 프로토타이핑이 아닌 시스템을 구현해버림</li>
</ul>
</li>
</ul>
<p>협력적인 설계</p>
<ul>
<li>동료와의 대화, 토론, 페어 프로그래밍</li>
<li>외부의 도움</li>
</ul>
<p>설계를 얼마나 해야할까?</p>
<ul>
<li>프로그램을 만듬에 있어서 고려할 수 있는 내용(팀원의 수준, 안정성의 정도, 프로젝트의 크기 등)을 기준으로 중요도를 파악</li>
</ul>
<p>설계 작업 기록하기</p>
<ul>
<li>설계 문서를 코드에 넣어라</li>
<li>설계의 논의와 결정을 위키에 기록하라</li>
<li>이메일로 요약을 작성하라</li>
<li>CRC 카드를 사용하라
<ul>
<li>클래스, 책임, 협력의 앞자를 딴 카드</li>
<li>클래스의 이름, 클래스가 가지는 책임, 클래스와 협력하는 다른 클래스를 기록</li>
</ul>
</li>
<li>UML 다이어그램을 작성하라
<ul>
<li>Unified Modeling Language</li>
<li>엔티티와 관계들에 대한 표현을 제공</li>
</ul>
</li>
</ul>
<h2>정리</h2>
<ul>
<li>복잡성 관리, 단순화</li>
<li>한번에 처리해야 하는 본질적인 복잡성의 양을 최소화, 부수적인 복잡성의 증가를 방지</li>
<li>발견적 학습</li>
<li>반복적인 설계</li>
<li>정보 은닉, “무엇을 숨겨야하지?” 질문하기</li>
</ul>
<p>복잡성 관리 → 설계의 가장 주된 이유</p>
<p>발견적 학습</p>
<p>지도자가 지도해 주는 것이 아닌 목표와 최소한의 지도를 통해 학습자가 스스로 탐구하여 최종 형태를 이루어 내는 것</p>
<p>여러번의 시행착오, 여러번의 반복된 설계가 좋은 프로그램을 만든다</p>
<h1>6장 클래스 다루기</h1>
<h2>1. 클래스 기초 : 추상 데이터 형 (ADT)</h2>
<p>ADT</p>
<ul>
<li>데이터와 데이터를 다루는 연산의 집합</li>
</ul>
<p>ADT 사용 지침</p>
<ul>
<li>전형적인 저수준의 데이터를 데이터 형이 아닌 ADT 로 만들어라</li>
<li>파일과 같은 일반 객체들을 ADT 로 취급하라</li>
<li>간단한 항목이라도 ADT 로 취급하라
<ul>
<li>간단한 연산이어도 코드가 스스로 설명할 수 있도록 하게 만들고 변경이 쉽도록 한다</li>
</ul>
</li>
<li>ADT 가 저장되어있는 매체에 독립적으로 ADT 를 참조하라</li>
</ul>
<p>ADT 와 클래스</p>
<ul>
<li>ADT 는 클래스의 기본</li>
<li>클래스를 지원하는 언어에서는 ADT 를 클래스로 구현할 수 있다</li>
</ul>
<h2>2. 좋은 클래스 인터페이스</h2>
<p>좋은 추상화</p>
<ul>
<li>클래스 추상화에 대한 평가는 public 루틴의 집합, 클래스의 인터페이스를 기초로 함</li>
<li>좋은 추상 인터페이스는 작성하는 것이 좋은 클래스 인터페이스를 작성하는데 도움을 줌
<ul>
<li>클래스 인터페이스에서 일관된 추상화 수준을 표현한다
<ul>
<li>각각의 클래스는 하나의 ADT 를 구현해야한다</li>
</ul>
</li>
<li>클래스가 구현하고 있는 추상화가 무엇인지 확실하게 이해하여야 한다</li>
<li>서로 반대되는 기능을 갖는 서비스 쌍을 제공하라
<ul>
<li>삽입 ↔ 삭제</li>
<li>on ↔ off</li>
</ul>
</li>
<li>관련 없는 정보를 다른 클래스로 이동시켜라</li>
<li>가능하다면 인터페이스를 의미론적이기 보다는 프로그래밍 적으로 만들어라
<ul>
<li>의미론적인 인터페이스는 주석 등으로 표기하여야 한다</li>
<li>프로그래밍 적으로 데이터 타입, 컴파일러에서 특정되게 하여야 한다</li>
</ul>
</li>
<li>수정 시 인터페이스의 추상화가 손상되는 것을 조심하라</li>
<li>인터페이스 추상화와 어긋나는 public 멤버를 추가하지 말라
<ul>
<li>루틴이 추가될 때마다 기존의 인터페이스에서 제공하는 추상화와 일관성이 있는지 질문한다</li>
</ul>
</li>
<li>추상화와 응집도를 함께 고려하라</li>
</ul>
</li>
</ul>
<p>좋은 캡슐화</p>
<ul>
<li>클래스와 멤버에 대한 접근성을 최소화하라
<ul>
<li>인터페이스 추상화의 무결성을 잘 유지하는 접근제어자를 사용</li>
</ul>
</li>
<li>멤버 데이터를 public 으로 노출하지 말라
<ul>
<li>get/set 을 사용하는 방식으로 데이터를 캡슐화</li>
</ul>
</li>
<li>내부의 세부적인 구현 사항들을 클래스의 인터페이스에 입력하지 않는다
<ul>
<li>구현부와 인터페이스를 분리시킨다</li>
<li>클래스의 선언부에는 구현에 관한 클래스의 포인터를 포함시켜 세부 구현사항을 숨긴다</li>
</ul>
</li>
<li>클래스의 사용자들을 추측하지 말라
<ul>
<li>사용자들의 동작을 추측하여 예상하면 안된다</li>
</ul>
</li>
<li>friend 클래스를 피하라
<ul>
<li>friend 클래스는 캡슐화를 위반한다</li>
</ul>
</li>
<li>public 루틴만을 사용한다고 public 인터페이스에 놓지 말라</li>
<li>코드를 작성할 때의 편의성보다 읽을 때의 편의성을 추구하라</li>
<li>캡슐화의 의미론적 위반을 주의하라
<ul>
<li>작동 방식을 이해하기 위해 내부 구현을 봐야 한다면 추상적인 것이 아니다</li>
</ul>
</li>
<li>지나치게 밀접한 결합을 주의한다
<ul>
<li>클래스와 멤버의 접근성을 최소화하라</li>
<li>friend 클래스는 밀접하게 결합되기 떄문에 피하라</li>
<li>파생 클래스가 기본 클래스와 느슨하게 연결되도록 데이터를 protected 보다 private 로 선언하라</li>
<li>클래스의 public 인터페이스에서 멤버 데이터를 노출하지 말라</li>
<li>캡슐화의 의미론적 위반을 경계하라</li>
<li>데미테르의 법칙을 준수하라</li>
</ul>
</li>
</ul>
<h2>3. 설계와 구현 문제</h2>
<p>포함 관계 (has a 관계)</p>
<ul>
<li>직원은 이름을 가지며(has a), 전화번호를 가지며…등등</li>
<li>최후의 수단으로 private 상속을 통해 has a 를 구현
<ul>
<li>포함하는 클래스가 포함되는 클래스의 protected 멤버 함수, 데이터에 접근가능해짐</li>
<li>조상 클래스와의 지나친 밀접 관계, 캡슐화 위반</li>
</ul>
</li>
<li>4개 이상의 데이터 멤버들을 포함하는 클래스를 주의하라
<ul>
<li>7±2 - 사람이 다른 작업을 할 때 기억할 수 있는 개별적인 항목의 수</li>
<li>클래스의 멤버변수가 너무 많아지만 작은 클래스로 분리할 수 있는지 고려</li>
</ul>
</li>
</ul>
<p>상속 관계 (is a 관계)</p>
<ul>
<li>한 클래스가 다른 클래스를 특수화 한다는 개념</li>
<li>공통적으로 사용되는 요소를 지정하는 기본 클래스와 이를 상속 받는 파생 클래스</li>
<li>반복되는 요소를 집중 시켜 반복을 피하기 위함</li>
<li>상속을 할 때 결정할 사항
<ul>
<li>각 멤버 루틴에 대하여, 루틴이 파생 클래스에서 보일 것인가? 기본 구현을 포함할 것인가? 기본 구현이 override 가 가능할 것인가?</li>
<li>각 데이터 멤버에 대하여, 데이터 멤버가 파생 클래스에서 보일 것인가?</li>
</ul>
</li>
<li>상속의 구현
<ul>
<li>public 상속을 통해서 is a 를 구현
<ul>
<li>새로운 클래스가 오래된 클래스의 특수화된 버전이다(is a)</li>
<li>기본 클래스는 파생 클래스가 어떻게 작동할 지 예측하고 작동에 제약을 가할 수 있다</li>
<li>파생 클래스가 기본 클래스의 계약을 완벽하게 따르지 않으면 잘못된 상속</li>
</ul>
</li>
<li>상속을 위해 설계하고 설명하라, 그렇지 않다면 상속을 금지하라
<ul>
<li>클래스가 상속을 위해 설계되어지지 않았다면 상속을 하면 안된다</li>
</ul>
</li>
<li>LSP, Liskov 치환원리를 따르라
<ul>
<li>하위 클래스 사용자가 그 차이점을 알 필요 없이 기본 클래스의 인터페이스를 통해 사용할 수 있어야 한다</li>
</ul>
</li>
<li>상속 받고싶을 때만 상속을 받아라
<ul>
<li>멤버 루틴에 대해 원하는 방식으로 상속 받기
<ul>
<li>오버라이드가 가능한지, 구현이 필수적인지…</li>
</ul>
</li>
</ul>
</li>
<li>오버라이드가 불가능한 멤버 루틴을 오버라이드 하지 말아라
<ul>
<li>파생 클래스에서 오버라이드가 불가능한 루틴의 이름을 재사용하지 말아라</li>
<li>기본 클래스의 private 함수를 파생 클래스에서 같은 이름으로 생성할 수 있지만 이는 override 가 아니며 혼란을 불러올 수 있다</li>
</ul>
</li>
<li>공용으로 사용되는 인터페이스, 데이터, 행위를 상속 트리의 가능한 위로 이동시켜라
<ul>
<li>공용으로 사용되는 것들이 높게 이동할 수록 파생 클래스에서 이들을 사용하기 쉬워진다</li>
<li>추상화를 깨지 않는 수준에서 높은 곳에 있는 것이 좋다</li>
</ul>
</li>
<li>인스턴스가 하나뿐인 클래스를 의심하라
<ul>
<li>단일 인스턴스는 설계가 객체를 클래스로 오판하고있는 경우</li>
<li>새로운 클래스 대신 객체를 생성</li>
<li>싱글톤은 예외사항</li>
</ul>
</li>
<li>파생 클래스가 하나뿐인 기본 클래스를 의심하라</li>
<li>루틴을 오버라이드 하고 파생된 루틴에서 아무것도 하지 않는 클래스를 의심하라
<ul>
<li>cat.scratch() 를 손톱이 없는 고양이에서 빈 함수로 override 하는 것이 아닌 cat 에 claw 클래스를 포함시키는 방식으로…</li>
</ul>
</li>
<li>깊은 상속을 피하라</li>
<li>광범위한 형 검사보다 다형성을 택하라
<ul>
<li>자주 반복되는 case 는 다형성을 사용해 깔끔하게 만들 수 있다</li>
</ul>
</li>
<li>모든 데이터를 protected 가 아닌 private 로 만들어라
<ul>
<li>상속은 캡슐화를 부순다</li>
</ul>
</li>
</ul>
</li>
<li>다중 상속
<ul>
<li>다중 상속은 과한 복잡성을 부를 수 있다</li>
<li>mixin
<ul>
<li>객체에 일련의 속성을 추가하기 위한 간단한 클래스</li>
<li>displayable, sortable 같은 속성을 나타내는 추상클래스</li>
<li>독립적으로 인스턴스화 하지 않음</li>
</ul>
</li>
<li>mixins
<ul>
<li>혼합물</li>
<li>mixin 들을 다중 상속받아 만들어진 결과물</li>
</ul>
</li>
<li>mixin 들이 완전히 독립적이면 다이아몬드 상속과 같은 문제를 만들지 않는다</li>
</ul>
</li>
<li>상속의 규칙
<ul>
<li>상속과 관련된 문제를 겪지 않기 위한 규칙들
<ul>
<li>데이터를 공유하고 행위를 공유하지 않는 클래스들
<ul>
<li>클래스들을 포함할 객체 생성</li>
</ul>
</li>
<li>행위는 공유하고 데이터는 공유하지 않는 클래스들
<ul>
<li>공통적인 루틴을 공유한 기본 클래스를 상속</li>
</ul>
</li>
<li>데이터와 행위를 공유하는 클래스들
<ul>
<li>공통적인 데이터와 루틴을 정의한 기본 클래스 상속</li>
</ul>
</li>
<li>인터페이스를 제어하기 위한 기본클래스가 필요 - 상속</li>
<li>인터페이스를 제어하고싶을 때 - 포함</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>멤버 함수와 데이터</p>
<ul>
<li>멤버함수와 데이터를 효율적으로 구현하기 위한 지침</li>
<li>클래스에 가능한 적은 수의 루틴을 유지하라</li>
<li>원하지 않는 멤버 함수, 연산자들의 암시적 생성을 차단</li>
<li>호출되는 루틴의 수를 최소화</li>
<li>다른 클래스에 대한 간접 루틴 호출을 최소화
<ul>
<li>데미테르의 법칙
<ul>
<li>객체 A가 객체 B 를 인스턴스화 했을 때 객체 A는 객체 B의 루틴을 호출할 수 있다
<ul>
<li>objectA.getObjectB();</li>
</ul>
</li>
<li>객체 A는 객체 B가 인스턴스한 객체의 루틴은 호출할 수 없다
<ul>
<li>objectA.getObjectB().getObjectOfB(); ← 금지</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>일반적으로 클래스와 다른 클래스가 협력하는 정도를 최소화
<ul>
<li>인스턴스화 되는 객체의 수</li>
<li>인스턴스화 된 객체에 대한 서로 다른 직접적인 루틴 호출의 수</li>
<li>인스턴스화 된 다른 객체에 의해서 리턴되는 객체에 대한 루틴 호출의 수</li>
</ul>
</li>
</ul>
<p>생성자</p>
<ul>
<li>가능하다면 모든 멤버 데이터를 모든 생성자에서 초기화한다</li>
<li>private 생성자를 사용하여 싱글톤 속성을 구현하라</li>
<li>다른 사항들이 증명될 때 까지 깊은 복사를 택하라</li>
</ul>
<h2>4. 클래스를 작성하는 이유</h2>
<ul>
<li>실세계의 객체를 모델링하라</li>
<li>추상 객체들을 모델링 하라
<ul>
<li>실세계의 객체는 아니지만 다른 객체의 추상화를 제공하는 객체를 모델링</li>
</ul>
</li>
<li>복잡성을 줄여라
<ul>
<li>클래스를 작성한 뒤에는 클래스에 관한 세부 사항을 잊고 클래스를 사용할 수 있어야함 - 추상화되어야 함</li>
</ul>
</li>
<li>복잡성을 고립시켜라
<ul>
<li>오류가 발생했을 때 해당 오류가 지역적으로 분포하도록</li>
<li>오류의 수정이 코드 전체에 영향을 미치는 것이 아니라 해당 클래스에서만 작용하도록</li>
</ul>
</li>
<li>세부적인 정보를 숨겨라</li>
<li>변경의 영향을 제한하라</li>
<li>전역 데이터를 숨겨라
<ul>
<li>접근 루틴에 의해 전역 데이터를 다루도록 함</li>
</ul>
</li>
<li>매개변수의 전달을 간소화하라
<ul>
<li>특정 변수가 여러 루틴들 사이에서 전달되고 있으면 해당 루틴들을 변수를 객체 데이터로 공유하는 클래스에 포함 시킬 수 있다</li>
</ul>
</li>
<li>중앙 집중 관리하라
<ul>
<li>한 곳에서 작업을 처리하도록</li>
</ul>
</li>
<li>코드의 재사용을 도와라
<ul>
<li>재사용이 가능한 코드라면 별도의 클래스로 나누어 재사용이 쉽도록 한</li>
</ul>
</li>
<li>프로그램군(family)을 위한 계획을 작성하라
<ul>
<li>프로그램이 변경될 것을 예상한다면 해당 부분들을 별도의 클래스로 입력하여 고립시킨다</li>
</ul>
</li>
<li>연관된 기능을 패키지화하라
<ul>
<li>관련된 기능들 적당한 그룹으로 패키지</li>
</ul>
</li>
<li>특정한 리팩토링을 수행하라</li>
</ul>
<p>피해야 할 클래스</p>
<ul>
<li>만능 클래스를 생성하지 말라</li>
<li>관련없는 클래스들을 제거하라
<ul>
<li>행위가 없고 데이터만 있는 클래스는 해당 클래스가 진짜 클래스인지 확인 후 데이터들이 다른 클래스들의 멤버 데이터가 될 수 있는지 확인</li>
</ul>
</li>
<li>동사가 따라오는 클래스를 피하라
<ul>
<li>데이터는 없이 행위로만 구성된 클래스의 루틴을 다른 클래스의 루틴으로 변환할 것을 고려</li>
</ul>
</li>
</ul>
<p>클래스 작성의 이유에 대한 요약</p>
<ul>
<li>실세계의 객체를 모델링하라</li>
<li>추상 객체를 모델링하라</li>
<li>복잡성을 줄여라</li>
<li>복잡성을 고립시켜라</li>
<li>세부적인 정보를 숨겨라</li>
<li>변경의 영향을 제한하라</li>
<li>전역 데이터를 숨겨라</li>
<li>매개변수의 전달을 간소화하라</li>
<li>중앙 집중 관리하라</li>
<li>코드의 재사용을 도와라</li>
<li>프로그램군을 위한 계획을 작성하라</li>
<li>연관된 기능을 패키지화하라</li>
<li>특정한 리팩토링을 수행하라</li>
</ul>
<h2>5. 언어에 따른 문제</h2>
<p>기본적으로 다른 언어라고 해도 개념은 같음</p>
<p>실제로 해당 개념을 구현하거나 구현할 때 제약이 다름</p>
<h2>6. 클래스를 넘어서 : 패키지</h2>
<p>클래스간의 의존성을 줄이고 독립적이 되도록</p>
<p>오류에 의한, 기능 추가에 의한 수정 등 특정 클래스가 변화하더라도 다른 클래스가 알지 못하도록</p>
<p>추상화를 잘 시켜 외부에서 사용이 용이하도록</p>
<p>좋은 클래스를 설계하는 법</p>
<p>추상화, 캡슐화를 깨지 않고</p>
<p>인스턴스와 객체간의 차이?</p>
<p>상속이 어려운 것이 나만 그런것이 아니었구나</p>
<p>객체를 어느 수준까지, 어느 정도로 나누는 것이 좋을까</p>
<ul>
<li>사람의 손? 손가락? 그 이상?</li>
</ul>
<h1>7. 고급 루틴</h1>
<p>루틴</p>
<ul>
<li>한 가지 목적을 위해서 호출 가능한 개별적인 매서드, 프로시저</li>
</ul>
<p>작성 이유</p>
<ul>
<li>복잡성을 줄인다</li>
<li>추상화</li>
<li>중복 방지</li>
<li>서브 클래싱 지원</li>
<li>순서를 숨긴다</li>
<li>포인터 연산을 숨긴다</li>
<li>이식성</li>
<li>bool 테스트의 단순화</li>
<li>성능개선</li>
</ul>
<p>응집성</p>
<ul>
<li>하나의 루틴이 한가지 일만 수행하는 것
<ul>
<li>cosin() 보다 cosAndTan() 가 응집성이 낮다</li>
</ul>
</li>
<li>루틴의 이름이 가지고 있는(책임, 역할, 권) 일만 한다</li>
</ul>
<p>함수? 프로시저? 차이를 주어야 하는 이유는?</p>
<p>루틴의 목적 반환값 == 이름 → 함수</p>
<p>이외 → 프로시저</p>
<h1>8. 방어적인 프로그래밍</h1>
<p>assert</p>
<ul>
<li>코드에서 “절대로” 발생하면 안되는 오류를 처리</li>
<li>스스로 검사하기 위한 방어 수단</li>
<li>외부 입력 등으로 인한 오류는 오류 처리 하는 것이 맞다</li>
<li>신뢰할 수 있는 내부의 입력을 검사하기 위한, 스스로 확인하기 위한 수단으로 사용</li>
</ul>
<p>오류 처리 기법</p>
<ul>
<li>발생할 것 이라고 예상되는 오류를 처리</li>
<li>정확성
<ul>
<li>잘못된 결과를 절대 반환하지 않는다</li>
</ul>
</li>
<li>견고성
<ul>
<li>프로그램의 종료보단 적당히 지속되는 것</li>
</ul>
</li>
</ul>
<p>예외</p>
<ul>
<li>예외가 일어난 이유를 던진다
<ul>
<li>오류를 처리하는 것이 간편해진다</li>
</ul>
</li>
</ul>
<p>방책</p>
<ul>
<li>방책을(방화벽을) 담당하는 인터페이스를 생성</li>
<li>해당 인터페이스를 거치는 데이터는 깨끗한 데이터임을 신뢰할 수 있다</li>
<li>수술실을 들어가기 전에 살균실을 들어가는 것 과 같은 원리</li>
</ul>
<p>디버그</p>
<ul>
<li>개발 과정 에서의 공격적 프로그래밍
<ul>
<li>오류의 가능성을 무시할 수 없도록 하라</li>
<li>의도적인 가혹한 환경을 상정</li>
</ul>
</li>
</ul>
<p>선행 조건</p>
<ul>
<li>루틴이 시작되기 이전에 참이어야 하는 조건
<ul>
<li>매개 변수의 조건…</li>
</ul>
</li>
</ul>
<p>후행 조건</p>
<ul>
<li>루틴이 끝난 후 참이어야 하는 조건
<ul>
<li>반환 값의 조건…</li>
</ul>
</li>
</ul>
<p>방어적 프로그래밍의 중요성, 문제점</p>
<p>프로그램에 따라서 적당한 오류 처리 기법을 사용하자</p>
<p>적당한 수준의 방어가 좋다, 과한 방어적 프로그래밍은 프로그램의 성능에 영향을 준다</p>
<p>사용자의 입장에서 무시해도 되는 오류, 무시되면 안되는 오류를 생각하자</p>
<p>assert, 예외 처리의 차이</p>
<p>42 에서는 과한 예외 처리가 필수였음</p>
<p>사소한 오류가 평가에 영향을 미칠 수 있기 때문에 하나의 오류도 발생하면 안됨 (null guard)</p>
<p>때문에 어떤 오류까지 직접 처리해야 하는지가 주된 논쟁 중 하나</p>
<p>null guard 에 대해 어떻게 생각 하시는지</p>
<p>try-catch 문을 main 함수 내부에서 모든 코드에 씌우는 것…</p>
<h1>9. 의사 코드 프로그래밍 프로세스</h1>
<p>PPP (Pseudocode Programming Process)</p>
<p>낮은 수준에서 의사 코드를 짠다</p>
<ul>
<li>의사 코드를 그대로 코드로 만들 수 있을 정도의 수준</li>
<li>높은 수준의 의사 코드는 코드의 세부 사항을 무시하게 된다</li>
<li>의사 코드를 기반으로 코딩을 한 후 의사 코드는 주석으로 남겨둔다</li>
</ul>
<p>검토의 용이함</p>
<p>반복 적인 설계를 함에서 오는 설계의 개선</p>
<p>쉬운 수정</p>
<p>의사 코드 작성 순서</p>
<ul>
<li>루틴의 설계
<ul>
<li>루틴이 해야 하는 일에 대해 정리</li>
</ul>
</li>
<li>사전에 필요한 조건들을 검사</li>
<li>루틴이 해결해야 하는 일을 정의</li>
<li>루틴의 이름 짓기</li>
<li>루틴의 테스트 방법을 결정</li>
<li>기 작성된 코드, 표준 라이브러리에서 사용 가능한 코드를 조사</li>
<li>오류 처리</li>
<li>효율성 고민
<ul>
<li>캡슐화는 잘 되어있나…추상화는 잘 되어있나…코드는 읽기 쉬운가…</li>
</ul>
</li>
<li>사용 가능한 알고리즘, 데이터 형 조사</li>
<li>의사 코드 작성</li>
</ul>
<p>루틴의 헤더 주석</p>
<ul>
<li>루틴이 무엇을 해야 하는 지에 대한 설명</li>
<li>데이터를 다루는 경우를 고려</li>
<li>의사 코드 검사</li>
</ul>
<p>위 과정을 반복하면서 최적의 방법을 찾는다</p>
<p>의사 코드를 실제 코드가 적혀있는 수준에서 작성을 한 뒤 실제 코드를 짜기 전 해당 의사 코드를 사용해 검토와 디버깅을 요구한다</p>
<p>의사 코드가 완벽하다면 이를 기반으로 만들어 지는 코드 또한 완벽할 것이기 때문에 바로 코드를 작성하는 것이 아닌 완벽한 의사 코드를 작성하는 데에 많은 시간을 써야 한다</p>
<p>의사 코드가 실제 코드보다 수정이 간편하고 이해하기 쉬우며 타인에게도 설명해 주기 쉽다</p>
<p>수정이 간편한 의사 코드로 여러 번의 수정 작업을 수행하고, 이를 타인에게 보여줌으로써 더 나은 코드를 작성할 수 있다</p>
<p>다시 한번 설계의 중요성을 알리고 있다</p>
<p>실제로 ‘직관’에서 오는 설계, 코딩을 해 왔었기 때문에 이미 생각하는 내용이 머리에만 있는 상태로 진행을 하였다</p>
<p>충분히 검토가 되지 않은 경우도 있었고 코드를 작성하던 중 세부 사항을 잊어버려 여러 번 다시 생각하게 되는 경우도 있었다</p>
<p>코드 레벨 수준의 의사 코드는 실제로 코드 몇 줄과 1대 1 대응이 가능 해 지므로 완성된 의사 코드를 사용해 코드를 작성하는 것은 그 것 만으로 2번의 코드 작성을 의미한다</p>
<p>또한 의사 코드를 작성 하면서 겪은 시행착오를 포함 하면 여러 번의 반복 적인 설계가 들어가게 되는 것이라고 생각한다</p>
<p>첫 번째로 만들어지는 코드보다 두 번째로 만들어지는 코드가 좋은 것처럼 코드 작성 이전 여러 번의 설계가 들어가는 것이 중요성을 다시금 깨닿고있다</p>
<h1>10. 변수 사용 시 일반적인 문제</h1>
<p>변수의 초기화</p>
<ul>
<li>선언과 동시에 초기화 한다</li>
<li>선언 근처에서 초기화 한다</li>
<li>해당 변수를 처 사용하는 곳 근처에서 초기화 한다
<ul>
<li>근접성 원리</li>
</ul>
</li>
</ul>
<p>프로그램을 시작할 때 작업 메모리를 초기화 한다?</p>
<p>변수 참조의 지역</p>
<ul>
<li>span : 참조 사이에 있는 줄의 수</li>
<li>span 이 작을 수록 읽기 쉽다</li>
</ul>
<p>변수의 수명</p>
<ul>
<li>변수가 생성되고 마지막으로 참조 될 때 까지 줄의 수</li>
<li>짧게 유지하는 것이 좋다</li>
</ul>
<p>바인딩 시간</p>
<ul>
<li>변수와 값이 서로 연결되는 시간</li>
<li>늦출수록 좋다..?</li>
<li>종류
<ul>
<li>코드를 작성한 순간 (직접 값을 넣는 경우)</li>
<li>컴파일 시간 (명명된 상수를 넣는 경우)</li>
<li>로드 시간 (외부의 소스로부터 값을 받아 넣는 경우)</li>
<li>객체 생성 시간 (해당 값이 있는 객체를 생성할 때 마다 값을 받아 넣는 경우)</li>
<li>적시에 (just in time) (해당 값을 사용할 때 마다 받아 넣는 경우)</li>
</ul>
</li>
<li>바인딩 시간이 늦을수록 변수의 사용이 유연해진다</li>
<li>유연성이 높아질 수록 코드의 복잡성은 강해진다</li>
</ul>
<p>변수는 한 가지 목적만을 위해서 사용한다</p>
<ul>
<li>함수, 객체에 책임, 역할, 권한을 주는 것과 마찬가지…?</li>
<li>한 변수를 두 가지 이상의 목적으로 사용하지 말 것</li>
<li>숨겨진 의미를 가지지 말 것
<ul>
<li>변수의 의미가 여러가지 인 경우
<ul>
<li>일반적으로는 양수, 에러일 경우 -1 을 가지는 변수</li>
<li>양수와 음수일 때 각각 다른 역할을 하는 변수</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>→ 예전의 C 에서는 함수 초기에 변수를 선언했어야 했다고 한다</p>
<p>→ 이때는 어땠을까?</p>
<p>변수의 선언과 올바른 사용 방법</p>
<p>참조 span 은 적을수록 좋다</p>
<p>초기화는 최초로 사용하기 직전에 하는 것이 좋다</p>
<p>변수의 수명은 짧을수록 좋다</p>
<p>변수의 바인딩 시간은 늦을수록 유연성이 올라가지만 복잡도 또한 올라간다</p>
<p>변수는 한 가지의 목적으로만 사용 되어야 한다</p>
<p>변수 선언을 상단에 몰아서 하기?</p>
<ul>
<li>c99 부터 가능해진 변수 선언의 위치 자율</li>
<li>c89 이전에는 왜 안됐나? 기술적인 문제?</li>
</ul>
<p>많은 변수를 선언하기 vs 임시 변수 돌려쓰기</p>
<ul>
<li>while, for loop 등을 위한 index variable 의 중복 사용…</li>
</ul>
<p>변수의 숨겨진 목적…printf, scanf, write, read, malloc 과 같은 함수들의 반환 값은?</p>
<h1>11. 변수 이름의 효과</h1>
<p>책임, 역할, 권한이 확실한 이름</p>
<p>다른 변수와 중복되거나 헷갈리지 않는 이름</p>
<p>듣기만 하면 찾아서 사용할 수 있는, 발음이 헷갈리지 않는 이름</p>
<p>유사한 의미를 가진 중복된 변수가 없는 이름</p>
<p>오해할 수 없는 명확한 이름</p>
<p>이 외에는 컨벤션에 맞게 지어진 합당한 이름으로 짓는다</p>
<p>당연하지만 당연하지 않은 내용들</p>
<p>이름을 명명함에 있어서 너무 길어 치기 귀찮은 경우를 피하고 이름을 간단히 명명할 때가 많았다</p>
<p>변수의 이름이 좀 더 길어지더라도 그에 맞는 이름을 지어주는 것이 의사소통에 더 이득이 될 것</p>
<h1>12. 기본 데이터 형</h1>
<p>숫자</p>
<ul>
<li>0, 1 을 제외한 literal 은 define, 상수형으로</li>
<li>이 외의 숫자는 magic number 이므로 사용을 피한다</li>
<li>명시적 형 변환을 사용, 암시적 형 변환은 지양</li>
<li>서로 다른 형의 비교는 지양</li>
<li>정수
<ul>
<li>나눗셈 확인</li>
<li>오버플로우 검사</li>
</ul>
</li>
<li>부동소수점
<ul>
<li>정확하지 않다는 것을 인지</li>
<li>라운딩 오류</li>
</ul>
</li>
</ul>
<p>문자, 문자열</p>
<ul>
<li>magic string 은 사용하지 않는다</li>
<li>언어가 unicode를 지원하는 방식에 대해 안다</li>
</ul>
<p>불린(boolean) 변수</p>
<ul>
<li>테스트의 용이</li>
</ul>
<p>열거형</p>
<ul>
<li>가독성, 수정의 용이성</li>
</ul>
<p>명명된 상수</p>
<ul>
<li>프로그램이 매개변수 화
<ul>
<li>프로그램의 특징을 상수 화 시켜 한 곳에 두고 관리</li>
</ul>
</li>
<li>가독성의 증가</li>
</ul>
<p>배열</p>
<ul>
<li>안전하지 않은 프로그램의 가능성
<ul>
<li>stack, queue 등 순차적인 접근이 가능한 자료구조를 먼저 생각한 뒤 배열의 사용을 고려한다</li>
</ul>
</li>
</ul>
<p>새로운 type 을 사용</p>
<ul>
<li>typedef 를 사용해 직접 type 을 명명한다</li>
<li>가독성, 코드의 이해를 돕는다</li>
<li>실제 세계의 자료형을 대입, 컴퓨터 데이터의 type 을 사용하지 않음</li>
<li>typedef 를 사용하는 것이 아닌 class 를 생성하는 방법도 사용</li>
<li>기능 지향적으로 형의 이름을 생성</li>
<li>미리 정의 된 형과 겹치지 않도록</li>
</ul>
<p>기본 데이터 타입에 대한 개관</p>
<p>해당 타입을 사용함에 있어서 타입을 그대로 사용하는 것이 아닌 좋은, 가독성 있는, 유지 보수하기 좋은 코드를 작성하기 위한 팁</p>
<p>-Wall -Werror -Wextra 옵션을 사용해 컴파일을 해 왔었다</p>
<p>덕분에 코드의 여러 문제가 될 부분을 미리 알고 코드를 수정할 수 있었다</p>
<p>이런 류의 경고 옵션들은 잘 사용하면 좋은 것 같다</p>
<p>magic number, magic string 이라는 단어를 보면서 생각을 가지게 만들었다</p>
<p>열거형을 자주 사용하지 않았는데 예시를 보니 확실히 가독성 측면이나 코드를 수정함에 있어서 좋은 결과가 나올 것 같다</p>
<p>상수, define 을 무의식 적으로 사용을 하지 않으려고 했었다</p>
<p>상수형을 사용하지 않고 define 을 많이 사용해왔다, 둘의 차이는? 어떤 방식이 더 유용할까?</p>
<p>메타 템플릿 프로그래밍에 대한 자료를 보면서 class, template class 를 사용해 커스텀 자료형을 만드는 것을 보았다, 메타 프로그래밍을 하는 것이 너무 어려워서 시도는 하지 못하였는데 어떤식으로 사용하게 되는지 좀 더 알아보고싶다</p>
<p>visual c++ warning level</p>
<h1>13. 특이한 데이터 형</h1>
<p>구조체</p>
<ul>
<li>무작정 묶는 것이 아닌 비슷한 성향, 용도, 구성을 가진 변수를 묶는다</li>
</ul>
<p>포인터</p>
<ul>
<li>포인터는 언제나 오류가 나기 쉬운 변수</li>
<li>루틴, 클래스 단위로 고립, 격리시켜 오류가 확산되는 것을 막고 재사용성을 높인다</li>
<li>초기화 되지 않은 포인터는 위험할 수 있으므로 선언과 동시에 초기화하면 seg fault 오류를 낼 가능성이 적어진다</li>
<li>할당이 된 곳에서 해제하거나 생성자에서 할당하였으면 소멸자에서 해제하는 등 대칭적으로 삭제한다</li>
<li>사용하기 전 안전한 곳에 위치하고 있는지 확인 후 사용한다</li>
<li>포인터 변수를 많이 사용하더라도 헷갈리는 부분을 줄인다</li>
<li>dangling pointer 를 막기 위해 삭제, 해제된 포인터는 null 로 초기화한다</li>
</ul>
<p>전역 데이터</p>
<ul>
<li>전역 데이터 수정 여부를 알지 못하는 문제</li>
<li>이름이 겹치게 되어 혼란이 생기는 문제</li>
<li>멀티 스레딩 에서의 문제</li>
<li>코드를 재사용하기 힘들어 지는 문제</li>
<li>모듈화, 관리의 용이성을 힘들게 하는 문제</li>
<li>사용해야 한다면?
<ul>
<li>정리된 테이블에 보관</li>
<li>명명된 상수 대신 사용</li>
<li>열거형 대신 사용</li>
<li>자주 사용되는, 아주 많은 참조를 가지는 경우 사용</li>
</ul>
</li>
<li>다른 방법이 없을 때 최후의 수단으로 사용한다</li>
<li>접근 루틴을 사용한다
<ul>
<li>직접 접근하는 것이 아닌 루틴을 통해서만 접근할 수 있도록 함</li>
<li>lock 을 사용해 접근을 제어한다</li>
<li>접근을 추상화한다</li>
</ul>
</li>
</ul>
<p>잘 사용되지 않는, 혹은 일반적인 방법으로 사용하지 않고 주의를 해야 하는 변수들에 대해서 설명하고 있다</p>
<p>사실 포인터의 경우는 직접 체득한 정보와 거의 유사했다</p>
<p>요즘은 실제로 메모리가 손상이 되어 문제가 될 일은 없을 것 같아 해당 부분은 무시하고 넘어갔지만 그 외의 포인터, 할당 관리에 대한 내용은 실제로 많이 사용하고 있는 방식이었고, 매크로를 사용하는 것 또한 하나의 가비지 컬렉터의 구현이라고 생각하고 구현을 해 본 적이 있다</p>
<p>전역 데이터는 실제로 많이 사용하지 않아서 크게 생각해 본 적이 없었는데 이 책을 읽으면서 강조했던 추상화, 캡슐화를 위반할 수 있다는 점에서, 또 실제로 데이터가 그대로 공개됨으로서 생기는 문제에 대해서 생각을 해 보게 되었다</p>
<h1>14. 직선형 코드 구성하기</h1>
<p>순서가 중요한 명령문</p>
<ul>
<li>의존성을 확실히 하라
<ul>
<li>코드의 구성, 이름, 매개변수를 사용해 실행의 선후관계를 확실히 하라</li>
<li>분명하지 않은 의존성은 주석으로라도 정리</li>
</ul>
</li>
</ul>
<p>순서가 중요하지 않은 명령문</p>
<ul>
<li>가독성을 위해 하향식으로 작성하기</li>
<li>가독성을 위해 연관된 명령문을 그룹화하기</li>
</ul>
<p>당연하지만 중요한 내용</p>
<p>실제로 내 코드에서 의존성을 어떻게 표현할 것 인가에 대해 생각을 많이 했었다</p>
<p>코드의 순서를 어떻게 해야 할 것인가…</p>
<h1>15. 조건문 사용</h1>
<p>if 문</p>
<ul>
<li>else 는 있는 것이 좋다? else 에 들어갈 내용이 없더라도 이유를 주석으로 처리해라?</li>
<li>조건문 안의 내용을 boolean 표현식을 반환하는 루틴을 사용해 단순화 시킨다</li>
<li>앞에 올수록 흔한 경우, 정상적인 경우 이다</li>
</ul>
<p>case 문</p>
<ul>
<li>default 는 마지막 경우가 아닌 위의 경우를 제외한 모든 경우이다, 마지막 한 가지 경우를 위해 default 를 사용하지 말자</li>
<li>break 를 잘 쓰자, break 없이 넘어가는 경우를 잘 쓰는 것은 힘들다</li>
</ul>
<h1>16. 루프 제어</h1>
<p>루프 진입</p>
<ul>
<li>진입은 한 곳 에서만</li>
<li>루프 직전에 초기화</li>
<li>for, while 을 적절하게 사용
<ul>
<li>간단한 곳에서만 for 사용</li>
</ul>
</li>
</ul>
<p>루프 중간</p>
<ul>
<li>중괄호로 묶기</li>
<li>빈 루프 피하기</li>
<li>루프를 제어하기 위한 식은 루프의 시작, 끝에 배치</li>
<li>하나의 루프가 하나의 기능을 수행</li>
</ul>
<p>루프 종료</p>
<ul>
<li>종료 조건을 명확하게</li>
<li>for 의 인덱스를 이유 없이, 임의로 조작하지 않도록</li>
<li>적절한 break, continue 사용
<ul>
<li>루프를 벗어나기 위한 flag 를 조건문에 넣는 것보다 break 를 사용한다</li>
</ul>
</li>
<li>break 가 너무 많아지는 것을 주의</li>
</ul>
<p>팁</p>
<ul>
<li>잘못된 조건문을 막기 위해 서수, 열거형을 사용</li>
<li>루프의 인덱스에 의미 있는 이름의 변수를 사용
<ul>
<li>i, j, k 를 그대로 사용하는 것 보다 이름을 지어주는 것이 가독성에 있어 좋다</li>
</ul>
</li>
</ul>
<h1>17. 특이한 제어 구조들</h1>
<p>return 을 많이 하는 경우</p>
<p>재귀</p>
<p>goto 문</p>
<p>특이한 데에는 이유가 있다</p>
<p>다수의 사람이 사용을 하지 않는 문법에는 그만한 이유가 있다</p>
<p>goto 같은 경우 코드를 간결하게 만들어 줄 수 있고 읽기 쉽게 될 수 있으나 순차적인 논리 구조를 부순다는 점에서 코드 작성에 있어서 좋지 않은 영향을 준다고 생각한다</p>
<p>가끔 코드를 작성할 때 goto 와 같은 문법에 대해 생각해 보기도 하지만 결국 goto 를 사용하기보단 다른 방법을 생각해 내는 것이 더 말이 되는 코드를 작성하는 것에 가까워지게 된다고 생각된다</p>
<h1>18. 테이블을 활용하는 방법</h1>
<p>논리적인 접근이 아닌 테이블을 이용해 접근하는 방법</p>
<p>직접 접근 방식</p>
<ul>
<li>테이블에 직접 접근하여 데이터를 가져오는 방식
<ul>
<li>12달의일 수 를 배열에 넣어두고 월을 배열의 인덱스로 넣어 데이터를 가져온다</li>
</ul>
</li>
<li>값을 논리적으로(if, else) 찾는 것이 아닌 테이블에서 “검색” 을 하게 된다</li>
</ul>
<p>인덱스 접근 방식</p>
<ul>
<li>자료가 담긴 테이블 이전에 인덱스 테이블을 사용</li>
<li>값을 인덱스 테이블에 넣어 키를 찾은 후(검색한 후) 키를 사용해 참조 테이블에서 자료를 가져온다</li>
</ul>
<p>단계적 접근 방식</p>
<ul>
<li>테이블의 값에서 한 단계 씩 여부를 판단</li>
<li>순차적 탐색, 이진 탐색으로 값이 해당 키에 맞는지 여부를 판단한 후 알맞은 키를 사용해 데이터를 탐색</li>
</ul>
<p>다수의 데이터를 처리해야 하는 과제에서 실제로 테이블을 사용해 해결한 적이 있다</p>
<p>복쉘과 같은 작고 수많은 데이터를 while, if 를 사용해 처리하면 시간이 너무 걸리고 그래픽 카드에서 논리 연산을 하는 것은 성능 저하 일어나 이를 해결하기 위해 vram에 배열을 넣어서 해결했다</p>
<h1>19. 제어와 관련된 일반적인 문제</h1>
<p>boolean</p>
<ul>
<li>boolean 변수와 true, false 를 비교하지 말고 그 자체로 boolean 으로 취급</li>
<li>복잡한 표현식을 루틴을 만들어 사용</li>
<li>테이블 사용</li>
<li>부정보단 긍정을 사용</li>
<li>boolean 을 제외한 0에 해당하는 자료형이 있는 경우(int 0, char ‘\0’) 명시적으로 비교</li>
</ul>
<p>널 명령문(빈 명령문) 을 사용하면 눈에 띄도록</p>
<p>깊은 중첩을 피하라</p>
<p>구조적 프로그래밍</p>
<ul>
<li>하나의 입구와 출구만이 있는 제어 구조를 사용한다는 개념</li>
<li>시작과 끝이 하나 뿐인 코드 블록</li>
<li>세 가지 핵심 요소
<ul>
<li>순서 (sequence)</li>
<li>선택 (selection)</li>
<li>반복 (iteration)</li>
</ul>
</li>
</ul>
<p>제어 구조가 프로그램 전체의 복잡도에 영향을 미친다</p>
<p>프로그램의 복잡도</p>
<ul>
<li>프로그램을 이해하기 위해 한번에 기억해야 하는 머릿속 객체의 수</li>
<li>프로그램을 이해하기 위해 얼마만큼의 노력을 들여야 하는가</li>
</ul>
<p>제어문을 작성하면서 나올 수 있는 문제들과 그에 대한 조언</p>
<p>결국 여기서도 복잡도 이야기가 나온다</p>
<p>프로그램이 잘 돌아가게 하는 가장 주된 요소가 아닐까</p>
<p>결국 프로그램의 복잡도를 결정하는 요소는 제어문이라고 하고 이를 잘 제어하는 것이 좋은 프로그램을 작성할 수 있다고 한다</p>
<h1>20. 소프트웨어의 품질에 대한 조망</h1>
<p>소프트웨어 품질 특성</p>
<ul>
<li>사용자가 느끼는 외적인 특성
<ul>
<li>정확성</li>
<li>유용성</li>
<li>효율성</li>
<li>신뢰성</li>
<li>무결성</li>
<li>적응성</li>
<li>정밀성</li>
<li>견고성</li>
</ul>
</li>
<li>프로그래머가 생각해야 할 내적인 특성
<ul>
<li>유지 보수성</li>
<li>유연성</li>
<li>이식성</li>
<li>재사용성</li>
<li>가독성</li>
<li>테스트 용이성</li>
<li>이해성</li>
</ul>
</li>
</ul>
<p>품질관리를 위해</p>
<ul>
<li>위의 품질들을 향상 시키는 것을 목표로 삼고</li>
<li>당장의 배포보다 품질관리를 중요시 하고</li>
<li>테스트를 꼼꼼하게 하고</li>
<li>기술적으로, 공학적으로 관리한다</li>
</ul>
<p>개발 프로세스</p>
<ul>
<li>통제된 변경</li>
<li>결과의 측정</li>
<li>프로토타이핑</li>
</ul>
<p>명확한 목표 설정</p>
<p>결함을 찾을 수 있는 여러 방법들을 사용하여 결함을 잡아내라</p>
<p>조사하는 것이 테스트보다 비용이 적다</p>
<p>결함이 빨리 발견될수록 수정하는데 드는 비용이 적다</p>
<p>테스트를 통한 결함 탐지는 이후 증상을 찾아내는데 드는 비용이 있다</p>
<p>프로그램을 만드는데 코드를 작성하는 시간은 얼마 되지 않는다</p>
<p>많은 시간은 오류를 찾고 디버깅 하는데 소비가 되며 이 시간을 줄이는 것이 좋은 프로그램을 빠르게 만드는 방법이다</p>
<p>품질을 생각하면서 코드를 작성하면 오류가 줄어들어 이에 걸리는 시간을 줄일 수 있게 된다</p>
<p>프로그램을 만드는데 걸리는 시간 중 가장 많은 시간이 디버깅이라는 데에 공감이 간다</p>
<p>또한 글에서 나온 것 처럼 아무리 시간을 오래 사용해도 실제로 코드를 작성하는 시간은 많지 않다</p>
<p>아얘 코드를 작성하기 전 많은 고민을 하고 짧은 시간 안에 코드를 확 작성하는 것이 효율이 좋다는 것은 이미 경험을 통해 알고있다</p>
<p>애매하게 시간이 걸릴때가 오히려 좋지 않은 코드가 나온다</p>
<h1>21. 협력적인 구현</h1>
<p>21.1 협력적인 개발 방법의 개요</p>
<ul>
<li>책임감을 공유하기 위한 기법</li>
<li>여러 테스트보다 협력적인 훈련이 더 효율적이고 다른 테스트에서 찾을 수 없는 종류의 오류를 발견할 수 있다</li>
<li>이미 뛰어난 프로그래머들에게는 지식을 공유할 수 있고 미숙한 프로그래머들에게는 더 많은 가르침을 받을 필요가 있다
<ul>
<li>코드의 형식, 주석, 변수의 명명과 같은 문화에서</li>
</ul>
</li>
<li>코드의 공동 소유권으로 코드가 개인이 것이 아닌 팀의 소유가 되도록
<ul>
<li>여러 사람의 리뷰에 의한 코드 품질 향상</li>
<li>한 사람의 부재로 인한 마비의 방지</li>
<li>모두가 버그를 잡고 에러를 수정함에서 오는 결함 수정 주기의 단축</li>
</ul>
</li>
</ul>
<p>21.2 짝 프로그래밍</p>
<ul>
<li>한 프로그래머가 키보드를 잡고 다른 한 프로그래머가 실수를 감시하면서 코드를 작성하는 방식</li>
<li>성공 요건
<ul>
<li>코드 작성의 표준화</li>
<li>감시가 아닌 “pair”</li>
<li>필요한 부분에서만</li>
<li>짝을 바꾸거나 역할을 교대로</li>
<li>속도를 맞춰서</li>
<li>같이 모니터를 보면서</li>
<li>잘 맞는 사람과</li>
<li>최소 한 사람의 숙련자, 경력자와 함께</li>
<li>한 명이 리더를 맡아서</li>
</ul>
</li>
<li>품질 향상, 일정 단축, 협력적인 문화 보급, 신입 교육, 코드의 공동 소유 장려</li>
</ul>
<p>21.3 형식적인 정밀 검사</p>
<ul>
<li>설계, 코드 정밀 검사
<ul>
<li>이전에 있었던 문제, 나타날 수 있는 문제를 체크 리스트 화 시켜 문제를 찾고 해결하는 방식</li>
<li>이번의 체크 리스트는 다음 정밀 검사 때 제공하여 장기적인 결과의 향상을 도모</li>
</ul>
</li>
<li>진행 상태의 평가를 위해서도 사용</li>
<li>대안을 찾거나 옳고 그름을 판별하는 것이 아닌 코드의 결함을 찾기 위한 과정
<ul>
<li>작성자를 비판하여서는 안됨</li>
<li>작성자로 하여금 검사가 품질 향상에 도움이 될 것 이라는 생각을 하도록 해야 함</li>
<li>작성자는 비판을 그대로 인정하는 것이 아닌 검토 후 결함에 대해 생각하고 그것의 타당성을 생각해야 함</li>
<li>작성자는 결함에 대한 방어를 검토 중에 하는 것이 아님</li>
<li>결함에 대한 최종 결정권은 작성자에게 있음</li>
</ul>
</li>
</ul>
<p>21.4 다른 종류의 협력적인 개발 방법</p>
<p>워크-쓰루 (work-throughs)</p>
<ul>
<li>개괄적인 검토</li>
<li>둘, 셋 이상이 모여 기술적인 문제에 대해 하는 모든 회의</li>
<li>코드를 리뷰하고 설계에 대해 토론하는 것</li>
</ul>
<p>코드 읽기</p>
<ul>
<li>코드를 읽고 오류를 찾는 방식</li>
<li>워크-쓰루와 정밀 검사 사이의 방식</li>
<li>두 명 이상의 검토자들이 코드를 나눠 받고 검토자들에 의해서 발견 된 결함을 위주로 회의</li>
<li>검토자들의 개별적인 검토에 중점</li>
</ul>
<p>코드 설계, 작성 과정 중에 프로그램의 결함을 줄일 수 있는 협력적 프로그래밍 방법을 소개한다</p>
<p>짝 프로그래밍, pair programming 은 두 사람이 하나의 코드를 같이 작성하며 한 명이 코드를 작성하고 한 명이 옆에서 그 코드를 검사하며 프로그래밍을 하는 방식</p>
<p>정밀 검사는 작성 중인, 작성된 설계, 코드를 여러 사람이 보면서 결함을 찾아 내는 방식</p>
<p>42 에서는 혼자 코드를 작성 하지만 후에 주어진 체크 리스트를 기반으로 여러 명의 사람과 1:1로 코드의 결함을 찾고 해당 결함에 대해 이야기를 하는 시간을 갖는다</p>
<p>pair programming 이 제대로 이뤄질 수 있을까? pair 가 된 두 사람이 동등한 관계가 아닌 경우 결국 한 사람이 다른 한 사람을 실시간으로 ‘감시’ 하면서 실시간 코드 리뷰를 하는 방식으로 이루어 질 것 같다</p>
<h1>22. 개발자 테스트</h1>
<p>테스트의 종류</p>
<ul>
<li>테스트 사이즈에 맞춰서
<ul>
<li>단위 테스트</li>
<li>컴포넌트 테스트</li>
<li>통합 테스트</li>
<li>회귀 테스트</li>
<li>시스템 테스트</li>
</ul>
</li>
<li>테스트 하는 주체에 맞춰서
<ul>
<li>블랙박스 테스트
<ul>
<li>테스트 하는 사람이 테스트 되는 항목의 내부 작동을 볼 수 없을 때</li>
</ul>
</li>
<li>화이트박스 테스트
<ul>
<li>테스트 하는 사람이 테스트 되는 항목의 내부 작동을 볼 수 있을 때 - 개발자가 하는 테스트</li>
</ul>
</li>
</ul>
</li>
<li>테스트는 오류를 발견하기 위한 방법</li>
<li>디버깅은 발견된 오류의 원인을 진단하고 수정하기 위한 방법</li>
</ul>
<p>22.1 소프트웨어 품질에서 개발자 테스트의 역할</p>
<ul>
<li>오류를 찾는 것, 성공적인 테스트는 소프트웨어를 부수는 것</li>
<li>테스트가 모든 오류를 찾을 수 없음, 오류가 없다는 것은 테스트가 완벽하지 않거나 비효율적인 테스트라는 것을 의미할 수 있음</li>
<li>테스트가 소프트웨어의 품질을 향상 시키지 않음, 품질의 지표</li>
<li>오류를 찾을 것 이라는 가정, 오류가 없을 것 이라 생각하고 하는 테스트는 오류를 찾을 수 없음</li>
<li>얼마나 많은 시간을 써야 하는가?</li>
<li>테스트의 결과로 무엇을 할 것 인가?</li>
<li>모든 부분은 다른 부분과 결합되기 전 unit test 를 하여야 한다
<ul>
<li>테스트 되지 않은 부분들이 합쳐진 후 오류가 발생하면 모든 부분을 검사하여야 한다</li>
</ul>
</li>
</ul>
<p>22.2 개발자 테스트에 대한 바람직한 접근 방법</p>
<ul>
<li>각각의 연관된 요구 사항이 구현되었는지 테스트</li>
<li>각각의 연관된 설계 사항이 구현되었는지 테스트</li>
<li>요구 사항과 설계 사항의 상세 테스트를 위한 기초 테스트</li>
<li>이전 테스트들의 체크 리스트를 사용</li>
<li>코드 작성 이전? 이후?
<ul>
<li>테스트를 작성하고 코드를 작성하면 테스트에 드는 비용이 줄어든다</li>
<li>테스트를 미리 작성하면 결함을 미리 발견, 인지하고 코드를 작성할 수 있다</li>
<li>테스트를 미리 작성하면 요구 사항과 설계에 대해 먼저 생각 해 볼 수 있다</li>
<li>테스트를 미리 작성하면 요구 사항에 있을 문제를 조기에 노출 시킨다</li>
<li>테스트를 미리 작성하면 코드 작성 이후에도 테스트가 가능하다</li>
<li>“테스트를 먼저 작성하라”</li>
</ul>
</li>
<li>개발자 테스트의 한계
<ul>
<li>코드가 ‘터지는’ 상황에 대한 테스트가 아닌 코드가 ‘작동하는지’ 에 대한 테스트를 하는 경향
<ul>
<li>clean test 보다 dirty test 를 하라</li>
</ul>
</li>
<li>실제보다 적은 테스트 커버리지
<ul>
<li>더 많은 부분을 테스트 하여야 한다</li>
</ul>
</li>
<li>정교하지 못한 테스트
<ul>
<li>더 정교한 테스트, 더 hard 한 테스트</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>22.3 여러가지 테스트 트릭</p>
<ul>
<li>모든 경우를 다 테스트 할 수는 없다</li>
<li>가장 오류에 가까운 ‘테스트 케이스’ 를 선택하여 확인한다</li>
<li>코드 커버리지, 논리 커버리지
<ul>
<li>프로그램의 모든 경로를 테스트 하는 접근 방법</li>
</ul>
</li>
<li>데이터 흐름 테스트
<ul>
<li>데이터 사용이 적어도 제어 흐름은 오류를 유발할 가능성이 있다는 기본 개념</li>
<li>데이터의 상태
<ul>
<li>정의 - 초기화 되었지만 사용되지 않음</li>
<li>사용 - 루틴의 인자로서 사용되었음</li>
<li>삭제 - 한번 정의되었지만 다른 방법에 의해 정의가 해제됨</li>
<li>들어감 - 변수가 사용되기 직전에 루틴에 들어감</li>
<li>빠져나옴 - 변수가 사용된 직후 루틴을 빠져나감</li>
</ul>
</li>
<li>테스트 하여야 할 수준
<ul>
<li>모든 정의</li>
<li>모든 정의 - 사용</li>
</ul>
</li>
</ul>
</li>
<li>등가 분할
<ul>
<li>좋은 테스트 케이스는 데이터의 넓은 부분을 다룬다</li>
<li>두 테스트가 같은 오류를 만들면 하나의 테스트 케이스만 있으면 된다</li>
</ul>
</li>
<li>오류 추측
<ul>
<li>직관, 경험에 의해 테스트 하는 방법</li>
</ul>
</li>
</ul>
<p>22.4 전형적인 오류</p>
<ul>
<li>오류는 균일하게 퍼져있는 것이 아니다, 주로 주요한 클래스에 집중되어있다</li>
<li>오류의 종류는 아주 다양하다
<ul>
<li>대부분의 오류는 적은 수정으로 수정될 수 있다</li>
<li>많은 오류가 프로그래머의 잘못이다</li>
<li>오타로 인한 오류</li>
<li>설계의 잘못된 이해로 인한 오류</li>
</ul>
</li>
<li>테스트의 오류</li>
</ul>
<p>22.5 테스트 지원 도구</p>
<ul>
<li>mock test
<ul>
<li>가짜 데이터를 반환하거나 실제 루틴을 호출하는 가짜 루틴같은 mock 객체, mock 데이터를 사용</li>
<li>JUnit, CppUnit 과 같은 mock test 를 위한 테스트 프레임워크를 사용</li>
</ul>
</li>
<li>테스트 데이터 생성기</li>
<li>커버리지 모니터
<ul>
<li>조사되고 있는 코드와 그렇지 않은 코드를 추적하기 위한 도구</li>
</ul>
</li>
<li>데이터 레코더/로깅</li>
<li>심볼릭 디버거</li>
<li>시스템 교란기</li>
<li>오류 데이터 베이스
<ul>
<li>반복적으로 발생하는 오류를 검사하고 새로 만들어지는 오류에 대한 기록을 한다</li>
</ul>
</li>
</ul>
<p>22.6 테스트를 향상시키는 방법</p>
<ul>
<li>계획 세우기</li>
<li>다시 테스트하기</li>
<li>자동화하기</li>
</ul>
<p>22.7 테스트 기록을 보존하는 방법</p>
<ul>
<li>테스트를 기록함에 있어 넣어야 할 항목들</li>
<li>프로젝트 테스트가 아닌 개인 테스트 또한 기록해 두기</li>
</ul>
<p>테스트의 중요성</p>
<h1>23. 디버깅</h1>
<p>23.1 디버깅 문제의 개요</p>
<p>디버깅은 품질을 향상시키는 것이 아닌 진단하는 방법</p>
<p>결함은 기회다</p>
<ul>
<li>시행착오에 의한 프로그래밍을 하면 안된다</li>
<li>결함을 기회로 배울 수 있다</li>
</ul>
<p>비효율적인 접근 방법</p>
<ul>
<li>추측하기</li>
<li>문제를 완벽하게 이해하기</li>
<li>분명한 곳이 아닌 이곳 저곳에서 오류를 수정하기</li>
<li>미신에 의한 디버깅</li>
</ul>
<p>23.2 결함의 발견</p>
<p>결함을 찾고 결함을 이해하는 것</p>
<p>과학적으로 디버깅 하기</p>
<p>간헐적인 결함을 예측 가능한 안정적인 결함으로</p>
<ul>
<li>결함이 신뢰할 수 있게 발생하도록한다</li>
<li>예측이 불가능한 오류
<ul>
<li>초기화 오류, 시간으로 인한 문제, dangling pointer 문제</li>
</ul>
</li>
<li>오류를 발생시키는 단순한 테스트 케이스를 찾아라</li>
</ul>
<p>오류의 원인을 찾기</p>
<p>결함을 찾는 팁</p>
<p>순차적 대입 (brute-force) 디버깅</p>
<p>구문 오류</p>
<p>23.3 결함의 수정</p>
<p>결함을 수정하는 것은 쉽지만 쉽다는 것은 오류를 내기도 쉽다는 것</p>
<p>문제를, 프로그램을 이해하라</p>
<p>23.4 디버깅에서 심리학적으로 고려해야 할 사항들</p>
<p>“그러길 원하는 것” 과 “실제” 의 심리적 거리</p>
<p>코드를 예상한 대로 보는 것이 아닌 그 자체로 보아야 한다</p>
<p>예상으로 문제 부분을 무시하는 일을 막자</p>
<p>23.5 디버깅 도구</p>
<p>diff</p>
<p>컴파일러</p>
<p>테스트 프레임워크</p>
<p>디버거</p>
<p>결함을 찾아내는 다양한 방법과 그를 해결함에 있어서 가져야 할 마음가짐</p>
<h1>24. 리팩토링</h1>
<p>리팩토링의 의의</p>
<p>이유</p>
<p>방법</p>
<p>주의점</p>
<p>24.1 소프트웨어 진화의 종류</p>
<p>진화가 프로그램의 품질을 향상시키는가?</p>
<p>구현 중 변경되는가 유지 보수 과정 중 변경되는가?</p>
<p>소프트웨어의 진화는 의식적으로 일어나야 한다</p>
<p>개선의 기회가 있을 때 개선해야 한다</p>
<p>24.2 리팩토링에 대한 소개</p>
<p>리팩토링</p>
<ul>
<li>소프트웨어를 보다 쉽게 이해할 수 있고</li>
<li>적은 비용으로 수정할 수 있도록</li>
<li>겉으로 보이는 동작의 변화 없이 내부 구조를 변경하는 것</li>
</ul>
<p>리팩토링을 하는 이유</p>
<ul>
<li>리팩토링을 필요로 하는 코드들…</li>
</ul>
<p>리팩토링을 하면 안되는 이유</p>
<ul>
<li>리팩토링 ≠ 변경</li>
<li>리팩토링은 단순한 변경이 아닌 프로그램의 품질을 향상시키고 복잡성을 줄이는 전략</li>
</ul>
<p>24.3 구체적인 리팩토링</p>
<p>데이터 수준 리팩토링</p>
<p>명령문 수준 리팩토링</p>
<p>루틴 수준 리팩토링</p>
<p>클래스 구현 리팩토링</p>
<p>클래스 인터페이스 리팩토링</p>
<p>시스템 수준 리팩토링</p>
<p>24.4 안전한 리팩토링</p>
<p>리팩토링을 안전하게 하는 방법</p>
<p>리팩토링을 하면 안되는 경우</p>
<p>리팩토링을 남용하지 말 것</p>
<p>24.5 리팩토링 전략</p>
<p>리팩토링을 해야 할 시기를 정하는 방법</p>
<p>언제 리팩토링을 해야하나?</p>
<h1>25. 코드 최적화 전략</h1>
<p>과거에도 최적화의 필요성에 대한 논란이 왔다 갔다 했음</p>
<p>25.1 성능의 개요</p>
<p>성능 ≠ 좋은 코드 인 것을 염두 하자</p>
<p>성능과 코드 최적화</p>
<ul>
<li>프로그램 요구 사항</li>
<li>프로그램 설계</li>
<li>클래스, 루틴의 설계</li>
<li>운영체제 상호작용</li>
<li>코드 컴파일</li>
<li>하드웨어</li>
<li>코드 최적화</li>
</ul>
<p>25.2 코드 최적화에 대한 소개</p>
<p>성능 향상의 가장 효율적인 방법은 아님</p>
<p>효율적은 코드 ≠ 좋은 코드</p>
<p>파레토 법칙</p>
<ul>
<li>20%의 노력으로 80%의 결과를 얻을 수 있다</li>
<li>작은 부분이 큰 영향을 미친다</li>
</ul>
<p>노부인들의 이야기(오래된 구전)</p>
<ul>
<li>미신, 오래된 이야기를 믿고 최적화 하지 마라</li>
</ul>
<p>최적화의 시기</p>
<ul>
<li>좋은 설계, 올바른 프로그램, 유지 보수성이 좋은 프로그램이 정확하게 완성된 뒤 성능을 검사하라</li>
<li>최적화가 필요하다는 것을 알 때 까지 최적화는 필요하지 않다</li>
</ul>
<p>컴파일러 최적화</p>
<ul>
<li>직관적이고 분명한 코드가 교묘한 코드보다 컴파일러가 최적화 하기 쉽다</li>
</ul>
<p>25.3 느리고 비대한 부분들</p>
<p>비효율성의 공통적인 원인을 찾아 프로파일링한다</p>
<p>공통적인 연산의 상대적인 성능 비용을 비교한다</p>
<ul>
<li>특정 연산은 비용을 더 잡아먹는다</li>
</ul>
<p>25.4 측정</p>
<p>실제 분쟁 지역을 판별하고 최적화 한 뒤 전후 차이를 측정 해 본다</p>
<p>경험으로 최적화 하지 말고 실제 값으로 최적화 한다</p>
<ul>
<li>경험적으로 빨랐다고 이번에도 실제로 빨라진다는 보장은 없다</li>
</ul>
<p>측정은 정확하게</p>
<ul>
<li>일반적인 시계가 아닌 CPU 클럭 틱을 사용 한다던가…</li>
</ul>
<p>25.5 반복</p>
<p>성능 저하의 원인을 규명한 뒤 여러 기법을 반복 사용하여 효과를 올린다</p>
<p>코드의 최적화</p>
<p>성능은 단지 품질의 한 가지 요소일 뿐 이며 보통 가장 중요한 요소가 아니다</p>
<ol>
<li>최적화에 실패할 경우를 대비한 백업 (git 등을 사용)</li>
<li>분쟁 지역, 시간이 오래 걸리는 지역을 검색</li>
<li>적절한 최적화 방안을 고민, 최적화 가능한 사항이 없다면 1에서 반복</li>
<li>최적화</li>
<li>성능 측정</li>
<li>코드의 성능이 향상되지 않는다면 1에서 저장한 코드로 돌아가 반복</li>
</ol>
<p>코드의 최적화 방안에는 많은 방법이 있으나 단순히 ‘카더라’ 를 믿지 말고 벤치마킹을 통해 성능 향상을 확인한다</p>
<p>처음으로 최적화를 해 보았던 과제는 container, 그 다음은 최근에 한 voxel 과제였다</p>
<p>앞의 과제는 속도의 기준치를 주었고 뒤의 과제는 원활한 ux 를 위해 스스로 걸어둔 기준이었다</p>
<p>생각한 방법은 많았지만 실제로 효과를 줄 수 있는, 주었던 방법은 몇 안되었고 최적화 성능 한계를 맞추는 것의 어려움을 알았다…</p>
<p>분명 설계부터 문제가 많은 코드였을 것 같은데 처음부터 다시 작성한다는 것이 두려워서 엄두도 못 내었던 것 같다</p>
<p>다시 voxel 과제에 손을 대게 되면 꼭 설계부터 다시 해서 갈아엎어야…</p>
<h1>26. 코드 최적화 기법</h1>
<p>코드의 최적화는 큰 규모에서 설계를 변경하는 것 보다 작은 규모에서 변경을 주로 가리킨다</p>
<p>리팩토링과 유사해 보일 수 있지만 최적화는 ‘내부 구조의 향상’ 과는 거리가 멀고 오히려 성능 향상을 목표로 내부 구조를 손상 시키는 경우가 많다</p>
<p>26.1 논리 구조</p>
<p>논리 식 에서 앞의 결과가 정해지면 뒤의 결과는 계산하지 않는 방법</p>
<ul>
<li>‘단락 회로 평가’라고 불린다</li>
<li>and, or 앞의 결과에 따라 뒤의 연산을 하지 않는 것</li>
<li>loop 에서도 break 나 while 의 조건문에 조건을 추가하는 방식으로 불필요한 요소를 검사하지 않도록 한다</li>
</ul>
<p>빈도에 따른 테스트 정렬</p>
<ul>
<li>if, switch 같은 분기문에서 더 일반적인 경우를 앞에 두어 자주 나오지 않는 경우를 자주 검사하는 것을 방지한다</li>
<li>if-else 문과 switch-case 문의 구현 방식이 언어마다, 컴파일러마다 다르기 때문에 성능 향상에 도움이 될 수도 안 될 수도 있다</li>
</ul>
<p>유사한 논리 구조의 성능 파악</p>
<ul>
<li>case, if-than-else 문과 같은 비슷한 역할을 하는 구문들의 성능을 파악한다</li>
<li>언어, 컴파일러마다 다를 수 있다</li>
</ul>
<p>복잡한 표현식을 테이블 참조로 대체</p>
<ul>
<li>논리 구조가 복잡해지면 테이블 참조를 고려해 본다</li>
</ul>
<p>소극적 평가(lazy evaluation)</p>
<ul>
<li>한번에 모든 것을 계산하는 것이 아닌 그때그때 필요한 부분을 계산 후 저장</li>
<li>후에 필요한 부분을 찾아 존재하면 사용, 없으면 계산</li>
<li>DP 알고리즘과 유사한듯…</li>
</ul>
<p>26.2 루프</p>
<p>Unswitching</p>
<ul>
<li>루프 안의 조건문이 고정되어 있다면 모든 루프에서 이것을 체크하는 것이 아닌 루프 밖에서 한번만 체크하도록 한다</li>
</ul>
<p>Jamming</p>
<ul>
<li>두 개 이상의 루프에서 결합할 수 있는 부분을 찾아 결합하는 것</li>
<li>두 번 이상의 루프를 한번으로 줄인다</li>
</ul>
<p>Unrolling</p>
<ul>
<li>루프의 반복을 줄이는 방법</li>
<li>코드는 더 길어지지만 루프의 반복이 줄어 성능 향상을 노린다</li>
</ul>
<p>루프 내부 작업의 최소화</p>
<ul>
<li>루프 안에서 작업 되는 양을 줄인다</li>
<li>참조, 조건문 등등…</li>
</ul>
<p>감시 값(sentinel values)</p>
<ul>
<li>복합 테스트를 가지는 루프의 조건문을 단순화하는 방식</li>
<li>검색 루프에서 검색되는 범위가 조건에 있을 때 검색완료 &amp;&amp; 범위 지나침 을 두번 검사해야 하는 경우가 있다</li>
<li>이때 검색되는 자료구조의 마지막 값을 임의로 수정하여 이를 한번에 해결한다</li>
</ul>
<p>가장 빈번한 루프를 안쪽에 작성한다</p>
<ul>
<li>중첩 된 루프의 순서를 고려한다</li>
<li>경우는 안, 밖의 조건의 곱으로 똑같지만 조건문을 검사하는 수는 밖의 루프 + (밖의 루프 * 안의 루프) 이다</li>
<li>밖의 루프가 작으면 조건문을 검사하는 수도 적어질 수 있다</li>
</ul>
<p>강도 감소</p>
<ul>
<li>곱셈과 같이 시간이 많이 걸리는 연산을 덧셈같은 시간이 적게 걸리는 연산으로 바꾸는 것</li>
<li>곱셈을 미리 밖에서 해 두는 방식으로 루프 내부에서는 곱셈을 줄인다</li>
</ul>
<p>26.3 데이터 변환</p>
<p>부동소수점 대신 정수</p>
<p>적은 차수의 배열을 사용</p>
<p>배열 참조를 최소화</p>
<p>보조 인덱스 사용</p>
<ul>
<li>c 에서 ‘\0’을 찾아 문자열의 길이를 측정하는 것이 아닌 문자열의 길이를 담고 있는 값을 같이 가지고 있는다
<ul>
<li>가변 길이 배열에서 통용되는 방식</li>
</ul>
</li>
<li>데이터를 직접적으로 움직이는 것이 아닌 참조 형식으로, 혹은 포인터 형식으로 다루어 데이터의 이동을 줄인다</li>
</ul>
<p>캐싱</p>
<ul>
<li>자주 사용되는 값은 저장 해 둔다</li>
</ul>
<p>26.4 표현식</p>
<p>논리 연산에서 표현식 (&amp;&amp;, ||) 의 사용을 줄이는 연산식을 사용한다</p>
<ul>
<li>!a || !b 보다 !(a &amp;&amp; b)</li>
</ul>
<p>강도 감소를 사용한다</p>
<ul>
<li>곱셈을 덧셈으로</li>
<li>제곱을 곱셈으로</li>
<li>2 제곱을 shift 연산으로</li>
</ul>
<p>컴파일 시간에 초기화 하라</p>
<ul>
<li>log2 를 직접 계산하는 것이 아니라 magic number 를 박아 넣는 방식</li>
</ul>
<p>시스템 루틴을 주의하라</p>
<ul>
<li>시스템 상 주어진 함수는 많이 정확하고 많이 느리다</li>
<li>좀 더 부정확한 결과여도 괜찮은 경우(log2 의 정수형이 필요하다던가) 더 간단한 루틴을 만들어 사용한다</li>
</ul>
<p>상수의 정확한 형을 사용하라</p>
<ul>
<li>형 변환 과정에서 오는 시간 손해를 줄인다</li>
</ul>
<p>결과를 사전에 계산하라</p>
<ul>
<li>계산을 미리 해 두고 사용한다</li>
</ul>
<p>공통적인 하위 표현식을 제거하라</p>
<ul>
<li>중복되는 표현식을 변수화 하여 중복 계산을 제거한다</li>
</ul>
<p>26.5 루틴</p>
<p>루틴을 인라인으로 재작성</p>
<ul>
<li>요즘을 루틴 호출에 큰 비용이 들지 않아 크게 효율있지 않다</li>
</ul>
<p>26.6 저급 언어를 이용한 재구성</p>
<p>고급 언어로 프로그램을 작성한 뒤 속도가 중요한 부분만 저급 언어로 재작성한다</p>
<ul>
<li>C# 과 C++ 섞어서 사용한다</li>
</ul>
<p>26.7 변경이 많을수록 상태는 그대로</p>
<p>코드 최적화는 복잡성, 가독성, 단순성, 유지 보수성 등 많은 측면이 성능과 트레이드 된다</p>
<p>정말 최적화가 필요한 것 인지 고민하면서 사용하자</p>
<p>코드의 성능을 높일 수 있는 최적화 기법들</p>
<p>중간 중간에도 이 방법들이 성능은 좋게 만들 수 있지만 코드의 가독성을 떨어트리는 등 코드 품질을 나쁘게 한다는 얘기를 반복해서 한다</p>
<p>적재적소에 활용해야 한다</p>
<p>최적화에 대해 고민을 하면서 실제로 사용했던 방식도 있지만 처음 보는, 신기한 방식이 더 많았다</p>
<p>정말 성능이 중요한 경우에는 사용을 고려 해 봐도 될 것 같다고 생각했다</p>
<h1>27. 프로그램의 크기가 구현에 미치는 영향</h1>
<p>모든 업무가 프로그램의 크기의 비례해서 커지지 않는다</p>
<p>27.1 의사소통의 크기</p>
<p>사람의 수가 많아지면 의사소통의 수는 사람의 수의 제곱에 비례해 커진다</p>
<p>사람이 많아질 수록 의사소통에 문제가 생길 확률도 제곱에 비례해 커진다</p>
<p>27.2 프로젝트 크기의 범위</p>
<p>27.3 프로젝트의 크기가 오류에 미치는 영향</p>
<p>프로젝트의 크기에 따라 오류의 양과 종류가 달라진다</p>
<p>프로젝트의 크기가 증가할 수록 요구 사항과 설계 상에서 실수에 의한 오류가 많아진다</p>
<p>작은 프로젝트에서는 구현 오류가 상대적으로 많다</p>
<p>프로젝트의 크기가 증가할 수록 오류의 밀도, 즉 줄 당 오류의 수가 증가한다</p>
<p>27.4 프로젝트의 크기가 생산성에 미치는 영향</p>
<p>작은 프로젝트에서는 생산성에 영향을 미치는 가장 큰 요소는 프로그래머의 능력</p>
<p>크기가 증가함에 따라 팀의 크기와 조직이 생산성에 더 많은 영향을 미친다</p>
<p>27.5 프로젝트의 크기가 개발 활동에 미치는 영향</p>
<p>활동 비율과 크기</p>
<ul>
<li>프로젝트의 크기에 따라 프로젝트가 필요로 하는 활동의 비율도 달라진다</li>
<li>작은 프로젝트에서는 구현이 제일 중요한 활동이지만 크기가 커지면 아키텍처, 통합 작업, 테스트의 비중이 커진다</li>
</ul>
<p>프로그램, 제품, 시스템, 시스템 제품</p>
<ul>
<li>프로그램
<ul>
<li>가장 간단한 소프트웨어의 종류</li>
<li>한 사람, 또는 몇 사람에 의해서 사용되는 작은 소프트웨어</li>
</ul>
</li>
<li>제품
<ul>
<li>개발자가 아닌 다른 사람에 의해서 사용 될 목적으로 만들어진 프로그램</li>
<li>제품이 릴리즈 되기 전에 많은 테스트와 문서화 과정이 필요하다</li>
</ul>
</li>
<li>시스템
<ul>
<li>함께 작동하는 프로그램 그룹</li>
<li>통합되는 부분 사이의 인터페이스를 개발하는 데에 따른 복잡성과 주의가 요구</li>
</ul>
</li>
<li>시스템 제품
<ul>
<li>시스템과 제품</li>
</ul>
</li>
<li>크기가 커질수록 구현은 프로젝트에서 적은 비율을 차지하며 그 외의 부분의 비중이 커지게 된다</li>
</ul>
<p>방법론과 크기</p>
<ul>
<li>크기에 따라 다른 방법론으로 접근 하여야 함
<ul>
<li>작은 집을 짓는 것과 큰 빌딩을 짓는 것은 다름</li>
</ul>
</li>
</ul>
<p>프로그램의 크기에 따라 달라지는 것에 대한 이야기</p>
<p>프로그램의 크기가 커질 때 선형적으로 증가하는 요소들과 비선형적으로 증가하는 요소들</p>
<p>크기에 따라 다르게 접근해야 함을 알려줌</p>
<p>단순히 코드의 줄 수에 따른 접근이 아닌 제품인지의 여부, 팀의 크기 등에 따라 프로젝트의 크기가 달라진다</p>
<p>프로그램의 크기에 따라 달라지는 것은 실제로 체감을 해 봤다</p>
<p>작은 cli 프로그램을 만들 때와 웹 서비스를 만들 때, gui 프로그램을 만들 때 설계의 중요성이 달라지고, 오류의 종류가 달라지는 것을 체감 하였다</p>
<h1>28. 구현 관리</h1>
<p>소프트웨어 개발 관리</p>
<p>구현에 적용되는 관리 주제</p>
<p>28.1 좋은 코드 작성의 장려</p>
<p>좋은 코드 습관을 어떻게 장려 할 것 인가?</p>
<ul>
<li>엄격한 표준은 좋지 않다</li>
<li>표준을 정해야 한다면 훌륭한 설계자가 표준을 정하자</li>
</ul>
<p>개발자가 정하는 프로젝트 표준</p>
<p>표준 설정 시 고려할 점</p>
<p>좋은 코드 작성을 장려하기 위한 기법</p>
<ul>
<li>짝 프로그래밍</li>
<li>코드 검토 - 동료에 의한 압박</li>
<li>코드의 서명 - 상위 권한자에 의한 승인</li>
<li>검토를 위한 좋은 예제 코드를 공부</li>
<li>코드의 공용 재산화 강조</li>
<li>좋은 코드에 대한 보상</li>
<li>쉬운 표준</li>
</ul>
<p>28.2 형상 관리</p>
<p>시스템이 오랜 시간 무결성을 유지할 수 있도록 체계적으로 프로젝트의 부산물을 규명하고 변화를 처리하기 위한 행위</p>
<p>변경 제어</p>
<p>요구 사항과 설계의 변경</p>
<ul>
<li>변경이 필요할 때 마다 변경을 하게 되면 제어되지 않은 변경으로 인해 불필요한 작업을 반복하게 된다</li>
</ul>
<p>소프트웨어 코드 변경</p>
<ul>
<li>소스 코드의 제어</li>
</ul>
<p>도구 버전</p>
<ul>
<li>사용하는 도구(라이브러리 등)의 버전 제어</li>
</ul>
<p>기계 구성</p>
<p>백업 계획</p>
<p>28.3 구현 일정의 예측</p>
<p>실제로 예측하는 것은 어느 정도의 낙관이 들어간 예측</p>
<p>예측 방법, 예측을 하는데 있어 좋은 접근 방법</p>
<p>구현 양에 대한 예측</p>
<p>일정에 미치는 영향들</p>
<p>예측 vs 제어</p>
<p>일정에 늦었을 경우</p>
<p>28.4 측정</p>
<p>프로젝트를 측정하는 이유</p>
<ul>
<li>무엇이건 간에 측정을 하는 것이 하지 않는 것 보다 낫다</li>
<li>측정의 부작용을 주의하라</li>
<li>측정을 반대하는 것은 프로젝트에 무슨 일이 일어나는 지 모르는 게 낫다고 주장하는 것</li>
</ul>
<p>28.5 프로그래머를 사람으로 대우하기</p>
<p>프로그래머들이 시간을 보내는 방식</p>
<p>성능과 품질의 다양성</p>
<p>개인차</p>
<p>팀 간의 차이</p>
<p>프로그래머의 신앙적인 문제</p>
<p>물리적인 환경</p>
<p>28.6 관리자 관리</p>
<p>직원도 관리자를 다룰 줄 알아야 한다</p>
<p>좋은 환경을 만들고 좋은 코드를 만드는 코드 외 적인 이야기들</p>
<h1>29. 통합</h1>
<p>개별적인 소프트웨어 컴포넌트를 하나의 시스템으로 결합하는 행위</p>
<p>29.1 통합 접근 방법의 중요성</p>
<p>29.2 통합 횟수 - 단계별 또는 점증적?</p>
<p>단계별 통합</p>
<ul>
<li>각 클래스를 설계, 작성, 테스트, 디버깅 - 단위 계발</li>
<li>클래스들을 하나의 큰 시스템으로 결합 - 시스템 통합</li>
<li>전체 시스템을 테스트, 디버깅</li>
<li>시스템에 있는 클래스들이 처음으로 통합될 때 새로운 문제점들이 발생하고 원인을 예상할 수 없다는 문제</li>
<li>문제들이 한순간에 여러 곳에서 발생 한다는 문제</li>
<li>한번에 문제가 불거져 나온다는 점에서 빅뱅 통합이라고 불리기도 함</li>
<li>작은 프로그램에서는 시간을 아끼는 좋은 방식</li>
</ul>
<p>점증적 통합</p>
<ul>
<li>작은 단위로 프로그램을 작성, 테스트 한 다음 한 번에 하나씩 결합</li>
<li>시스템 크기가 작으면서 적은 기능을 수행하는 부분을 개발, 테스트, 디버깅</li>
<li>클래스를 설계, 작성, 디버깅</li>
<li>클래스를 뼈대에 통합, 테스트, 디버깅</li>
<li>새로운 클래스를 추가하기전 확인</li>
<li>눈덩이가 점점 커지는 모양</li>
</ul>
<p>점증적 통합의 이점</p>
<p>29.3 점증적 통합 전략</p>
<p>단계별 통합은 모든 클래스가 한번에 합쳐지며 마감 전까지 순서에 상관없이 모든 작업을 해도 된다</p>
<p>점증적 통합은 순차적으로 클래스가 합쳐지므로 순서가 중요하다</p>
<p>구현 계획을 세워 컴포넌트들이 만들어 지는 순서를 정해 통합하여야 한다</p>
<p>하향식 통합</p>
<ul>
<li>상위 객체, 루틴을 먼저 작성, 통합한다</li>
<li>하위 객체를 대신 해 줄 stub 객체를 만들어 테스트 한다</li>
<li>시간이 지남에 따라 해당 stub 객체들을 실제 객체로 바꾸어 나간다</li>
<li>하향식 통합의 단점을 보완하고자 전체를 수직적인 부분으로 나누어 각각 하향식 통합을 하는 방식을 사용한다</li>
</ul>
<p>상향식 통합</p>
<ul>
<li>계층의 밑단에서 부터 클래스를 작성하고 통합한다</li>
<li>한번에 하나씩 저수준의 클래스들을 추가 해 나간다</li>
<li>저수준의 클래스들을 테스트 하기 위한 드라이버(비계)들을 작성한 다음 클래스를 추가한다</li>
<li>시간이 지남에 따라 테스트 드라이버들을 상위 클래스로 바꾼다</li>
<li>상향식 통합의 단점을 보완하고자 전체를 수직적인 부분으로 나누어 각각 상향식 통합을 하는 방식을 사용한다</li>
</ul>
<p>샌드위치 통합</p>
<ul>
<li>상향적 통합과 하향적 통합의 문제를 해결하기 위한 방법</li>
<li>상위 수준에서 고 수준 비즈니스 객체를 통합</li>
<li>장치-인터페이스 클래스들과 하위 클래스 객체를 통합</li>
<li>상위, 하위 수준의 통합을 위 아래로 진행한 뒤 중간 단계의 통합을 진행</li>
</ul>
<p>위험 지향적인 통합</p>
<ul>
<li>어려운 부분을 우선 통합한다</li>
<li>각 클래스와 연결된 위험 수준을 규명 한 뒤 구현이 어려운 부분을 우선 구현한다</li>
<li>일반적으로 최상위, 최하위 부분이 먼저 구현, 통합된다</li>
</ul>
<p>기능 지향적인 통합</p>
<ul>
<li>한번에 하나의 ‘기능’ 을 통합</li>
<li>시스템의 구체적인 기능 별로 구현, 통합한다</li>
</ul>
<p>T 자형 통합</p>
<ul>
<li>초기 기초 개발을 한 뒤 상세 부분을 수직적으로 개발, 통합한다</li>
</ul>
<p>29.4 일별 빌드와 스모크 테스트</p>
<p>daily build, smoke test</p>
<p>모든 코드를 ‘매일’ 컴파일 해 동작을 확인하는 ‘스모크 테스트’ 을 한다</p>
<p>일별 빌드</p>
<ul>
<li>매일 빌드를 함으로써 개발자들의 일정 동기화를 돕는다</li>
</ul>
<p>망가진 빌드 검사</p>
<ul>
<li>매일 빌드를 해 빌드를 망치는 지점을 찾아 고친다</li>
</ul>
<p>일별 스모크 테스트</p>
<ul>
<li>전체 시스템을 처음부터 끝까지 사용한다</li>
<li>중요한 문제점을 노출시킨다</li>
</ul>
<p>테스트를 최신으로 유지</p>
<ul>
<li>시스템이 커질수록 테스트도 커져야 한다</li>
</ul>
<p>스스로 테스트</p>
<ul>
<li>수정 된 코드를 추가하기 전 스스로 테스트 한다</li>
</ul>
<p>어디에 사용할까?</p>
<p>지속적인 통합</p>
<h1>30. 프로그래밍 도구들</h1>
<p>30.1 설계 도구</p>
<p>설계 다이어그램을 만드는 도구들</p>
<ul>
<li>UML(아키텍처 블록 다이어그램, 계층적 차트, 엔티티 관계 다이어그램, 클래스 다이어그램)</li>
</ul>
<p>30.2 소스 코드 도구</p>
<p>편집</p>
<ul>
<li>통합 개발 환경, IDE</li>
<li>다중 파일 문자열 검색, 바꾸기</li>
<li>비교 도구</li>
<li>병합 도구</li>
<li>소스 코드 정돈 도구</li>
<li>인터페이스 문서화 도구</li>
<li>템플릿</li>
<li>상호 참조 도구</li>
<li>클래스 계층 구조 생성기</li>
</ul>
<p>코드 품질 분석</p>
<ul>
<li>까다로운 문법, 의미 검사기</li>
<li>매트릭스 보고 도구</li>
</ul>
<p>소스 코드 리팩토링</p>
<ul>
<li>리팩토링 도구</li>
<li>재구성 도구</li>
<li>코드 변환 도구</li>
</ul>
<p>버전 관리</p>
<p>데이터 사전</p>
<p>30.3 실행 코드 도구</p>
<p>코드 생성</p>
<ul>
<li>컴파일러</li>
<li>링커</li>
<li>빌드 도구</li>
<li>코드 라이브러리</li>
<li>코드 생성 마법사</li>
<li>셋업, 설치</li>
<li>전처리기</li>
</ul>
<p>디버깅</p>
<p>테스트</p>
<p>코드 최적화</p>
<ul>
<li>프로파일러</li>
<li>어셈블러, 디스 어셈블러</li>
</ul>
<p>30.4 도구 지향적인 환경</p>
<p>unix 환경의 도움을 받을 수 있는 도구를 windows 에서도 사</p>
<p>30.5 자신만의 프로그래밍 도구 개발하기</p>
<p>스크립트</p>
<p>30.6 프로그래밍 도구에 대한 환상</p>
<p>프로그래밍 도구로 인해 프로그래머의 필요성이 사라진다?</p>
<p>프로그래머가 그러한 도구를 사용해서 더 좋은 결과를 낸다</p>
<p>우리는 이미 많은 도구들을 사용하고 있고 더 좋은 도구, 더 편해질 수 있는 도구를 찾는 중이다</p>
<p>새로운 도구를 들이는데 망설임을 갖지 말자</p>
<h1>31. 배치와 방식</h1>
<p>미적인 측면</p>
<p>성능과는 상관없음</p>
<p>31.1 배치 기초</p>
<p>가독성!!</p>
<p>기본적인 형식화 법칙</p>
<ul>
<li>논리적인 구조를 보여주는 배치</li>
<li>코드의 구조를 보여주는 배치</li>
</ul>
<p>프로그램에 대한 사람과 컴퓨터의 해석</p>
<ul>
<li>사람의 눈으로 보는 것과 컴퓨터가 해석하는 것의 차이</li>
<li>사람과 컴퓨터가 모드 잘 이해할 수 있도록, 같은 것을 이해할 수 있도록 하는 것이 좋은 배치</li>
</ul>
<p>좋은 배치의 가치</p>
<ul>
<li>작성 규칙이 이해력에 큰 영향을 줄 수 있다</li>
</ul>
<p>종교</p>
<ul>
<li>본인의 배치에 대해 종교적인 믿음, 맹신을 가지는 경우…</li>
<li>더 좋은 방식이 있다면 적응하는데 시간이 걸리더라고 수용하자</li>
</ul>
<p>목표</p>
<ul>
<li>코드의 논리적인 구조를 정확하고 일관되게 표현</li>
<li>가독성</li>
<li>변경 사항에 대한 내성</li>
</ul>
<p>31.2 배치 기술</p>
<p>공백</p>
<ul>
<li>그룹화</li>
<li>빈 줄</li>
<li>들여쓰기</li>
</ul>
<p>괄호</p>
<p>31.3 배치 방식</p>
<p>순수 블록</p>
<p>순수 블록 흉내 내기</p>
<p>블록 경계를 나타내기 위해 중괄호 사용</p>
<p>줄 끝 배치</p>
<p>어떤 방식이 가장 좋을까?</p>
<p>31.4 제어 구조의 배치</p>
<p>이해, 가독성을 위해 사용</p>
<p>31.5 단일 명령문의 배치</p>
<p>31.6 주석의 배치</p>
<p>31.7 루틴의 배치</p>
<p>31.8 클래스의 배치</p>
<h1>32. 스스로를 설명하는 코드</h1>
<p>프로젝트의 문서화</p>
<ul>
<li>소스 코드 내부</li>
<li>소스 코드 외부</li>
<li>별도의 문서</li>
<li>단위 개발 일지의 코드</li>
</ul>
<p>32.1 외부 문서</p>
<p>단위 개발 일지(Unit Development Folders, UDF)</p>
<p>또는</p>
<p>소프트웨어 개발 일지(Software Development Folder, SDF)</p>
<ul>
<li>개발자가 구현 중에 사용했던 기록들을 포함한 비 형식적인 문서</li>
<li>패키지, 컴포넌트, 클래스를 의미</li>
<li>설계 시의 결정 사항들에 대한 기록</li>
<li>상세 설계 문서
<ul>
<li>저수준 설계 문서</li>
</ul>
</li>
</ul>
<p>32.2 문서화를 위한 프로그래밍 방식</p>
<p>코드 내부에 존재하는 문서</p>
<p>주석, 또는 코드 그 자체</p>
<p>코드의 명료화</p>
<p>32.3 주석을 작성 할 것인가? 작성하지 않을 것인가?</p>
<p>32.4 효율적인 주석을 위한 핵심 사항</p>
<p>주석의 종류</p>
<ul>
<li>코드의 반복</li>
<li>코드의 설명</li>
<li>코드에서의 표시 기능</li>
<li>코드의 요약</li>
<li>코드의 의도를 기술</li>
<li>코드 자체 만으로 표현할 수 없는 정보</li>
</ul>
<p>효율적인 주석 작성하기</p>
<ul>
<li>유지 보수하기 어려운 주석은 지양한다</li>
<li>코드 작성 이전에 주석을 작성한다</li>
<li>주석을 개발 방식에 포함해라 - 주석 개발</li>
<li>성능 때문에 주석을 달지 않는 것은 핑계다</li>
</ul>
<p>적당한 수의 주석</p>
<p>32.5 주석 작성 기법</p>
<p>32.6 IEEE 표준</p>
<p>IEEE std</p>
<p>Institute for Electric and Electrical Engineers Software Engineering Standards</p>
<h1>33. 개인 성격</h1>
<p>33.1 개인 성격은 주제를 벗어난 것 아닌가?</p>
<p>33.2 지성과 겸손</p>
<p>33.3 호기심</p>
<p>33.4 지적인 정직함</p>
<p>33.5 의사 소통과 협동</p>
<p>33.6 창의성과 훈련</p>
<p>33.7 게으름</p>
<p>33.8 생각만큼 중요하지 않은 특성</p>
<ul>
<li>인내력</li>
<li>경험</li>
<li>별난 프로그래밍</li>
</ul>
<p>33.9 습관</p>
<h1>34. 소프트웨어 장인에 대한 주제</h1>
<p>34.1 복잡성 정복</p>
<p>소프트웨어 설계, 구현의 주요 목적은 복잡성을 정복 하는 것</p>
<p>많은 프로그래밍 습관의 목적은 복잡성을 줄이는 것</p>
<p>복잡성을 줄이는 것은 효율적인 프로그래머가 되기 위한 가장 중요한 핵심 요소</p>
<p>34.2 자신에게 맞는 프로세스 선택</p>
<p>알맞은 프로세스가 코드 작성의 기반</p>
<p>34.3 컴퓨터보다 사람을 위한 프로그램을 작성하라</p>
<p>스스로 설명하는 코드</p>
<p>코드의 가독성</p>
<p>코드는 작성보다 읽는데 오랜 시간을 쓴다</p>
<p>34.4 언어에 얽매이지 말고 언어를 활용하는 프로그램을 작성하라</p>
<p>언어가 제공하는 기본적인 개념들에 사고를 제한하지 말아라</p>
<p>34.5 규약을 이용하여 주의를 집중하라</p>
<p>규약은 복잡성을 관리하기 위한 지적인 도구 중 하나</p>
<p>정보를 간결하게 전달</p>
<p>알려진 위험을 예방</p>
<p>코드의 예측 가능성 증가</p>
<p>언어의 약점을 보충</p>
<p>34.6 문제 중심의 프로그램</p>
<p>높은 추상화 단계에서 작업하여야 한다</p>
<p>해결책 보다는 프로그래밍 문제 중심적으로</p>
<p>프로그램을 추상화 수준으로 나누기</p>
<ul>
<li>0 수준 : 운영체제 연산과 기계 명령</li>
<li>1 수준 : 프로그래밍 언어 구조와 도구</li>
<li>2 수준 : 저수준 구현 구조</li>
<li>3 수준 : 저수준 문제 도메인 용어</li>
<li>4 수준 : 고수준 문제 도메인 용어</li>
</ul>
<p>문제 도메인에서 작업하기 위한 저수준 기술들</p>
<p>34.7 낙석을 주의하라</p>
<p>경고를 주의해서 보자</p>
<p>프로그래밍은 과학이 아닌 기술이기 때문에 경고 표시는 직접적이 아닌 간접적으로 나타난다</p>
<p>경고가 될 수 있는 다양한 지표</p>
<ul>
<li>교묘한 코드</li>
<li>많은 오류를 가지고 있는 클래스</li>
<li>코드의 작성 시간보다 긴 디버깅 시간</li>
<li>설계 측정법(design metrics)
<ul>
<li>클래스 멤버의 수</li>
<li>루틴의 결정점의 수</li>
<li>지역 중첩의 수</li>
<li>변수의 수</li>
<li>응집력</li>
<li>결합의 정도</li>
</ul>
</li>
<li>반복되는 같은 수정</li>
<li>테스트 케이스의 복잡함</li>
<li>설계의 난해함</li>
<li>주석을 적기 어려움</li>
</ul>
<p>경고 표시를 눈의 띄기 쉽도록 해라</p>
<ul>
<li>코드가 경고를 쉽게 보이게끔 한다
<ul>
<li>잘못된 참조를 막기 위해 free 한 포인터는 null 로 초기화하여 null 참조를 하도록 만든다</li>
</ul>
</li>
</ul>
<p>컴파일러 경고를 눈여겨 봐라</p>
<p>34.8 반복，반복，또 반복</p>
<p>34.9 소프트웨어와 신조를 떼어 놓아라</p>
<p>신조, 신념을 넣어둬라</p>
<p>소프트웨어 계시(Oracles)</p>
<p>절충주의</p>
<ul>
<li>한 가지의 방법을 고집하지 말자</li>
</ul>
<p>실험</p>

        </article>
        
        
    </main>

    

<footer>
    <p>Author: Dongyoon Kim - <a href="https://biisairo.github.io/">Home</a> - <a href="https://github.com/Biisairo">GitHub</a> - <a
            href="mailto:rlark1224@naver.com">Mail</a></p>
</footer>

</body>

</html>