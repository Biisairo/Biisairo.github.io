<!DOCTYPE html>



<html>

<head>
    <meta charset="UTF-8">
    <title>3장</title>
    <link rel="icon" href="https://biisairo.github.io/static/favicon.ico" type="image/x-icon">
</head>

<script>
    function toggleSection(id) {
        const section = document.getElementById(id);
        const header = section.previousElementSibling;

        if (section.style.display === 'none') {
            section.style.display = 'block';
            header.innerHTML = header.innerHTML.replace('▶', '▼');
        } else {
            section.style.display = 'none';
            header.innerHTML = header.innerHTML.replace('▼', '▶');
        }
    }
</script>

<body>
    <header>
    <nav>
        <ul>
            

            <li><a href="https://biisairo.github.io/">Home</a></li>
            
            <li><a href="https://biisairo.github.io/About/">About</a></li>
            
            <li><a href="https://biisairo.github.io/Study/">Study</a></li>
            
            <li><a href="https://biisairo.github.io/Contact/">Contact</a></li>
            
        </ul>
    </nav>

    <style>
    html,
    body {
        height: 100%;
        margin: 0;
    }

    body {
        display: flex;
        flex-direction: column;
        max-width: 720px;
        margin: 0 auto;
        padding: 2rem 1rem;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
            Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        line-height: 1.6;
        background: #222831;
        color: #EEEEEE;
    }

    header,
    footer {
        text-align: center;
        margin-bottom: 2rem;
    }

    nav ul {
        list-style: none;
        padding: 0;
        display: flex;
        justify-content: space-between;
        align-items: flex-end;

        flex-wrap: wrap;
        gap: 1rem;
    }

    nav li:first-child {
        margin-right: auto;
    }

    nav li:not(:first-child) {
        margin-left: 0;
    }

    nav li:first-child a {
        color: #EEEEEE;
        font-size: 1.5em;
        text-decoration: none;
    }

    nav li:first-child a:hover {
        color: #aadadf;
    }

    nav a {
        color: #00ADB5;
        text-decoration: underline;
        transition: color 0.3s ease;
    }

    nav a:hover {
        color: #66C1C9;
        text-decoration: none;
    }

    main a,
    article a,
    footer a {
        color: #33d3c8;
        text-decoration: underline;
        transition: color 0.3s ease;
    }

    main a:hover,
    article a:hover,
    footer a:hover {
        color: #66C1C9;
        text-decoration: none;
    }

    main {
        flex: 1;
        margin-bottom: 2rem;
    }

    h1,
    h2,
    h3 {
        line-height: 1.3;
        margin-top: 2rem;
        margin-bottom: 1rem;
        color: #00ADB5;
    }

    h2[onclick] {
        user-select: none;
        color: #2699b6;
    }


    ul {
        padding-left: 1.5rem;
    }

    article {
        margin-top: 2rem;
        border: 1px solid #33d3c8;
        padding: 1rem;
        border-radius: 5px;
    }

    footer p {
        font-size: 0.9rem;
        color: #AAAAAA;
    }
</style>

</header>

    <main>
        
        
        

        
        <h2 onclick="toggleSection('pages')" style="cursor: pointer;">▶ 하위 페이지</h2>
        <div id="pages" style="display: none;">
            <ul>
                
                <li><a href="https://biisairo.github.io/Study/%ec%b1%85/%eb%a6%ac%ec%96%bc%ec%9b%94%eb%93%9c%20HTTP/1%ec%9e%a5.html">1장</a></li>
                
                <li><a href="https://biisairo.github.io/Study/%ec%b1%85/%eb%a6%ac%ec%96%bc%ec%9b%94%eb%93%9c%20HTTP/2%ec%9e%a5.html">2장</a></li>
                
                <li><a href="https://biisairo.github.io/Study/%ec%b1%85/%eb%a6%ac%ec%96%bc%ec%9b%94%eb%93%9c%20HTTP/3%ec%9e%a5.html">3장</a></li>
                
                <li><a href="https://biisairo.github.io/Study/%ec%b1%85/%eb%a6%ac%ec%96%bc%ec%9b%94%eb%93%9c%20HTTP/4%ec%9e%a5.html">4장</a></li>
                
                <li><a href="https://biisairo.github.io/Study/%ec%b1%85/%eb%a6%ac%ec%96%bc%ec%9b%94%eb%93%9c%20HTTP/5%ec%9e%a5.html">5장</a></li>
                
                <li><a href="https://biisairo.github.io/Study/%ec%b1%85/%eb%a6%ac%ec%96%bc%ec%9b%94%eb%93%9c%20HTTP/6%ec%9e%a5.html">6장</a></li>
                
                <li><a href="https://biisairo.github.io/Study/%ec%b1%85/%eb%a6%ac%ec%96%bc%ec%9b%94%eb%93%9c%20HTTP/7%ec%9e%a5.html">7장</a></li>
                
                <li><a href="https://biisairo.github.io/Study/%ec%b1%85/%eb%a6%ac%ec%96%bc%ec%9b%94%eb%93%9c%20HTTP/8%ec%9e%a5.html">8장</a></li>
                
            </ul>
        </div>
        

        
        
        <article>
            <h1>3장</h1>
<h1>HTTP/1.1 의 신택스</h1>
<p>1장은 HTTP/1.0 의 기본이 되는 네가지 요소를 2장에서는 구성요소의 조합으로 이루어지는 브라우저의 다양한 처리를 설명했다</p>
<p>이 장에서는 프로토콜 신택스로서 HTTP/1.1 의 변경사항은 다음과 같다 - 통신 고속화 - Keep-Alive 가 기본적으로 유효하다 - 파이프라이닝 - TLS 에 의한 암호화 통신 - 새로운 메서드의 추가 - PUT, DELETE 가 필수 메서드가 됨 - OPTIONS, TRACE, CONNECT 가 추가됨 - 프로토콜 업데이트 - 이름을 이용한 가상 호스트를 지원 - 크기를 사전에 알 수 없는 콘텐츠의 청크 전송 인코딩 지원</p>
<h2>1. 통신 고속화</h2>
<h3>Keep-Alive</h3>
<p>HTTP 의 아래층인 TCP/IP 통신을 효율화 하는 구조</p>
<p>기존의 방식은 하나의 요청마다 한번의 통신이 이루어 지고 통신을 닫아야 했다 Keep-Alive 를 사용하면 연속된 요청이 오면 기존의 접속을 재이용함 TCP/IP 의 접속 대기시간이 줄어들게 되며 한번의 통신에서 처리하는 처리량이 많아져 속도가 올라간 것처럼 보이게 됨</p>
<p>HTTP/1.0 에서는 아래 헤더를 추가함으로서 Keep-Alive 를 사용할 수 있음 <code>Connection: Keep-Alive</code> 위 헤더를 받아들인 서버가 keep-alive 를 지원하면 응답에 같은 헤더를 넣어줌</p>
<p>HTTP/1.1 에서는 이 동작이 기본으로 이루어 지게 되어있음</p>
<p>Keep-Alive 를 이용한 통신은 클라이언트나 서버 한쪽에서 아래 헤더를 부여해 접속을 끊거나 타임 아웃이 날때까지 연결이 유지됨 <code>Connection: Close</code></p>
<p>실제로는 서버에서 통신이 끝난것을 판정할 수 없기때문에 연결의 종료를 명시적으로 보내는 것 보단 타임아웃으로 접속이 종료되는것을 기다리게 됨</p>
<h3>파이프라이닝</h3>
<p>지금은 이 기능을 그대로 사용하지는 않으나 이후 개선의 기초가 됨</p>
<p>최초의 요청이 완료되기 전에 먼저 다음 요청을 보내는 기술 다음 요청까지의 대기시간을 없앰으로서 속도를 향상시킴 Keep-Avlive 이용을 전재로 하며 서버는 들어온 요청을 순서대로 반환</p>
<p>현재는 바르게 구현되지 않거나 구현하였더라도 설정을 꺼둔경우가 많은 잘 사용하지 않는 기술</p>
<p>실제로 사용하더라도 서버는 요청을 받은 순서대로 응답해야 함 응답 생성에 시간이 걸리거나 큰 크기의 파일을 응답해야하는 경우 다른 응답에 영향을 주게됨 - HOL 블로킹 (head-of-line blocking)</p>
<p>파이프라인의 문제들을 해결하고 HTTP/2.0 에서는 스트림이라는 구조로 개발됨 - HTTP/2 부터는 HTTPS 가 전제가 되며 프록시가 송수신 되는 데이터를 볼 수 없음 - 즉 프록시가 통신을 중계만 하고 해석할 수 없기때문에 프록시의 영향에서 벗어나 문제없이 사용할 수 있음 - 통신 순서를 유지해야 한다는 제약이 사라짐 - 하나의 세션안에 복수의 스트림이 공존하며 시분할로 각각의 스트림의 통신이 이루어짐 - 즉 서버측이 준비가 된 순서로 반환할 수 있게되었으며 - 우선순위를 부여할수도 있게됨</p>
<h2>2. 전송 계층 보안 (TLS)</h2>
<p>TLS : transport layer securtiy</p>
<p>HTTP/1.0 에서의 소켓 계층 보안 (SSL : secure sockets layer) 을 바탕으로 개발</p>
<p>HTTP/1.0 과 함께 사용되는것을 의식해서 만들어 졌지만 다양한 통신 프로토콜에 통신의 안정성을 추가해 새로운 프로토콜을 만들수 있는 범용성이 있음 - 메일전송 프로토콜인 SMTP 의 TLS 버전인 SMTPS 등</p>
<p>기존의 80 번 포트를 사용하는 HTTP 와 달리 443 포트를 사용함</p>
<p>통신을 중계하는 게이트웨이 입장에서는 <strong>암호화되어 통신내용을 엿보거나 변경할 수 없는 양방향통신</strong></p>
<p>존재하는 버전이 많으며 현재도 OpenSSL, EV SSL 등 SSL 로 불리는 경우가 많다 사실 SSL 은 취약점이 많이 알려져있고 무효화 되어있는 경우도 많아 사용하지 않으며 현재 SSL 이라는 이름으로 사용중인 것은 거의 TLS 이다</p>
<h3>해시 함수</h3>
<p>해시의 특성 - 같은 알고리즘과 같은 데이터면 결과로서 생성되는 해시값은 항상 같다 - 해시값은 같은 알고리즘이 사용되면 길이가 고정된다 - SHA-256 을 사용하면 항상 256bit(32byte) 이다 - 입력값이 지극히 작은 경우를 제외하면 원본이 해싱된 값보다 작다 - 해시된 값에서 원본데이터를 유추하기 힘들다 (약한 충돌 내성) - 같은 해시값을 만드는 두개의 다른 데이터를 찾기 힘들다 (강한 충돌 내성)</p>
<h3>공통키, 공개키, 디지털 서명</h3>
<p>암호화에서 중요한 점은 알고리즘이 알려져도 안전한 통신을 할 수 있도록 하는 것 많이 사용하는 방식은 알고리즘은 공개하고 그 암호화에 사용되는 데이터(키)를 숨기는 방식</p>
<h3>공통 키 방식 = 대칭 함호</h3>
<p>암호화 하는 키와 복호화 하는 키가 같은 방식 TLS 에서 일반 통신의 암호화에 사용</p>
<h3>공개 키 방식 = 비대칭 암호</h3>
<p>공개키 - 공개되어도 괜찮은 키 비밀키 - 공개되면 안되는 키</p>
<p>공개키로 암호화 하며 비밀키로 복호화 함</p>
<h3>디지털 서명</h3>
<p>공개키 방식을 응용</p>
<p>비밀키로 암호화 하고 공개키로 복호화 한다 암호화 된 데이터를 넘겨주고 공개키로 복호화 한 데이터를 사용해 인증하는 방식</p>
<p>실제로는 본문을 해싱하고 암호화 해서 비밀키로 암호화 하게 됨</p>
<h3>키 교환</h3>
<p>클라이언트와 서버 사이에 키를 교환하는 것 간단히는 클라이언트에서 공통키를 생성한 다음 서버 인증서의 공개키로 암호화 해 서버로 보내줌</p>
<p>실제로는 DH(Diffe-Hellman) 알고리즘에서 파생된 DHE(Diffe-Hellman aqhemeral) 알고리즘을 사용함 키를 직접 교환하는 방식이 아닌 클라이언트와 서버에서 각각 키 재료를 만들어 서로 교환하고 각자 계산해서 같은 키를 얻어내는 방식</p>
<h3>공통키 방식과 공개키 방식을 구분하는 이유</h3>
<p>공개키 방식이 복잡한 만큼 안정성이 높지만 TLS 에서는 두 방식을 조합하여 사용</p>
<p>통신마다 한번만 사용되는 공통키를 만들고 공개키 방식을 사용해 공통키를 전달한 다음 이후 통신에서는 공통키를 사용하여 통신</p>
<p>공개키 방식이 안정성은 좋지만 복호화에 필요한 계산량이 많다</p>
<h3>TLS 통신 절차</h3>
<ol>
<li>핸드셰이크 프로토콜
<ul>
<li>통신을 확립하는 단계</li>
</ul>
</li>
<li>레코드 프로토콜
<ul>
<li>통신 단계</li>
</ul>
</li>
<li>재접속 시의 고속 핸드셰이크
<ul>
<li>SessionTicket 구조를 이용</li>
</ul>
</li>
</ol>
<h3>서버의 신뢰성을 확인</h3>
<ul>
<li>공개키를 보증하는 구조
<ul>
<li>공개키 기반 구조 (PKI - public key infrastructure)</li>
</ul>
</li>
<li>브라우저가 서버로부터 해당 서버의 SSL 서버 인증서를 가져오는 것으로 시작
<ul>
<li>인증서에는
<ul>
<li>사이트 주체 (subject : 이름과 도메인명)</li>
<li>발행자</li>
<li>소유자 서버의 공개키</li>
<li>유효기간</li>
</ul>
</li>
<li>등의 항목이 존재</li>
<li>발행자는 인증기관 (CA : certificate authority) 라고 불림</li>
<li>인증서에는 발행자의 디지털 서명이 있으며 그 발행자의 인증서를 취득함으로 서명을 검증</li>
<li>이후 계속해서 상위 발행자의 인증서를 검토</li>
<li>최종적으로는 발행자와 주체자가 동일한 인증서가 나오며 이를 루트 인증기관 이라고 함
<ul>
<li>루트 인증기관 자신의 신뢰성을 무조건적으로 보증할 수 없으므로 미리 신뢰할 수 있는 기관의 인증서가 설치되어있음</li>
</ul>
</li>
<li>신뢰가 확인되지 않은 발행자와 주체가 같은 인증서는 <strong>자가서명인증</strong> 이라고 불림</li>
</ul>
</li>
</ul>
<h3>키교환, 통신시작</h3>
<p>공개키 암호를 이용한 키 교환 - 클라이언트가 난수를 사용해 공통키를 생성 - 공통키를 만들때는 한쪽에서 완벽한 키를 만드는 것이 아닌 키를 생성할 시드를 서버, 클라이언트 양쪽에서 만들어 교환해 계산 - 시드를 교환할때는 공개키 암호화를 이용 - 서버 인증서에 첨부된 공개키로 통신용 공통키를 암호화 한 뒤 서버로 보냄 - 서버는 인증서의 공개키에 대응되는 비밀키를 가지고 있으므로 데이터를 복호화 해 공통키를 획득</p>
<p>현재는 공개키 암호를 이용한 키 교환이 보안에 문제가 있을 수 있으므로 키 교환 전용 알고리즘을 사용함</p>
<h3>통신</h3>
<p>통신에서는 기밀성과 무결성(조작방지)를 위해 암호화를 함 위에서 교환한 공통키를 이용해 암호화</p>
<h3>통신의 고속화</h3>
<p>위의 과정은 최초 접속시의 흐림 이후에는 공통키를 이용해 암호화를 하며 Keep-Alive 와 같은 방식으로 통신을 고속화 함 TLS 1.2 에서는 세션 재개 기능 (session resumption) 을 사용 - 핸드셰이크 전에 사용하던 세션 ID (32비트) 를 보내 키 교환을 생략</p>
<p>TLS 아래의 계층을 핸드셰이크가 필요한 TCP 가 아닌 UDP 로 대체해 애플리케이션에서 재전송 하는 QUIC 라는 통신방식을 이용하기도 함</p>
<h3>암호 강도</h3>
<h3>암호화 스위트</h3>
<p>TLS 는 HTTP 와 또다른 방식으로 유연성을 부여 <strong>서버를 인증하고 키를 교환해서 통신한다</strong> 라는 흐름은 유지하며 키 교환 방식, 메세지 암호화, 메세지 서명 방식등을 조합하여 리스트화 해 관리하고 서버/클라이언트에서 선택 해 사용할 수 있도록 하는 시스템을 만듬 새로운 알고리즘을 도입하거나 낡은 알고리즘을 비추천 하기 쉬워짐 이러한 알고리즘 세트를 암호화 스위트 (cipher suite) 라고 부름</p>
<h3>프로토콜 선택</h3>
<p>TLS 에서 애플리케이션 계층 프로토콜을 선택할 수 있도록 하는 기능</p>
<h3>TLS 의 의의</h3>
<p>TLS 는 통신 경로의 안전을 지키기 위한 구조 클라이언트와 서버간의 통신 경로를 신뢰할 수 없는 상황에서 안전하게 통신할 수 있도록 만들어짐 그러나 통신경로 밖에서의 정보는 숨겨주지 않음 브라우저의 쿠키를 빼내는 크래킹은 보호해 주나 브라우저를 오작동 시키거나 서버가 크랙되었을때는 정보를 보호해 주지 않음</p>
<h2>3. PUT 메서드와 DELETE 메서드의 표준화</h2>
<p>기존 HTTP/1.0 에서는 옵션이었던 PUT, DELETE 메서드가 필수가 되면서 데이터베이스를 다루는 기본적인 네개의 메서드가 갖추어지게 됨 - CRUD - Create - Read - Update - Delete</p>
<p>새로 만들어진 두개의 메서드는 HTML 폼으로 보내는 것이 아닌 <strong>XMLHttpRequest</strong> 를 사용해야함</p>
<h2>4. OPTIONS, TRACE, CONNECT 메서드 추가</h2>
<h3>OPTIONS</h3>
<p>서버가 받아들일 수 있는 메서드 목록을 반환 Allow 헤더에 결과가 입력되어 반환 됨 대부분의 웹서버에서 사용하지 않거나 사용할 수 없음</p>
<h3>TRACK (TRACK)</h3>
<p>서버가 TRACE 를 받으면 Content-Type 에 message/http 를 설정하고 200 OK 를 붙여 요청 헤더와 바디를 그대로 반환 현재는 임의의 스크립트를 브라우저에 실행하게 하는 크로스 사이트 스크립팅(XSS) 에 취약해 사용하지 않음</p>
<h3>CONNECT</h3>
<p>HTTP 프로토콜 상의 다른 프로토콜의 패킷을 흘릴 수 있게 함 프록시 서버를 거쳐 대상 서버에 접속할 수 있는것이 목적 주로 https 통신을 중계하는 용도로 사용</p>
<h2>5. 프로토콜 업그레이드</h2>
<p>HTTP/1.1 부터는 이외의 프로토콜로 업그레이드 할 수 있게됨 - HTTP 에서 TLS 를 이용해 안전한 통신으로 업그레이드 (TLS) - HTTP 에서 웹소켓을 사용한 양방향 통신으로 업그레이드 (websocket) - HTTP 에서 HTTP/2 로 업그레이드 (h2c)</p>
<h2>6. 가상 호스트 지원</h2>
<p>기존에는 한대의 웹 서버로 하나의 도메인만 다룰 수 있었음 HTTP/1.1 부터 하나의 서버로 여러 서비스를 운영하는 방법이 지원됨</p>
<h2>7. 청크</h2>
<p>전체를 한꺼번에 전송하는 것이 아닌 작게 나눠서 전소아는 방식 시간이 오래 걸리는 데이터전송을 조금씩 앞당겨서 시행할 수 있음 청크 방식을 <strong>스트리밍 다운로드/업로드</strong> 라고 부르기도 함</p>
<p>클라이언트 측에서 처리할때는 받은 청크를 통합하여 처리함 서버에서는 전송에 필요한 블록만 로드해 TCP 소켓에 실어 보냄 - 큰 데이터를 전송할때 데이터의 크기보다 작은 메모리를 사용함</p>
<p>청크방식으로 전송할 경우 청크된 메세지 끝에 헤더를 추가할 수 있음 <code>Trailer: Content-Type</code> <strong>여기서 지정한 헤더는 바디를 보낸 후 전송된다</strong> 라는 명시 청크 형식으로만 사용할 수 있다는 것은 청크 형식임을 사전에 알려야 하며 이를 위해 필요한 헤더는 지정할 수 없음 - Transfer-Encoding - Content-Length - Trailer</p>
<h2>8. 바디 전송 확인</h2>
<p>클라이언트에서 서버로 곧장 데이터를 보내는게 아니라 일단 서버가 데이터를 받을 수 있는지 확인한 후 데이터를 보내는 2단계 전송을 할 수 있음</p>
<p>클라이언트가 바디를 제외한 모든 헤더와 아래의 헤더를 넣어 서버에 요청을 보냄 파일이 없더라고 Content-Length 헤더를 함께 보냄 <code>Expect: 100-continue</code></p>
<p>서버로 부터 <code>100 Continue</code> 응답이 돌아오면 서버가 이를 처리할 수 있다는 뜻이므로 바디를 붙여 다시 전송 서버가 요청을 받을 수 없는경우 <code>417 Expectation Failed</code> 가 돌아올 수 있음</p>

        </article>
        
        
    </main>

    

<footer>
    <p>Author: Dongyoon Kim - <a href="https://biisairo.github.io/">Home</a> - <a href="https://github.com/Biisairo">GitHub</a> - <a
            href="mailto:rlark1224@naver.com">Mail</a></p>
</footer>

</body>

</html>