<!DOCTYPE html>



<html>
<head>
    <meta charset="UTF-8">
    <title>2 TCP IP 의 데이터를 전기 신호로 만들어 보낸</title>
    <link rel="icon" href="https://biisairo.github.io/static/favicon.ico" type="image/x-icon">
</head>
<body>
        <header>
        <nav>
            <ul>
                

                <li><a href="https://biisairo.github.io/">Home</a></li>
                
                    <li><a href="https://biisairo.github.io/About/">About</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/">Study</a></li>
                
                    <li><a href="https://biisairo.github.io/Contact/">Contact</a></li>
                
            </ul>
        </nav>

            <style>
 
html, body {
    height: 100%;
    margin: 0;
}

body {
    display: flex;
    flex-direction: column;
    max-width: 720px;
    margin: 0 auto;
    padding: 2rem 1rem;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
                Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
    line-height: 1.6;
    background: #222831;
    color: #EEEEEE;
}

header, footer {
    text-align: center;
    margin-bottom: 2rem;
}

nav ul {
    list-style: none;
    padding: 0;
    display: flex;
    justify-content: space-between;
    align-items: flex-end;  
    flex-wrap: wrap;
    gap: 1rem;
}

nav li:first-child {
    margin-right: auto;  
}

nav li:not(:first-child) {
    margin-left: 0;
}

nav li:first-child a {
    color: #EEEEEE;
    font-size: 1.5em;
    text-decoration: none;  
}

nav li:first-child a:hover {
    color: #aadadf;  
}

nav a {
    color: #00ADB5;
    text-decoration: underline;
    transition: color 0.3s ease;
}

nav a:hover {
    color: #66C1C9;
    text-decoration: none;
}

main a,
article a,
footer a {
    color: #33d3c8;
    text-decoration: underline;
    transition: color 0.3s ease;
}

main a:hover,
article a:hover,
footer a:hover {
    color: #66C1C9;
    text-decoration: none;
}

 
main {
    flex: 1;
    margin-bottom: 2rem;
}

h1, h2, h3 {
    line-height: 1.3;
    margin-top: 2rem;
    margin-bottom: 1rem;
    color: #00ADB5;
}

ul {
    padding-left: 1.5rem;
}

article {
    margin-top: 2rem;
}

footer p {
    font-size: 0.9rem;
    color: #AAAAAA;
}

    </style>

    </header>

    <main>
        
            
        

        
            <h2>하위 페이지</h2>
            <ul>
                
                    <li><a href="https://biisairo.github.io/Study/%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac/%ec%84%b1%ea%b3%b5%ea%b3%bc%20%ec%8b%a4%ed%8c%a8%eb%a5%bc%20%ea%b2%b0%ec%a0%95%ed%95%98%eb%8a%94%201%25%ec%9d%98%20%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac%20%ec%9b%90%eb%a6%ac/1%20%ec%9b%b9%20%eb%b8%8c%eb%9d%bc%ec%9a%b0%ec%a0%80%ea%b0%80%20%eb%a9%94%ec%8b%9c%ec%a7%80%eb%a5%bc%20%eb%a7%8c%eb%93%a0%eb%8b%a4.html">1 웹 브라우저가 메시지를 만든다</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac/%ec%84%b1%ea%b3%b5%ea%b3%bc%20%ec%8b%a4%ed%8c%a8%eb%a5%bc%20%ea%b2%b0%ec%a0%95%ed%95%98%eb%8a%94%201%25%ec%9d%98%20%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac%20%ec%9b%90%eb%a6%ac/2%20TCP%20IP%20%ec%9d%98%20%eb%8d%b0%ec%9d%b4%ed%84%b0%eb%a5%bc%20%ec%a0%84%ea%b8%b0%20%ec%8b%a0%ed%98%b8%eb%a1%9c%20%eb%a7%8c%eb%93%a4%ec%96%b4%20%eb%b3%b4%eb%82%b8.html">2 TCP IP 의 데이터를 전기 신호로 만들어 보낸</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac/%ec%84%b1%ea%b3%b5%ea%b3%bc%20%ec%8b%a4%ed%8c%a8%eb%a5%bc%20%ea%b2%b0%ec%a0%95%ed%95%98%eb%8a%94%201%25%ec%9d%98%20%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac%20%ec%9b%90%eb%a6%ac/3%20%ec%bc%80%ec%9d%b4%eb%b8%94%ec%9d%98%20%ec%95%9e%ec%9d%80%20LAN%20%ea%b8%b0%ea%b8%b0%ec%98%80%eb%8b%a4.html">3 케이블의 앞은 LAN 기기였다</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac/%ec%84%b1%ea%b3%b5%ea%b3%bc%20%ec%8b%a4%ed%8c%a8%eb%a5%bc%20%ea%b2%b0%ec%a0%95%ed%95%98%eb%8a%94%201%25%ec%9d%98%20%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac%20%ec%9b%90%eb%a6%ac/4%20%ec%95%a1%ec%84%b8%ec%8a%a4%20%ed%9a%8c%ec%84%a0%ec%9d%84%20%ed%86%b5%ed%95%b4%20%ec%9d%b8%ed%84%b0%eb%84%b7%ec%9d%98%20%eb%82%b4%eb%b6%80%eb%a1%9c.html">4 액세스 회선을 통해 인터넷의 내부로</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac/%ec%84%b1%ea%b3%b5%ea%b3%bc%20%ec%8b%a4%ed%8c%a8%eb%a5%bc%20%ea%b2%b0%ec%a0%95%ed%95%98%eb%8a%94%201%25%ec%9d%98%20%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac%20%ec%9b%90%eb%a6%ac/5%20%ec%84%9c%eb%b2%84%ec%b8%a1%ec%9d%98%20LAN%20%ec%97%90%eb%8a%94%20%eb%ac%b4%ec%97%87%ec%9d%b4%20%ec%9e%88%eb%8a%94%ea%b0%80.html">5 서버측의 LAN 에는 무엇이 있는가</a></li>
                
                    <li><a href="https://biisairo.github.io/Study/%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac/%ec%84%b1%ea%b3%b5%ea%b3%bc%20%ec%8b%a4%ed%8c%a8%eb%a5%bc%20%ea%b2%b0%ec%a0%95%ed%95%98%eb%8a%94%201%25%ec%9d%98%20%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac%20%ec%9b%90%eb%a6%ac/6%20%ec%9b%b9%20%ec%84%9c%eb%b2%84%ec%97%90%20%eb%8f%84%ec%b0%a9%ed%95%98%ec%97%ac%20%ec%9d%91%eb%8b%b5%20%eb%8d%b0%ec%9d%b4%ed%84%b0%ea%b0%80%20%ec%9b%b9%20%eb%b8%8c%eb%9d%bc%ec%9a%b0%ec%a0%80.html">6 웹 서버에 도착하여 응답 데이터가 웹 브라우저</a></li>
                
            </ul>
        
        
        
        <article>
            <h1>2. TCP/IP 의 데이터를 전기 신호로 만들어 보낸다</h1>
<h2>1. 소켓을 작성한다</h2>
<h3>1. 프로토콜 스택의 내부 구성</h3>
<ul>
<li>네트워크 애플리케이션
<ul>
<li>브라우저, 메일 프로그램, 웹 서버 등</li>
<li>socket 라이브러리를 사용
<ul>
<li>socket 라이브러리 안에 리졸버가 있음</li>
</ul>
</li>
</ul>
</li>
<li>OS
<ul>
<li>프로토콜 스택
<ul>
<li>TCP 프로토콜을 이용한 데이터 송수신 부분</li>
<li>UDP 프로토콜을 이용한 데이터 송수신 부분</li>
<li>위 두 부분이 애플리케이션으로 부터 데이터를 받아 송수신 동작을 실행</li>
<li>IP 프로토콜을 이용하여 패킷 송수신 동작을 제어
<ul>
<li>IP 는 데이터를 작게 나누어둔 패킷을 통신상대까지 전송하는것이 역할</li>
<li>ICMP
<ul>
<li>패킷 운반 중 오류, 제어용 메시지를 통지</li>
</ul>
</li>
<li>ARP
<ul>
<li>IP 주소에 대응하는 이더넷의 MAC 주소를 조사할때 사용</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>LAN 드라이버
<ul>
<li>LAN 어뎁터의 하드웨어를 제어</li>
</ul>
</li>
</ul>
<h3>2. 소켓의 실체는 통신 제어용 제어 정보</h3>
<ul>
<li>프로토콜 스택 내부의 제어정보
<ul>
<li>통신 상대의 IP 주소</li>
<li>포트번호</li>
<li>통신 동작의 진행상태 등</li>
</ul>
</li>
<li>소켓은 실체가 존재하는 것이 아닌 개념적인 것으로 위에 적힌 데이터를 소켓으로 생각할 수 있다</li>
<li>프로토콜 스택은 소켓에 적힌 제어 정보를 토대로 동작함</li>
</ul>
<h3>3. 소켓을 호출했을 때의 동작</h3>
<ul>
<li>애플리케이션이 소켓을 생성
<ul>
<li>프로토콜 스택에 소켓이 생성될 메모리를 확보한 뒤 소켓의 제어 정보를 저장</li>
<li>초기에는 동작이 없으므로 초기 상태에 대한 제어 정보를 저장</li>
<li>소켓을 나타내는 디스크립터를 애플리케이션에 전달</li>
</ul>
</li>
</ul>
<h2>2. 서버에 접속한다</h2>
<h3>1. 접속의 의미</h3>
<ul>
<li>소켓이 생성된 직후에는 아무것도 기록되어있지 않은 상태
<ul>
<li>송신 의뢰가 와도 데이터를 어디로, 누구에게 보낼지 정해지지 않은 상태</li>
</ul>
</li>
<li>클라이언트
<ul>
<li>소켓에 연결할 서버의 IP 주소나 포트번호를 프로토콜 스택에 알리는 작업</li>
</ul>
</li>
<li>서버
<ul>
<li>소켓을 연 직후에는 아무도 접속을 하지 않은 상태</li>
<li>클라이언트에서 본인의 IP 주소와 포트번호를 알리며 접속을 요구함</li>
<li>서버의 프로토콜 스택이 클라이언트의 정보를 가져오는 작업</li>
</ul>
</li>
<li>통신 상태와의 제어 정보를 주고받아 통신을 위해 필요한 정보를 서로의 소켓에 기록하고 송수신이 가능한 상태로 만드는 것</li>
<li>버퍼 메모리
<ul>
<li>데이터 송수신시 송수신데이터를 일시적으로 저장해 둘 메모리</li>
<li>접속 동작이 실행될 때 확보하게 됨</li>
</ul>
</li>
</ul>
<h3>2. 맨 앞부분에 제어 정보를 기록한 헤더를 배치한다</h3>
<ul>
<li>클라이언트와 서버가 서로 연락을 절충하기 위해 주고받는 제어 정보
<ul>
<li>접속, 데이터 송수신, 연결 종료, 이외의 동작 전체에서 필요한 정보를 정리하여 TCP 프로토콜의 사양으로 기록되어있음</li>
<li>이와같은 정보는 페킷의 맨 앞에 위치하며 ‘헤더’라고 불림</li>
</ul>
</li>
<li>추가 제어정보
<ul>
<li>헤더가 아닌 소켓의 메모리영역에 기록되는 정보</li>
<li>애플리케이션에서 통지된 정보, 통신 상태로 부터 받은 정보 등</li>
<li>프로토콜 스택의 움직임에 관여하는 정보
<ul>
<li>실제 프로토콜 스택의 움직임과 같다</li>
</ul>
</li>
<li>상대측에서는 볼 수 없는 정보</li>
</ul>
</li>
</ul>
<h3>3. 접속 동작의 실제</h3>
<ul>
<li>connect 함수
<ul>
<li>디스크립터, 서버의 IP와 포트번호를 전달받음</li>
</ul>
</li>
<li>인자가 프로토콜 스택의 TCP 담당 부분으로 전달됨</li>
<li>TCP 담당 부분은 IP 와 포트번호를 사용해 서버와 제어 정보를 주고받음</li>
<li>서버의 소켓과 클라이언트의 소켓을 지정하고 컨트롤 비트인 SYN 을 1로 초기화</li>
<li>IP 담당 부분이 만들어진 TCP 헤더를 사용해 패킷을 송신</li>
<li>패킷을 받은 상대 서버의 IP 담당 부분이 서버의 TCP 담당 부분으로 정보를 전달</li>
<li>서버에서는 연결이 되어있는 소켓을 찾아 필요한 정보를 입력하고 접속이 진행중임을 기록</li>
<li>클라이언트와 마찬가지로 SYN 컨트롤 비트를 1로 초기화해 접속이 진행중임을 표시</li>
<li>서버에서 응답을 보낼때는 ACK 컨트롤 비트를 1로 초기화
<ul>
<li>패킷을 받았다는 것을 알리는 컨트롤 비트</li>
<li>네트워크에 오류가 났을 시 패킷이 제대로 전달되었는지 확인할 때 사용</li>
</ul>
</li>
<li>위와같이 만들어진 TCP 헤드를 담은 패킷을 클라이언트로 응답</li>
<li>클라이언트에서 응답을 받았을 시 패킷을 제대로 받았다는걸 서버에 알리기 위해 ACK 컨트롤 비트를 1로 초기화 한 TCP 헤더를 반송</li>
<li>해당 패킷이 서버에 도달하면 접속이 완료됨</li>
<li>접속이 완료되면 파이프가 연결됬다고 간주하며 해당 ‘파이프같은것’ 을 커넥션 이라고 함</li>
<li>커넥션은 데이터가 송수신되는 동안, close 를 호출하여 연결을 끊기 전까지 존재</li>
</ul>
<h2>3. 데이터를 송수신 한다</h2>
<h3>1. 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘긴다</h3>
<ul>
<li>connect 이후 애플리케이션에서 write 함수를 호출하여 프로토콜 스택으로 전송할 데이터를 건네줌
<ul>
<li>프로토콜 스택은 받은 데이터의 내용은 알지 못하며 write 에서 건네준 데이터의 길이만 알고 있음</li>
</ul>
</li>
<li>건네받은 데이터를 프로토콜 스택 내부의 버퍼 메모리에 저장
<ul>
<li>MTU
<ul>
<li>패킷 한개로 운반할 수 있는 최대 데이터 길이</li>
<li>이더넷에서는 보통 1500 바이트</li>
</ul>
</li>
<li>MSS
<ul>
<li>MTU 에서 TCP 헤더를 제외하고 보낼수 있는 데이터의 최대 크기</li>
</ul>
</li>
<li>애플리케이션에서 받은 데이터를 MSS 에 가까워질 만큼 버퍼에 모아놨다가 한번에 보냄
<ul>
<li>작은 데이터의 패킷을 여러번 보내 네트워크의 효율이 떨어지는 것을 방지</li>
</ul>
</li>
<li>매번 MSS 크기만큼의 데이터가 모일 때 까지 기다리게 되면 시간지연이 발생할 수 있음
<ul>
<li>버퍼에 데이터가 모이지 않아도 타이머를 사용 해 일정 시간이 지나면 패킷을 전송하도록 함</li>
</ul>
</li>
<li>두가지 방법을 설정하는 것은 우선적으로 프로토콜 스택의 개발자가 맡음</li>
<li>애플리케이션에서 데이터 송신을 의뢰할 때 두가지 방법 중 어느 것을 사용할 것인지를 선택할 수 있는 옵션이 존재</li>
</ul>
</li>
</ul>
<h3>2. 데이터가 클 때는 분할하여 보낸다</h3>
<ul>
<li>데이터의 크기가 커서 MSS 의 길이를 초과하면 데이터를 나누어 여러 패킷에 담아 보냄</li>
<li>데이터의 맨 앞에 TCP 헤더를 부가 해 조각을 맞춤</li>
</ul>
<h3>3. ACK 번호를 사용하여 패킷이 도착했는지 확인한다</h3>
<ul>
<li>TCP 에서는 패킷을 그냥 보내는 것이 아닌 보낸 패킷이 잘 도착했는지 확인하는 과정이 필요</li>
<li>시퀀스 번호
<ul>
<li>데이터 조각을 송신할 때 조각이 데이터의 몇번째 바이트인지를 TCP 헤더에 기록</li>
</ul>
</li>
<li>송신할 데이터의 크기는 패킷의 크기에서 헤더의 크기를 뺀 것 이므로 따로 기록하지 않음</li>
<li>시퀀스 번호와 송신한 데이터의 크기를 이용하여 데이터의 누락이 있는지 확인할 수 있음
<ul>
<li>ex) 첫번째 패킷에서 1400 바이트를 수신하면 두번째 패킷의 시퀀스 번호가 1401 이어야함</li>
</ul>
</li>
<li>누락이 없는 것을 확인한 송신측은 총 수신한 데이터의 크기를 TCP 헤더의 ACK 번호에 기록해 송신측에 알림</li>
<li>해당 헤더를 통해 송신측에서는 상대가 어디까지 데이터를 수신했는지를 확인할 수 있음</li>
<li>실제 시퀀스 번호는 보안을 위해 난수로 생성된 값을 사용
<ul>
<li>초기값을 알 수 없게 되므로 접속 동작에서 사용한 SYN 제어비트를 1 로 초기화해 시퀀스 번호의 시작임을 알림</li>
</ul>
</li>
<li>TCP 데이터는 양방향 송수신 이므로 위의 동작이 양쪽에서 똑같이 이뤄짐</li>
<li>상대가 데이터를 제대로 받았는지 확인이 될 때 까지 데이터를 버퍼에 저장 해 두고 송신한 데이터에 대응되는 ACK 번호가 되돌아 오지 않을 시 버퍼에서 데이터를 다시 보내게 됨</li>
<li>TCP 에서 송수신을 확인해 주기 때문에 애플리케이션을 포함한 LAN, 버퍼, 라우터 등의 기기에서는 오류에 대한 조치를 하지 않음
<ul>
<li>오류가 생기면 데이터를 버리게 됨</li>
</ul>
</li>
<li>케이블 단선등의 이유로 데이터가 갈 수 없는 경우 TCP 는 계속 데이터를 보내는 것이 아닌 일정 횟수만큼만 전송을 시도
<ul>
<li>전송에 실패하면 애플리케이션에 오류를 통지</li>
</ul>
</li>
</ul>
<h3>4. 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다</h3>
<ul>
<li>타임아웃 값
<ul>
<li>ACK 번호가 반환되는것을 기다리는 시간</li>
</ul>
</li>
<li>TCP 에서 네트워크 상황에 맞게 타임아웃 값을 동적으로 변경
<ul>
<li>데이터를 송신한 후 ACK 번호가 들어오는 값을 기록한 후 이것을 토대로 반환시간을 설정</li>
</ul>
</li>
</ul>
<h3>5. 윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다</h3>
<ul>
<li>한개의 패킷을 보내고 응답이 돌아오는것을 기다리게 되면 다른 패킷을 송신할 수 없어 시간 낭비가 됨</li>
<li>윈도우 제어
<ul>
<li>송신한 패킷의 응답이 돌아오는 것을 확인하지 않고 연속해서 복수의 패킷을 보내는 방식</li>
</ul>
</li>
<li>수신측의 수신능력
<ul>
<li>일반적인 핑퐁방식은 주고 받는 순서가 명확하므로 수신측의 수신능력을 고려하지 않아도 됨</li>
<li>윈도우 제어 방식으로 패킷을 보내면 수신측의 수신능력을 초과하여 패킷을 보낼 수 있음</li>
<li>패킷을 수신하면 수신용 버퍼에 데이터를 저장</li>
<li>수신용 버퍼를 비우는 시간보다 빨리 패킷이 도달하게 되면 오류가 나게 되며 이를 수신능력을 초과했다고 간주</li>
<li>수신측에서 송신측에 수신 가능한 데이터 양을 통지하고 송신측에서 이를 파악해 이 양을 초과하지 않게 보내는것이 윈도우 제어 방식</li>
</ul>
</li>
<li>수신측은 응답 TCP 헤더의 윈도우 필드에 수신 가능한 데이터 양을 적어 송신측에 알림</li>
<li>윈도우 사이즈
<ul>
<li>수신 가능한 데이터의 최댓값</li>
</ul>
</li>
</ul>
<h3>6. ACK 번호와 윈도우를 합승한다</h3>
<ul>
<li>윈도우 통지
<ul>
<li>송신측은 기존에 넘어왔던 윈도우의 크기와 송신한 데이터를 사용해 계산함</li>
<li>수신측에서 버퍼에 있던 데이터가 애플리케이션으로 전달하였을 때 윈도우의 크기가 변하며 이때 송신측에 통지해 줌</li>
</ul>
</li>
<li>ACK 번호 통지
<ul>
<li>수신측에서 데이터를 받았을 때 데이터를 확인해 정상 수신인 경우 송신측에 통지해 줌</li>
</ul>
</li>
<li>윈도우와 ACK 번호를 따로따로 전달하면 수신측에서 송신측에 보내는 패킷이 많아지게 됨</li>
<li>수신측에서 윈도우와 ACK 번호를 그때그때 전송하는 것이 아닌 다음 통지 동작이 일어날 때 둘을 하나의 패킷으로 묶어서 보내게 됨</li>
<li>각각의 통지가 연속해서 일어나면 모든 통지를 따로 보내는 것이 아닌 최후의 것만 통지함</li>
</ul>
<h3>7. HTTP 응답 메시지를 수신한다</h3>
<ul>
<li>브라우저가 리퀘스트 메시지 송신을 의뢰</li>
<li>서버로부터 들어오는 응답을 받기 위해 read 함수를 호출</li>
<li>read 함수로 인해 프로토콜 스택으로 제어를 넘김</li>
<li>데이터를 수신하면 프로토콜 스택의 수신버퍼로 데이터가 들어오고 이 데이터를 애플리케이션에 전달</li>
<li>송수신 과정은 상대만 반대로 브라우저와 서버에 각각 작동됨</li>
</ul>
<h2>4. 서버에서 연결을 끊어 소켓을 말소한다</h2>
<h3>1. 데이터 보내기를 완료했을 때 연결을 끊는다</h3>
<ul>
<li>애플리케이션이 필요한 데이터를 전부 송신했다고 판단하면 연결끊기 단계로 들어감
<ul>
<li>서버, 클라이언트 양쪽 어느쪽에서든 연결 끊기 단계로 들어갈 수 있음</li>
</ul>
</li>
<li>연결 끊기 단계 (서버에서 끊는 경우를 가정)
<ul>
<li>서버가 socket 라이브러리의 close 함수 호출</li>
<li>서버의 프로토콜 스택이 TCP 헤더를 생성
<ul>
<li>연결 끊기를 나타내는 정보 기입</li>
<li>FIN 컨트롤 비트를 1로 설정</li>
</ul>
</li>
<li>서버의 프로토콜 스택에 해당 소켓이 disconnect 에 들어갔다는 것을 기록</li>
<li>클라이언트에서 FIN 컨트롤 비트가 1로 설정된 TCP 헤더를 수신</li>
<li>클라이언트의 프로토콜 스택에 해당 소켓이 disconnect 에 들어갔다는 것을 기록</li>
<li>클라이언트에서 서버로부터 FIN 이 1로 설정 된 패킷을 받은것을 확인하기 위해 ACK 번호를 서버에 반송</li>
<li>애플리케이션이 read 를 사용해 데이터를 요청</li>
<li>데이터를 바로 건네지 않고 서버에서 보낸 데이터를 전부 수신했음을 클라이언트에 알림
<ul>
<li>HTTP 1.0 에서는 데이터 전송이 완료되면 서버에서 통신을 끊도록 되어있음</li>
<li>HTTP 1.1 이후의 버전에서는 연결을 끊지 않고 계속 데이터를 주고 받을 수 있음</li>
<li>오랫동안 응답이 없는 경우 클라이언트에서 연결을 끊을 수 있음</li>
</ul>
</li>
<li>데이터를 전부 받은걸 확인한 애플리케이션이 close 를 호출해 데이터 송수신을 끝냄</li>
<li>클라이언트에서 서버와 마찬가지로 FIN 이 1로 설정된 패킷을 보냄</li>
<li>서버에서 ACK 번호가 들어오면 서버와의 연결이 종료됨</li>
</ul>
</li>
</ul>
<h3>2. 소켓을 말소한다</h3>
<ul>
<li>통신이 끝나면 소켓은 필요가 없어지나 오류를 막기위해 바로 삭제하는 것이 아닌 잠시 시간을 두게 됨</li>
<li>close 를 한 직후에 소켓을 말소하면 상대측에서 ACK 번호를 보낼 때 제대로 받을 수 없게됨</li>
<li>반대로 한쪽에서 close 를 한 직후 소켓을 말소하면 상대측에서 close 를 하면서 FIN 을 넘겨주는 것을 받을 수 없게됨</li>
</ul>
<h3>3. 데이터 송수신 동작을 정리한다</h3>
<ul>
<li>소켓 생성
<ul>
<li>소켓 생성 후 접속 대기단계</li>
<li>클라이언트가 무언가를 요청하면 서버와 접속하여 패킷을 작성</li>
</ul>
</li>
<li>접속
<ul>
<li>SYN 을 1 로 설정한 TCP 헤더를 만들어 패킷에 담아 서버로 전송</li>
<li>TCP 헤더에는 시퀀스 번호의 초깃값이 등록</li>
<li>패킷이 서버에 도달하면 서버에서 SYN 을 1 로 설정한 페킷을 응답</li>
<li>해당 TCP 헤더에는 시퀀스 번호와 윈도우, 클라이언트로부터 데이터를 받은것을 확인하는 ACK 번호가 기록되어있음</li>
<li>해당 패킷을 받은 클라이언트는 패킷을 받았다는 것을 확인하는 ACK 번호가 담긴 TCP 헤더를 전송</li>
<li>서버가 해당 패킷을 받음으로써 접속이 끝남</li>
</ul>
</li>
<li>데이터 송수신
<ul>
<li>TCP 가 송신측의 데이터를 쪼개서 패킷에 저장후 TCP 헤더를 부여해 수신측에 전송</li>
<li>TCP 헤더에는 송신 데이터가 어디서 부터 시작되는지를 기록한 시퀀스 번호가 있음</li>
<li>패킷을 받은 수신측은 ACK 번호를 송신측에 발송</li>
<li>데이터 송수신이 진행되면서 달라지는 윈도우 값 또한 송신측에 전송</li>
</ul>
</li>
<li>접속 해제
<ul>
<li>데이터의 송수신이 끝나면 연결 끊기 동작이 실행</li>
<li>연결을 끊으려는 쪽에서 FIN 컨트롤 비트가 1로 설정된 TCP 헤더를 발송</li>
<li>받은 쪽에서는 받음을 확인하는 ACK 번호를 발송</li>
<li>역방향에서도 똑같이 FIN 컨트롤 비트가 1로 설정된 TCP 헤더를 발송</li>
<li>해당 헤더를 받은 쪽에서 ACK 번호를 발송</li>
<li>이후 시간이 지나면 소켓 말소</li>
</ul>
</li>
</ul>
<h2>5. IP 와 이더넷의 패킷 송수신 동작</h2>
<h3>1. 패킷의 기본</h3>
<ul>
<li>헤더
<ul>
<li>수신처를 나타내는 주소</li>
<li>제어 정보</li>
</ul>
</li>
<li>데이터
<ul>
<li>패킷의 내용물</li>
</ul>
</li>
<li>송신처에서 패킷을 생성</li>
<li>패킷을 가장 가까운 중계 장치에 송신</li>
<li>중계 장치에서 헤더를 확인 후 다음 중계 장치로 송신하기를 반복</li>
<li>최종 수신처로 패킷이 전달</li>
<li>앤드 노드
<ul>
<li>수신처와 송신처는 서로 데이터를 주고 받으며 계속 역할이 바뀌게 됨</li>
<li>따라서 송수신처를 구별하지 않고 호칭하는 쪽이 편함</li>
<li>송수신처를 묶어서 앤드 노드라고 함</li>
</ul>
</li>
<li>중계 장치
<ul>
<li>라우터
<ul>
<li>패킷의 목적지를 확인 해 다음 라우터로 전달</li>
<li>IP 가 목적지를 확인하여 다음 IP 의 중계 장치로 전달</li>
<li>MAC 헤더 (이더넷용 헤더)</li>
</ul>
</li>
<li>허브
<ul>
<li>서브넷 안에서 패킷을 운반하여 다음 라우터로 전달</li>
<li>서브넷 안에 있는 이더넷이 중계 장치까지 패킷을 운반</li>
<li>IP 헤더 (IP용 헤더)</li>
</ul>
</li>
</ul>
</li>
<li>송신처에서 패킷의 목적지의 IP 를 패킷이 IP 헤더에 기록</li>
<li>송신처에서 패킷의 목적지 방향에 있는 중계 장치에 전송되도록 의뢰</li>
<li>라우터에 할당 된 이더넷주소 (MAC 주소)를 MAC 헤더에 기록
<ul>
<li>다음으로 수신될 라우터의 주소</li>
<li>IP 헤더에 적혀있는 IP 주소는 변하지 않음</li>
<li>MAC 헤더에 적혀있는 MAC 주소는 패킷이 라우터를 경유할 때 마다 다음 목적지 라우터의 MAC 주소로 갱신됨</li>
</ul>
</li>
<li>패킷이 허브에 도착하면 허브에서 패킷의 목적지를 판단하기 위해 작성된 이더넷용 표를 사용해 패킷을 전송</li>
<li>허브가 한개이면 바로 목적지로 전송하며 허브가 여러개면 복수의 허브를 순차적으로 이동</li>
</ul>
<h3>2. 패킷 송수신 동작의 개요</h3>
<ul>
<li>애플리케이션에서 프로토콜 스택으로 송신 의뢰</li>
<li>프로토콜 스택의 TCP 담당 부분이 데이터를 나누고 TCP 헤더를 붙여 IP 담당 부분에게 송신을 의뢰</li>
<li>TCP 담당 부분이 건네 준 IP 주소를 확인하여 IP 담당 부분이 IP 헤더와 MAC 헤더를 추가
<ul>
<li>IP 헤더
<ul>
<li>목적지까지 패킷을 전달하기 위한 제어정보</li>
</ul>
</li>
<li>MAC 헤더
<ul>
<li>다음 라우터까지 패킷을 전달하기 위한 제어정보</li>
</ul>
</li>
</ul>
</li>
<li>IP 담당 부분이 생성한 패킷을 네트워크 하드웨어로 전달
<ul>
<li>이더넷, 무선 LAN 등</li>
</ul>
</li>
<li>1, 0 으로 이루어진 패킷을 하드웨어에 맞는 신호로 바뀌어 전송</li>
<li>목적지에 도달된 신호는 해당 기기의 LAN 어댑터에서 디지털 데이터로 변경</li>
<li>패킷을 IP 담당 부분에 전달</li>
<li>IP 담당 부분이 IP 헤더와 MAC 헤더 뒤에 이어지는 내용인 TCP 헤더와 데이터를 TCP 담당 부분에 전달</li>
<li>TCP 담당 부분에서 앞에서 설명한 송수신 과정이 이루어짐</li>
<li>IP 담당 부분은 TCP 담당 부분이 넘겨준 데이터를 확인하지 않으며 안에 어떤 내용이 들어있든 같은 동작을 수행 함</li>
</ul>
<h3>3. 수신처 IP 주소를 기록한 IP 헤더를 만든다</h3>
<ul>
<li>수신처 IP 주소
<ul>
<li>IP 담당 부분은 스스로 수신처를 판단하지 않고 TCP 담당 부분이 보내준 IP 주소를 그대로 헤더에 기입</li>
</ul>
</li>
<li>송신처 IP 주소
<ul>
<li>송신하는 곳의 IP 주소</li>
<li>할당된 IP 주소는 컴퓨터에 할당되는 것이 아닌 LAN 어댑터에 할당이 되어있으며 장착된 어댑터가 많은 경우 한대의 컴퓨터에 여러대의 IP 가 할당될 수 있음</li>
<li>해당 IP 주소에 적히는 IP 주소는 실제 데이터를 전송할 LAN 어댑터의 주소
<ul>
<li>경로 표
<ul>
<li>IP 주소 표 의 다른 이름</li>
<li>Network Destination, Netmask
<ul>
<li>수신처의 IP 주소</li>
<li>0.0.0.0/0.0.0.0
<ul>
<li>기본 게이트웨이</li>
<li>따로 설정된 목적지가 없는 패킷은 기본 게이트웨이를 통해 전송됨</li>
</ul>
</li>
</ul>
</li>
<li>Interface
<ul>
<li>네트워크 인터페이스 (LAN 어댑터 등) 에 할당 된 IP 주소</li>
</ul>
</li>
<li>Gateway
<ul>
<li>다음 라우터의 IP 주소</li>
</ul>
</li>
<li>프로토콜 번호
<ul>
<li>어느 프로토콜을 사용하는지 기입</li>
<li>06(16진수) : TCP</li>
<li>17(16진수) : UCP</li>
<li>미리 약속되어있다</li>
<li>프로토콜 번호 이후의 데이터는 의뢰 받은 곳에서의 데이터로 간주</li>
</ul>
</li>
</ul>
</li>
<li>라우터에서 IP 주소 표를 사용해 다음으로 넘어갈 라우터를 구하듯 프로토콜 스택의 IP 주소 표를 사용</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>4. 이더넷용 MAC 헤더를 만든다</h3>
<ul>
<li>IP 헤더를 만든 후 MAC 헤더를 작성</li>
<li>이더넷에서는 TCP/IP 개념을 사용하지 않음</li>
<li>MAC 주소
<ul>
<li>48 비트</li>
<li>IP 는 네트워크 주소와 호스트 주소를 사용해 ㅇㅇ구ㅇㅇ동 같은 개념인데 반해 MAC 주소는 48 비트가 하나의 값</li>
</ul>
</li>
<li>수신처 MAC 주소
<ul>
<li>패킷을 수신하는 곳의 MAC 주소</li>
<li>최종 목적지가 아닌 패킷을 건네받는 상대의 MAC 주소를 기입</li>
<li>IP 주소표에서 패킷을 중계하는 Gateway IP 주소에 있는 라우터의 MAC 주소를 입력</li>
<li>상대의 MAC 주소는 기입되어있지 않기때문에 IP 주소에서 MAC 주소를 찾아오는 단계가 필요</li>
</ul>
</li>
<li>송신처 MAC 주소
<ul>
<li>패킷을 송신하는 곳의 MAC 주소</li>
<li>LAN 어댑터를 제조할 때 ROM 에 기록되어 있음</li>
</ul>
</li>
<li>이더 타입 (Ether Type)
<ul>
<li>IP 헤더의 프로토콜 번호와 비슷</li>
<li>이더 타입 뒤의 데이터는 IP 헤더와 의뢰받은 데이터로 간주</li>
<li>내용물이 어떤것인지 알려줌</li>
<li>IP 프로토콜, ARP 프로토콜 등 이전 프로토콜을 기입</li>
</ul>
</li>
</ul>
<h3>5. ARP 로 수신처 라우터의 MAC 주소를 조사한다</h3>
<ul>
<li>ARP (Address Resolution Protocol)</li>
<li>IP 주소에서 MAC 주소를 찾아오는 프로토콜</li>
<li>브로드캐스트
<ul>
<li>이더넷에 연결되어있는 전원에게 패킷을 전달하는 방법</li>
</ul>
</li>
<li>브로드캐스트를 사용해 IP 주소를 전원에게 보내고 해당 IP 를 가진 당사자가 MAC 주소를 반환 해 줌</li>
<li>매번 패킷을 보낼 때 마다 ARP 를 사용해 MAC 주소를 받아오면 너무 많은 패킷을 전송하게 됨
<ul>
<li>ARP 캐시를 이용 해 한번 찾아온 MAC 주소를 메모리에 저장해둠</li>
<li>저장해둔 MAC 주소를 계속 사용하면 MAC 주소가 바뀌었을 때 문제가 생김</li>
<li>일정 시간이 지난 뒤 저장 된 ARP 캐시를 지우게 함</li>
</ul>
</li>
</ul>
<h3>6. 이더넷의 기본</h3>
<ul>
<li>MAC 헤더, MAC 주소를 사용해서 기기를 판별</li>
<li>10BASE5 - 이더넷의 원형
<ul>
<li>모든 기기가 케이블로 연결되어있음</li>
<li>트렁크 케이블
<ul>
<li>하나의 메인 케이블</li>
</ul>
</li>
<li>트랜시버 케이블
<ul>
<li>기기에서 트렁크 케이블로 이어지는 케이블</li>
</ul>
</li>
<li>트랜시버
<ul>
<li>트랜시버 케이블과 트렁크 케이블을 잇는 장치</li>
</ul>
</li>
<li>패킷을 모든 기기로 전달하며 기입된 MAC 헤더에 맞게 받을 패킷은 사용하고 본인에게 오지 않은 패킷은 패기</li>
</ul>
</li>
<li>10BASE-T - 리피터 허브를 이용한 파생형
<ul>
<li>리피터 허브
<ul>
<li>스위칭 허브와 구별되는 구형의 증폭기 허브</li>
<li>들어온 신호를 연결된 모든 기기에 전달</li>
</ul>
</li>
<li>트렁크 케이블이 리피터 허브로 변경</li>
<li>원형과 같은 방식으로 작동</li>
</ul>
</li>
<li>스위칭 허브를 이용한 형태
<ul>
<li>전원에게 신호가 전달되는 것이 아닌 목적지로만 신호가 전달</li>
<li>스위칭 허브가 MAC 헤더를 사용해 목적지를 선별</li>
</ul>
</li>
</ul>
<h3>7. IP 패킷을 전기나 빛의 신호로 변환하여 송신한다</h3>
<ul>
<li>패킷은 디지털 데이터이므로 전송가능한 신호로 변환</li>
<li>LAN 어댑터
<ul>
<li>LAN 드라이버 소프트웨어</li>
<li>전원이 공급되면 하드웨어 검사, 초기설정등의 초기화 작업이 진행
<ul>
<li>이더넷의 송수신 동작을 제어하는 MAC 회로에 MAC 주소를 설정하는 과정 포함
<ul>
<li>ROM 에서 MAC 주소를 읽어와 기록해두며 이후 작동시에는 ROM 을 확인하지 않고 이곳을 확인함</li>
</ul>
</li>
</ul>
</li>
<li>ROM
<ul>
<li>전 세계적인 규칙으로 정해진 중복되지 않는 MAC 주소가 기록되어있음</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>8. 패킷에 3개의 제어용 데이터를 추가한다</h3>
<ul>
<li>LAN 드라이버가 프로토콜 스택의 IP 담당으로 부터 패킷을 받으면 MAC 회로가 작업을 함</li>
<li>버퍼 메모리에서 송신할 패킷을 추출</li>
<li>클록
<ul>
<li>비트 구분을 나타내는 신호</li>
<li>일정한 주기로 1과 0이 반복되는 신호</li>
<li>패킷과 같이 보내서 둘을 비교해 패킷의 신호를 변환할 수 있도록 할 수 있다</li>
<li>거리가 멀어 클럭신호와 패킷신호의 시간차가 생기면 사용할 수 없다</li>
</ul>
</li>
<li>패킷에 데이터를 추가로 기록
<ul>
<li>패킷의 맨 앞(MAC 헤더 앞)
<ul>
<li>프리엠블
<ul>
<li>송신하는 패킷을 읽을 타이밍을 잡기 위해 설정</li>
<li>1과 0이 번갈아 나오는 비트열이 56비트 이어짐 (101010…)</li>
<li>패킷 신호와 클럭 신호를 합산해 같이 보내면 신호에서 클럭을 추출한 후 추출한 클럭신호를 사용 해 패킷 신호를 추출할 수 있음</li>
<li>클럭신호를 추출하려면 클럭의 정확한 타이밍이 필요한데 이것을 확인하기 위해 저장한 신호가 프리엠블</li>
</ul>
</li>
<li>스타트 프레임 딜리미터(SFD)
<ul>
<li>패킷의 시작을 알리는 신호</li>
</ul>
</li>
</ul>
</li>
<li>패킷의 맨 뒤(데이터 뒤)
<ul>
<li>프레임 체크 시퀀스(FCS)
<ul>
<li>패킷의 마지막에 붙는 신호</li>
<li>패킷의 시작부터 끝까지의 내용을 오류검사 식을 사용하여 전송된 패킷에 문제가 있었는지 확인
<ul>
<li>Cyclic Redundancy Check: CRC</li>
</ul>
</li>
<li>송신측에서 기록한 FCS 와 수신측에서 계산한 FCS 가 같아야 오류가 없이 전송이 된 것</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>9. 허브를 향해 패킷을 송신한다</h3>
<ul>
<li>패킷에 프리엠블, 스타트 프레임 딜리미터, FCS 를 부가해 패킷을 케이블로 송신할 준비를 끝냄</li>
<li>반 이중 모드 (리피터 허브를 이용했을 때)
<ul>
<li>케이블에 다른 기기가 송신한 신호가 있는지 확인한 다음 신호가 없을때만 전송</li>
<li>MAC 회로가 프리앰블의 맨앞 비트인 1 부터 하나씩 전기 신호로 변환
<ul>
<li>데이터를 신호로 변환하는 속도 = 전송 속도</li>
</ul>
</li>
<li>전기 신호를 PHY 혹은 MAU 라고 불리는 송수신 부분으로 전달
<ul>
<li>Physical Layer Device : 100mb/s 이상의 고속 이더넷을 말함</li>
<li>Medium Attachment Unit</li>
</ul>
</li>
<li>MAC 회로에서 생성된 PHY(MAU)회로로 가는 신호는 실제 전송되는 신호가 무엇인지에 상관없이 통일된 신호로 생성됨</li>
<li>해당 신호를 PHY(MAU)회로에서 실제 전송 시 사용할 신호로 변환</li>
<li>PHY(MAU)회로는 MAC 회로에서 받은 신호를 케이블에 전송하기 전 수신 신호선에서 신호가 들어오고 있는지 확인</li>
<li>송신을 완료하기 전까지 수신 신호선에서 신호가 들어오지 않으면 송수신 동작이 끝남</li>
<li>상대에게 신호가 제대로 갔는지를 확인하지 않음</li>
<li>오류가 발생하면 TCP 에서 검출</li>
<li>충돌
<ul>
<li>우연히 두 기기가 동시에 신호를 보내 송신중 수신 신호선에 신호가 들어오는 것</li>
<li>서로의 신호가 섞여서 분간할 수 없게 됨</li>
<li>송신 동작을 중지한 후 다른 기기들에게 충돌이 일어났음을 알림</li>
<li>재밍 신호
<ul>
<li>충돌이 일어남을 알리는 신호</li>
</ul>
</li>
<li>재밍 신호를 보낸 후 잠시 뒤 다시 송신을 시도함
<ul>
<li>다시 충돌이 나지 않게 하기위해 MAC 주소를 기반으로 난수를 생성하여 대기</li>
</ul>
</li>
<li>이더넷이 혼잡한 경우에는 충돌의 가능성이 높아짐
<ul>
<li>연속해서 충돌이 일어나는 경우 매번 대기시간을 2배로 늘려 다시 송신을 시도</li>
<li>10번째 충돌에서는 오류로 판단</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>전 이중 모드 (스위칭 허브를 이용했을 때)
<ul>
<li>스위칭 허브를 이용해 충돌이 일어나지 않음</li>
<li>충돌이 없으므로 수신 신호선에서 신호가 들어와도 그대로 송신함</li>
</ul>
</li>
</ul>
<h3>10. 돌아온 패킷을 받는다</h3>
<ul>
<li>신호의 맨 앞에있는 프리앰블을 인식해 클럭 타이밍을 알아냄</li>
<li>스타트 프레임 딜리미터가 나오면 이후의 비트를 디지털 데이터로 변환</li>
<li>신호는 PHY(MAU)회로에서 통일된 신호로 바뀌며 MAC 회로에서 디지털 데이터로 변환됨</li>
<li>MAC 회로에서 신호의 앞에서부터 디지털 데이터로 변환해 버퍼 메모리에 저장</li>
<li>신호의 끝에서 FCS 를 검사</li>
<li>FCS 의 문제가 없으면 MAC 헤더의 MAC 주소와 기기의 MAC 주소를 비교하여 본인이 받을 데이터인지를 확인</li>
<li>목적지가 다른 패킷은 파기하고 옳은 패킷만 버퍼메모리에 저장</li>
<li>변환이 끝나면 MAC 회로에서 할일이 끝났음을 컴퓨터에 알림
<ul>
<li>운영체제에 인터럽트를 걸어줌</li>
</ul>
</li>
<li>인터럽트에 의해 LAN 드라이버가 동작해 LAN 어댑터의 버퍼메모리에서 패킷을 추출한 뒤 MAC 헤더의 프로토콜 타입을 확인해 프로토콜 스택의 맞는 프로토콜 담당 부분으로 전달</li>
<li>프로토콜 스택에서 애플리케이션으로 데이터 전달</li>
</ul>
<h3>11. 서버의 응답 패킷을 IP에서 TCP로 넘긴다</h3>
<ul>
<li>LAN 어댑터에서 프로토콜 스택으로 패킷을 넘김</li>
<li>패킷의 타입을 확인해 알맞은 프로토콜의 프로토콜 스택으로 패킷을 넘겨줌</li>
<li>IP 담당 부분은 IP 헤더를 조사하여 포멧에 문제가 없는지 확인
<ul>
<li>본인의 IP 와 IP 헤더에 기입된 IP 가 다르면 오류</li>
<li>오류가 나면 IP 담당 부분이 ICMP 메시지를 사용하여 통신 상대에게 오류를 통지</li>
</ul>
</li>
<li>IP 프로토콜에 의해 분할된 패킷을 원래의 패킷으로 되돌림
<ul>
<li>IP 헤더에 있는 플래그를 확인</li>
<li>패킷이 분할 수신되었으면 분할된 패킷을 IP 담당 부분의 메모리에 임시 저장</li>
<li>ID
<ul>
<li>분할된 패킷은 같은 ID 를 가지고 있음</li>
</ul>
</li>
<li>프래그먼트 오프셋
<ul>
<li>분할된 패킷이 원래 패킷의 어느 위치에 있었는지를 나타냄</li>
</ul>
</li>
<li>리어셈블링
<ul>
<li>분할된 패킷을 원래대로 되돌리는 과정</li>
</ul>
</li>
</ul>
</li>
<li>IP 담당 부분이 패킷을 TCP 담당 부분으로 전달</li>
<li>TCP 헤더를 이용해 담당 소켓을 탐색</li>
<li>소켓에 저장된 데이터를 사용해 수신 과정을 진행</li>
</ul>
<h2>6. UCP 프로토콜을 이용한 송수신 동작</h2>
<h3>1. 수정 송신이 필요없는 데이터의 송신을 UDP가 효율적이다</h3>
<ul>
<li>TCP 는 상대가 데이터를 제대로 받았는지 확인을 하며 통신을 함</li>
<li>한번에 모든 데이터를 보내게 되면 오류가 발생했을 때 모든 패킷을 다시 보내야함</li>
<li>TCP 에서는 데이터를 쪼개서 누락된 데이터만 다시 보내줌</li>
<li>보내야 할 데이터가 패킷 한개로만 충분한 경우에는 TCP 를 사용해도 효율적임</li>
<li>UDP 를 사용하면 짧은 길이의 패킷을 한번만 보내며 상대가 패킷을 받았는지 확인할 필요가 없음</li>
</ul>
<h3>2. 제어용 짧은 데이터</h3>
<ul>
<li>DNS 서버에 대한 조회와 같은 제어를 위해 전송되는 패킷처럼 한개의 패킷으로 처리가 되는 경우에는 UDP 를 사용</li>
<li>TCP 와 같은 수신확인이나 윈도우가 존재하지 않아 송수신 이전의 접속단계나 연결끊기 단계가 필요없음</li>
<li>애플리케이션에서 송신의뢰를 받으면 UDP 헤더를 부가해 송신함</li>
<li>송신 또한 IP 헤더와 UDP 헤더, 송수신측의 포트번호를 확인해 소켓을 사용하여 데이터를 받고 애플리케이션으로 전달함</li>
<li>TCP 처럼 오류확인을 해주지 않지만 애플리케이션에서 데이터의 누락을 확인하고 다시 데이터를 보내면 됨</li>
</ul>
<h3>3. 음성 및 영상 데이터</h3>
<ul>
<li>음성이나 영상 데이터는 정해진 시간내에 데이터를 전송해야할 필요가 있음</li>
<li>누락 없는 통신보단 속도가 중요함</li>
<li>음성이나 영상은 데이터가 다소 누락되더라도 큰 문제가 발생하지 않음</li>
<li>안정성보다 시간이 중요한 이런경우도 UDP 를 사용</li>
</ul>

        </article>
        
    </main>

        <footer>
        <p>Generated by SuGo</p>
    </footer>

</body>
</html>


