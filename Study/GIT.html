<!DOCTYPE html>



<html>

<head>
    <meta charset="UTF-8">
    <title>GIT</title>
    <link rel="icon" href="https://biisairo.github.io/static/favicon.ico" type="image/x-icon">
</head>

<script>
    function toggleSection(id) {
        const section = document.getElementById(id);
        const header = section.previousElementSibling;

        if (section.style.display === 'none') {
            section.style.display = 'block';
            header.innerHTML = header.innerHTML.replace('▶', '▼');
        } else {
            section.style.display = 'none';
            header.innerHTML = header.innerHTML.replace('▼', '▶');
        }
    }
</script>

<body>
    <header>
    <nav>
        <ul>
            

            <li><a href="https://biisairo.github.io/">Home</a></li>
            
            <li><a href="https://biisairo.github.io/About/">About</a></li>
            
            <li><a href="https://biisairo.github.io/Study/">Study</a></li>
            
            <li><a href="https://biisairo.github.io/Contact/">Contact</a></li>
            
        </ul>
    </nav>

    <style>
     
    html,
    body {
        height: 100%;
        margin: 0;
    }

    body {
        display: flex;
        flex-direction: column;
        max-width: 720px;
        margin: 0 auto;
        padding: 2rem 1rem;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
            Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        line-height: 1.6;
        background: #222831;
        color: #EEEEEE;
    }

    header,
    footer {
        text-align: center;
        margin-bottom: 2rem;
    }

    nav ul {
        list-style: none;
        padding: 0;
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
         
        flex-wrap: wrap;
        gap: 1rem;
    }

    nav li:first-child {
        margin-right: auto;
         
    }

    nav li:not(:first-child) {
        margin-left: 0;
    }

    nav li:first-child a {
        color: #EEEEEE;
        font-size: 1.5em;
        text-decoration: none;
         
    }

    nav li:first-child a:hover {
        color: #aadadf;
         
    }

    nav a {
        color: #00ADB5;
        text-decoration: underline;
        transition: color 0.3s ease;
    }

    nav a:hover {
        color: #66C1C9;
        text-decoration: none;
    }

    main a,
    article a,
    footer a {
        color: #33d3c8;
        text-decoration: underline;
        transition: color 0.3s ease;
    }

    main a:hover,
    article a:hover,
    footer a:hover {
        color: #66C1C9;
        text-decoration: none;
    }

     
    main {
        flex: 1;
        margin-bottom: 2rem;
    }

    h1,
    h2,
    h3 {
        line-height: 1.3;
        margin-top: 2rem;
        margin-bottom: 1rem;
        color: #00ADB5;
    }

    h2[onclick] {
        user-select: none;
    }


    ul {
        padding-left: 1.5rem;
    }

    article {
        margin-top: 2rem;
        border: 1px solid #33d3c8;
        padding: 1rem;
        border-radius: 5px;
    }

    footer p {
        font-size: 0.9rem;
        color: #AAAAAA;
    }
</style>

</header>

    <main>
        
        
        <h2 onclick="toggleSection('groups')" style="cursor: pointer;">▶ 하위 그룹</h2>
        <div id="groups" style="display: none;">
            <ul>
                
                <li><a href="https://biisairo.github.io/Study/Language/">Language</a></li>
                
                <li><a href="https://biisairo.github.io/Study/%eb%a6%ac%ec%96%bc%ec%9b%94%eb%93%9c%20HTTP/">리얼월드 HTTP</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Server/">Server</a></li>
                
                <li><a href="https://biisairo.github.io/Study/UNIX/">UNIX</a></li>
                
                <li><a href="https://biisairo.github.io/Study/VIM/">VIM</a></li>
                
                <li><a href="https://biisairo.github.io/Study/computer%20science/">computer science</a></li>
                
                <li><a href="https://biisairo.github.io/Study/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/">운영체제</a></li>
                
                <li><a href="https://biisairo.github.io/Study/%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac/">네트워크</a></li>
                
                <li><a href="https://biisairo.github.io/Study/OpenGL/">OpenGL</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Object%20Oriented%20Programming/">Object Oriented Programming</a></li>
                
                <li><a href="https://biisairo.github.io/Study/%ec%b1%85/">책</a></li>
                
                <li><a href="https://biisairo.github.io/Study/42/">42</a></li>
                
            </ul>
        </div>
        
        

        
        <h2 onclick="toggleSection('pages')" style="cursor: pointer;">▶ 하위 페이지</h2>
        <div id="pages" style="display: none;">
            <ul>
                
                <li><a href="https://biisairo.github.io/Study/GIT.html">GIT</a></li>
                
                <li><a href="https://biisairo.github.io/Study/ASM.html">ASM</a></li>
                
                <li><a href="https://biisairo.github.io/Study/cmake.html">cmake</a></li>
                
                <li><a href="https://biisairo.github.io/Study/%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98.html">알고리즘</a></li>
                
            </ul>
        </div>
        

        
        
        <article>
            <h1>GIT</h1>
<table>
<thead>
<tr>
<th>구분</th>
<th>명령어</th>
</tr>
</thead>
<tbody>
<tr>
<td>개념</td>
<td>HEAD, 사용자 설정, help, hunk, hook</td>
</tr>
<tr>
<td>파일 관리</td>
<td>.gitignore</td>
</tr>
<tr>
<td>명령어</td>
<td></td>
</tr>
<tr>
<td>시작</td>
<td>init, clone, submodule</td>
</tr>
<tr>
<td>작업공간, 인덱스 조작</td>
<td>add, rm, mv, restore, stash, clean</td>
</tr>
<tr>
<td>상태보기</td>
<td>status, diff, config, log, reflog, tag, show, blame, bisect</td>
</tr>
<tr>
<td>커밋의 조작</td>
<td>commit, branch, checkout, switch, reset, revert, merge, rebase, cherry-pick</td>
</tr>
<tr>
<td>협업</td>
<td>remote, push, pull, fetch</td>
</tr>
<tr>
<td>github</td>
<td>page, ssh, gpg, action</td>
</tr>
</tbody>
</table>
<p>HEAD</p>
<ul>
<li>브랜치의 가장 최근 커밋을 가르킨다</li>
<li>checkout 으로 커밋을 이동 할 때에는 이름 미정의 임시 브랜치가 생성되는걸로 간주할 수 있다</li>
<li>헤드를 움직여 원하는 지점에서 브랜치를 분기할 수 있다</li>
</ul>
<p>.gitignore</p>
<ul>
<li>git 에 포함되면 안되는 파일의 리스트</li>
<li>.gitignore 라는 이름의 파일을 만든 뒤 해당 파일에 git 에 포함하면 안되는 파일의 이름을 넣는다</li>
</ul>
<p>사용자 설정</p>
<ul>
<li>github 설정과 별개</li>
<li>git config –global user.name <name>
<ul>
<li>사용자 이름 설정</li>
</ul>
</li>
<li>git config –global user.email <email>
<ul>
<li>이메일 설정</li>
</ul>
</li>
</ul>
<p>hunk</p>
<ul>
<li>변경사항 하나하나의 단위</li>
</ul>
<p>hook</p>
<ul>
<li>shell script 같은 git 스크립트</li>
<li>.git/hooks 에 예시로 나온 hook 들이 있으며 .sample 를 지우면 실행파일이 된다</li>
<li>gitmoji 등에서 사용한다</li>
</ul>
<p>git submodule</p>
<ul>
<li>git submodule add <path> : 현재 프로젝트의 path 의 프로젝트가 서브모듈로 생성된다</li>
<li>프로젝트 안에 프로젝트가 들어있어 모든 프로젝트가 깃으로 관리되며 서브 프로젝트와 메인프로젝트의 버전을 별개로 관리하고싶은 경우 사용한다</li>
<li>메인 프로젝트의 git 은 서브모듈의 git 에는 직접적으로 관여하지 않는다</li>
<li>메인의 깃은 서브모듈내부는 관여하지 않지만 서브모듈의 변경사항은 확인하고 저장된다</li>
<li>메인 프로젝트를 클론하면 서브모듈은 받아와지지 않는다</li>
<li>git submodule init
<ul>
<li>안에있는 모든 서브모듈을 연결한다</li>
<li>git submodule init <submodule name> : 해당 서브모듈만 가져온다</li>
</ul>
</li>
<li>git submodule update : 서브모듈을 가져온다, 처음 init 후 사용한다
<ul>
<li>-remote : 서브모듈의 수정사항을 가져온다</li>
<li>-recursive : 서브모듈 안에 서브모듈이 중첩으로 존재할 경우 사용</li>
</ul>
</li>
</ul>
<p>git config</p>
<ul>
<li>-global : 이 컴퓨터 전역에 해당하는 설정</li>
<li>-local : 해당 프로젝트, 해당 깃 폴더 안에서만 적용되는 설정</li>
<li>local 과 global 옵션은 아래 나올 옵션들에 적용시켜 범위를 제한 할 수 있다, 범위를 적용하지 않으면 모든 설정이 나온다</li>
<li>-list : 설정 된 모든 설정값 보기</li>
<li>e : 설정 편집, vim 으로 실행됨
<ul>
<li>git config –global core.editor “code –wait” : vsc 로 열기</li>
<li>이 설정을 하면 이후 커밋메세지 등 편집창 또한 에디터로 열림</li>
<li>다른 에디터의 경우 code 대신 해당 편집기 exe 파일의 경로 적기</li>
<li>-wait : 편집이 실행되는 동안 터미널 일시정지</li>
</ul>
</li>
<li>-get <something>
<ul>
<li>something 의 정보 가져오기</li>
<li>ex) user.name…</li>
</ul>
</li>
<li>유용한 설정
<ul>
<li>-global core.autocrlf input(윈도우의 경우 true) : 줄바꿈 문제 해결</li>
<li>-pull.rebase false/ture : pull 의 기본전략을 rebase 또는 merge 로 설정</li>
<li>-global init.defaultBranch main : 기본 브랜치으 이름은 main 으로 설정</li>
<li>-global push.default current : push 할때 push -u 할 필요 없이 무조건 동일한 브랜치 명으로 push 되도록</li>
<li>단축키 설정
<ul>
<li>-global alias.(단축어) “명령어” : 명령어를 단축어로만 써도 되도록… commit 을 co 로 만들던가 등등</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>git help</p>
<ul>
<li>git help : 도움 페이지 보기</li>
<li>git help -a : 모든 명령어 보기</li>
<li>git help -w <command> : 해당 커맨드 웹에서 doc 보기</li>
<li>git help <command>, git command –help : 해당 커맨드 help 페이지 보기</li>
<li>git <command> -h : 해당 커맨드 옵션 간단히 보기</li>
</ul>
<p>git init</p>
<ul>
<li>해당 디렉토리를 깃으로 관리하고자할때 사용</li>
<li>깃으로 버전관리를 하기 전 필수</li>
</ul>
<p>git add <filename></p>
<ul>
<li>status 에 해당 파일 추가</li>
<li>다음 커밋 명령어가 적용 될 파일들</li>
<li>p : add 를 hunk 단위로 스테이징할 수 있다
<ul>
<li>? 를 누르면 옵션들의 설명을 들을 수 있다</li>
<li>한 파일 내에서도 변경사항 하나하나를 add 할 수 있다</li>
</ul>
</li>
</ul>
<p>git status</p>
<ul>
<li>디렉토리에 들어있는 파일들의 상태 확인</li>
<li>수정이 되었거나 새로 생겨 status 에 올라가지 않았거나 add 로 status 에 올라갔는지 확인</li>
</ul>
<p>git commit</p>
<ul>
<li>커밋</li>
<li>후에 나오는 vim 에서 코맨트 추가</li>
<li>m “commit message” : vim 으로 가지 않고 바로 커밋 메세지 작성</li>
<li>a : tracked 되고있는 파일이 있으면 이번 작업에서 add 되지 않았더라도 자동으로 add 후 커밋</li>
<li>-amend : 현재 커밋이면서 브랜치의 마지막 끝에 있는 커밋을 수정, 평소의 커밋과 같이 진행 후 –amend 옵션을 붙여주기만 하면 된다</li>
<li>v : 커밋 될 항목들의 변경사항을 확인 후 커밋한다, 커밋메세지를 적는 창에서 내려보면 변경사항을 볼 수 있다, 커밋과 diff 를 사용한다고 보면 된다</li>
</ul>
<p>git log</p>
<ul>
<li>현재 브랜치의 지금까지 커밋 된 기록들을 확인</li>
<li>p : 커밋 된 소스들 간의 차이점을 확인할 수 있다</li>
<li>git log <commit id> : 해당 커밋의 로그 확인</li>
<li>git log <filename> : 해당 파일이 변경된 커밋만 보기</li>
<li><n> : n 개의 로그 보기</li>
<li>-reverce : log 를 거꾸로 보여준다</li>
<li>-branched : 모든 브랜치에서의 커밋 된 기록들을 확인</li>
<li>-all : 모든 커밋 기록을 다 보여준다</li>
<li>-decorate : 태그, 색 등 보기쉽게 꾸며줌, 해당 커밋이 어떤 브랜치에서 왔는지 확인이 가능함</li>
<li>-graph : 화면 왼쪽에 그래프를 보여줌</li>
<li>-oneline : 한줄로, 모든 현황을 한줄씩 간결하게 보여줌</li>
<li>-stat : 커밋의 통계(변화목록) 보기</li>
<li>-shortstat : stat 의 간소화</li>
<li>-grep &lt;검색&gt; : 커밋메세지에서 검색</li>
<li>S &lt;검색&gt; : 커밋 변경내용을 검색한다</li>
<li>git log <branch1>..<branch2> : 브랜치 1 에는 없고 브랜치 2 에는 있는것을 보여줌, -p 와 결합 시 이 차이점을 소스코드수준에서 알 수 있음</li>
</ul>
<p>git diff</p>
<ul>
<li>
<p>최근 커밋과 working directory 의 차이를 보여준다</p>
</li>
<li>
<p>add 를 하면 보이지 않는다, 즉 stage 에 올라오지 않은 파일의 수정내용을 보여준다</p>
</li>
<li>
<p>-stage, –cash : 스테이지 되어있는 변경된 파일들을 보여준다</p>
</li>
<li>
<p>git diff</p>
<p>: 두 커밋의 차이를 보여준다</p>
</li>
<li>
<p>git diff <branch1> <branch2> : 두 브랜치의 차이점을 자세히 보여준다</p>
</li>
<li>
<p>-name-only : 변경점이 있는 파일의 목록만 보여준다</p>
</li>
</ul>
<p>git branch</p>
<ul>
<li>존재하는 브랜치 확인, 및 작업중인 브랜치 확인</li>
<li>git branch <branch name> : branch name 이라는 이름의 브랜치를 만든다</li>
<li>git branck <branch1> <branch2> : branch1 의 헤드를 branch2 로 옮긴다</li>
<li>브랜치를 생성하면 속해있는 브랜치의 상태를 그대로 복사하게된다</li>
<li>d <branch name> : 해당 브랜치를 지운다</li>
<li>D <branch name> : 해당 브랜치를 질문없이 강제로 지운다</li>
<li>m <original> <modify> : original 브랜치를 modify 로 이름을 바꾼다</li>
<li>-all, -a : 원격 브랜치를 포함한 모든 브랜치를 볼 수 있다</li>
<li>f : 해당 명령어를 강제실행한다</li>
</ul>
<p>git checkout</p>
<ul>
<li>git chechout <branch name></li>
<li>branch name 브랜치로 이동</li>
<li>git checkout HEAD^ : 헤드가 한단계 전의 커밋을 가리킨다</li>
<li>git checkout HEAD~n : 헤드가 n 단계 전의 커밋을 가리킨다</li>
<li>git checkout <tag name> : 헤드가 해당 태그를 가리킨다</li>
<li>git chackout - : checkout 을 한단계 뒤로 돌린다, ctrl+z 같은 느낌</li>
<li>b : 해당 브랜치를 만들고 그 브랜치로 이동한다, git branch 와 git checkout 을 동시에 진행하는 형태</li>
<li>branch name 에 commit id 를 넣으면 해당 커밋으로 바로 이동할 수 있다
<ul>
<li>이렇게 하면 HEAD 가 특정 branch 에 있는게 아니라 HEAD 가 직접 해당 커밋을 가리키게 된다</li>
<li>하나의 이름미정의 브랜치를 만들어 그곳에 있게되는 원리</li>
<li>HEAD 기본적으로 브랜치의 최종 커밋을 가리킨다</li>
<li>해당 커밋을 확인하고 돌아올 때 유용</li>
<li>원래 브랜치로 체크아웃 해서 돌아가기</li>
</ul>
</li>
<li>t origin/<branch name> : origin 이라는 원격 저장소에서 branch name 의 이름을 가진 브랜치를 복사에서 로컬에 생성한 뒤 로컬과 원격의 두 브랜치를 연결한다 (push -u 와 비슷하다)</li>
<li>git chechout origin/<branch name> : 와 같은 방법으로 원격저장소의 브랜치로 갈 수 있다
<ul>
<li>이 이전에 git fetch 를 해 주어야 원격의 변경사항이 반영이 된다</li>
</ul>
</li>
</ul>
<p>git switch</p>
<ul>
<li>git switch <branch name></li>
<li>해당 브랜치로 이동</li>
<li>c : 생성과 동시에 이동, checkout 의 -b 와 같은 기능</li>
<li>git 2.23 ver 이후에 chechout 의 기능이 세분화 되면서 브랜치를 이동하는 명령어가 따로 만들어짐</li>
<li>chechout 과 switch 둘다 사용 가능</li>
<li>t : chechout 과 동일</li>
</ul>
<p>git reset</p>
<ul>
<li>git reset <commit id> : 해당 아이디의 커밋을 최신 커밋으로 만든다</li>
<li>git reset HEAD^ : 바로 전의 커밋으로 돌아간다</li>
<li>git reset HEAD~n : n 개 전의 커밋으로 돌아간다</li>
<li>-hard : working copy, index, repository 전부를 초기화한다</li>
<li>-mixed : index, repository 를 초기화한다</li>
<li>-soft : repository 만 초기화한다</li>
<li>옵션을 생략하고 리셋을 하게 되면 mixed 옵션을 사용하게 된다</li>
<li>commit id 를 생략하게 되면 현재의 커밋 상태로 리셋하게 된다</li>
<li>뒤에 커밋 된 커밋들은 보이지 않게된다, 복구가 가능하다</li>
<li>github 에 올린 후에는 리셋을 하면 안된다</li>
<li>commit id 에 ORIG_HEAD 를 넣게되면 ORIG_HEAD 의 상태로 리셋을 취소하게된다
<ul>
<li>ORIG_HEAD 에는 리셋 이전단계의 커밋의 상태가 담겨있다</li>
</ul>
</li>
</ul>
<p>git revert</p>
<ul>
<li>git revert <commit id> : 해당 커밋의 변화를 취소한다</li>
<li>git revert HEAD : 바로 이전 커밋의 변화만 되돌린다</li>
<li>git revert HEAD~n : n 개의 커밋이 순서대로 revert 된다</li>
<li>git revert <commit id1> <commit id2> : 여러개 커밋의 변화를 취소한다, 각각의 커밋이 생성된다</li>
<li>git revert <commit id1>..<commit id2> : 속한 범위의 커밋을 전부 revert 한다</li>
<li>n, –no-commit : revert 할 내용이 index 에 반영이 된 뒤 커밋은 되지 않는다, reverting 상태가 된다
<ul>
<li>추가 변경을 마친 후 git revert –continue 로 커밋을 진행한다</li>
</ul>
</li>
<li>reset 과 다르게 이전의 커밋을들 없애는게 아닌 돌아갈 커밋의 변화만 취소하게 된다
<ul>
<li>이런 이유로 reset 처럼 해당 커밋으로 상태를 되돌리려면 해당 커밋까지의 모든 커밋을 revert 해 주어야한다</li>
</ul>
</li>
<li>파일의 삭제, 생성 등의 경우 revert 가 끝나지 않고 충돌날 수 있다, 이때 충돌을 해결한 다음 git revert –continue 를 해주면 된다
<ul>
<li>해당 revert 를 취소하고싶을때는 git reset –hard 를 해 주면 된다</li>
</ul>
</li>
<li>이는 여러 사람과 작업할 때 브랜치가 꼬이지 않게 도와준다</li>
</ul>
<p>git reflog</p>
<ul>
<li>log 분이 아닌 git 을 이용한 모든 활동을 기록한다</li>
<li>logs/refs 에 있는 log 들을 볼 수 있다</li>
<li>로그들을 활용해 reset 을 사용할 수 있다</li>
</ul>
<p>git merge</p>
<ul>
<li>git merge <branch></li>
<li>브랜치가 남아있고 브랜치의 변화를 메인가지에 적용시켜 새로 커밋한다</li>
<li>브랜치의 내역이 남아있게된다</li>
<li>합쳐서 남겨질, 메인이 되는 브랜치로 체크아웃을 한다음 사용
<ul>
<li>가지를 휘도록 당겨온다고 생각하기</li>
</ul>
</li>
<li>ex)메인 브랜치로 브랜치 A 를 가져온다고 하면 git merge A 를 해준다</li>
<li>merge 후 브랜치를 지워준다</li>
<li>-no-ff : fastforward merge 를 할 수 있는 상황에서 fastforward 를 하지않는 옵션</li>
<li>git merge –abort : 병합 도중 충돌이 났을 때, 병합을 중단하고 싶은 경우 사용한다</li>
<li>-squash <branch>
<ul>
<li>다른 브랜치의 커밋들을 rebase 처럼 각각 가져오는게 아닌 하나의 커밋으로 만들어 main 에 커밋하는 방법</li>
<li>명령어를 실행하면 main 의 맨 앞에 스테이징되며, commit 명령어로 커밋해야한다</li>
</ul>
</li>
</ul>
<p>merge conflict 해결하기</p>
<ul>
<li>merge 하려는 파일이 다르면 문제없이 병합된다</li>
<li>수정된 파일의 이름이 같지만 수정한 위치가 다르다면 git 이 스스로 두 파일의 차이점을 확인하고 합쳐준다</li>
<li>수정된 파일이 같으면서 수정된 부분이 같다면 git 이 수정된 부분을 스스로 해결하지 못하고 충돌을 내게 된다</li>
<li>이 경우 병합이 진행되지 않고 git 은 충돌이 일어난 파일을 수정할것을 요구한다
<ul>
<li>&lt;&lt;&lt;&lt;&lt; HEAD</li>
<li>합쳐지는 브랜치에서의 충돌이 난 부분의 내용</li>
<li>=========</li>
<li>합침당하는 브랜치에서의 충돌이 난 부분의 내용</li>
<li>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<branch name>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
</li>
<li>해당부분을 통채로 충돌이 나지 않게끔 수정한 뒤 &lt;&lt;HEAD, === &gt;&gt;&gt;, branch 부분은 지운다</li>
<li>수정이 끝난 충돌이 난 파일을 add 해준 다음 commit 을 해주면 병합이 제대로 진행되게 된다</li>
</ul>
<p>git rebase</p>
<ul>
<li>git rebase <main></li>
<li>merge 와는 반대로 옮김당하는 브랜치로 checkout 을 한 뒤 사용
<ul>
<li>가지를 잘라 움직여 이어붙인다고 생각하기</li>
</ul>
</li>
<li>브랜치의 변경내용이 메인 가지의 뒤에 옮겨 붙는다</li>
<li>메인 브랜치의 헤드가 원래 위치에 그대로 있고 그 앞으로 붙여진 브랜치가 가게된다
<ul>
<li>main 으로 체크아웃 한다음 git merge <branch name> 으로 해결 해 준다</li>
</ul>
</li>
<li>rebase 후 브랜치를 지워준다</li>
<li>git rebase –abort : 병합 도중 충돌이 났을 때, 병합을 중단하고 싶은 경우 사용한다</li>
<li>i &lt;수정할 대상의 이전의 커밋&gt; : 과거의 커밋 수정하기
<ul>
<li>옵션으로 넣은 커밋 다음의 커밋부터의 수정이 가능하다</li>
<li>에디터의 pick 를 원하는 수정 명령어로 변경하고 해당 수정을 실행한다</li>
<li>edit 후에는 git rebase –continue 로 진행해준다</li>
</ul>
</li>
<li>-onto &lt;목적지 branch&gt; &lt;출발 branch&gt; &lt;이동할 branch&gt;
<ul>
<li>가지의 잔가지를 줄기에 가져오는 방법</li>
<li>main 에서 분기된 출발브런치에서 한번 더 분기된 이동할 브랜치가 있다</li>
<li>그냥 이동할 브랜치를 rebase 하면 출발 브랜치까지 리베이스가 된다</li>
<li>이때 두번 분기된 이돌할 브랜치를 main, 목적지 브랜치에 리베이스를 하는법이다</li>
</ul>
</li>
</ul>
<p>rebase conflict 해결하기</p>
<ul>
<li>각각의 커밋이 충돌이 있으면 각각의 충돌과정을 해결해야 한다</li>
<li>각각의 충돌에서 충돌 된 파일을 수정 해 준다음 git rebase –continue 도 진행한다</li>
<li>모든 충돌이 해결될 때 까지 반복한다</li>
</ul>
<p>git stash</p>
<ul>
<li>git stash, git stash save (save 의 생략)</li>
<li>감추다, 숨겨두다 라는 뜻</li>
<li>브랜치에서의 작업중인 작업을 커밋 없이 감춰서 저장해 두는 기능</li>
<li>작업중인 상황을 커밋 하지않고 다른 브랜치로 이동하면 이동한 브랜치에 영향을 끼칠 수 있기때문에 이같은 경우에 사용</li>
<li>stash 를 하고나면 수정한 사항들이 사라지고 최근 커밋의 상태로 돌아가게된다</li>
<li>stash 의 저장은 stack 방식으로 저장되고 꺼내어진다</li>
<li>git stash list : 저장해 놓은 stash 들을 확인한다, 위에 있는 것일수록 최근에 stash 한것이다</li>
<li>git stash apply : stash 로 저장한 내용을 불러온다 (peek 방식)</li>
<li>git stash drop : 가장 위에있는 stash 를 삭제한다</li>
<li>git stash pop : 가장 위에있는 stash 를 적용한 뒤 삭제한다 (pop 방식)
<ul>
<li>git stash branch <branch name> : 스케시를 불러올 때 현재 작업과 충돌이 날 수 있는 경우 새로운 브랜치를 만들어 불러온다</li>
</ul>
</li>
<li>apply, pop, drop 은 stash@{num} 을 붙이고 num 에 원하는 stash 의 넘버를 넣으면 해당 stash 를 불러온다</li>
<li>stash 는 tracked 되고있는 파일에 대해서만 적용된다</li>
<li>p : add -p 처럼 원하는 변경사항만 stash 할 수 있다</li>
<li>m ‘message’ : stash 에 메세지 넣기</li>
</ul>
<p>git rm</p>
<ul>
<li>git rm <filename></li>
<li>filename 에 해당하는 파일을 working directory 와 index 양쪽에서 모두 지운다</li>
</ul>
<p>git mv</p>
<ul>
<li>git mv <oldname> ㄷ;</li>
<li>oldname 에 해당하는 파일의 이름을 newname 에 적용한 뒤 index 에 올린다</li>
</ul>
<p>git restore</p>
<ul>
<li>git restore <filename></li>
<li>해당 파일의 상태를 현재 커밋의 상태로 돌리면서 index 에서도 삭제한다, 해당 파일데 대해서만 hard reset 한것과 같은 효과</li>
<li>git restore –staged <filename> : index 에 올라가있는 파일을 index 에서만 지운다</li>
<li>git restore –source=<commit id> <filename> : 해당 파일을 특정 커밋의 상태로 가져온다, working area 로만 가져온다</li>
</ul>
<p>git clean</p>
<ul>
<li>추적하지 않는 파일 삭제, .gitignore 에 있는 파일은 삭제하지 않음</li>
<li>n :명령어 실행 시 삭제당할 파일들을 보여줌, 삭제되지 않음</li>
<li>i : 인터렉티브 모드, 상세 선택을 할 수 있는 모드로 들어감</li>
<li>d : 파일뿐이 아닌 폴더도 삭제</li>
<li>f : 강제삭제</li>
<li>.gitignore 에 있는 파일들도 삭제하기</li>
</ul>
<p>git tag</p>
<ul>
<li>lightweight : 단순히 특정 커밋을 가리키는 용도
<ul>
<li>git tag <tag name></li>
</ul>
</li>
<li>annotated : 작성자 정보, 날짜, 메시지, GPG, 서명 포함
<ul>
<li>git tag -a <tag name> : 이후 메세지 작성</li>
<li>git tag -m <tag name> ‘message’</li>
</ul>
</li>
<li>git tag <tag name> <commit id> : 특정 커밋에 태그달기, 옵션은 위와 같이</li>
<li>git tag : 현존하는 태그들 확인
<ul>
<li>l ‘name’ : name 으로 필터링하기, 와일드카드 사용 가능</li>
</ul>
</li>
<li>git tag -d <tag name> : 해당 태그 삭제</li>
<li>특정 시점을 키워드로 적용하고 싶을때 사용</li>
<li>버전명 같은걸 적어둔다</li>
<li>체크아웃 시 태그이름을 적어 체크아웃 할 수 있다</li>
<li>원격에 태그를 올리고 내릴 수 있다
<ul>
<li>git push origin <tag name> : 원격에 태그 올리기</li>
<li>git push –delete origin <tag name> : 원격에서 태그 지우기</li>
<li>git push –tags : 모든 태그 올리기</li>
</ul>
</li>
</ul>
<p>git show</p>
<ul>
<li>git show <tag name> : 해당 태그의 내용 확인</li>
</ul>
<p>git cherry-pick</p>
<ul>
<li>git cherry-pick <commit id> <commit id> … &lt;여러개&gt;</li>
<li>현재 브랜치에 해당 커밋을 그래도 복제해서 가져와 붙인다</li>
<li>원래의 커밋과 새로 가져온 커밋은 별개의 커밋이 된다</li>
</ul>
<p>git blame</p>
<ul>
<li>git blame <filename> :파일의 각 라인을 누가 수정했는지 보여준다</li>
<li>git blame -L &lt;시작줄&gt;, &lt;끝줄 or +줄수&gt; <filename> : 시작줄부터 끝줄까지, 혹은 줄수만큼 수정한 사람을 보여준다</li>
</ul>
<p>git bisect</p>
<ul>
<li>이진탐색법으로 현재 커밋과 예상커밋을 양끝으로 오류가나는 커밋을 검색한다</li>
<li>git bisect start : 이진탐색 시작</li>
<li>시작지점이 에러가 나는 상황이므로 git bisect bad 로 표시</li>
<li>git checkout <commit id> 로 의심되는 커밋으로 이동</li>
<li>이후부터 git bisect bad, git bisect good 를 표시 해 주며 원인을 찾을때 까지 반복</li>
<li>오류지점을 찾은 후 git bisect reset 으로 종료</li>
</ul>
<hr>
<p>원격저장소</p>
<ul>
<li>push 가 된 커밋은 수정하지 않기
<ul>
<li>-amend, reset 등 이전의 커밋이 수정되는 명령어를 사용하면 안된다</li>
<li>revert 처럼 새로운 커밋을 만들어 push 하는 방식으로 진행해야한다</li>
</ul>
</li>
</ul>
<p>git clone <path></p>
<ul>
<li>원격저장소에서 프로젝트를 받아온다</li>
</ul>
<p>git remote add origin <path></p>
<ul>
<li>현재 저장소에 원격 저장소를 추가한다</li>
<li>그 저장소의 경로는 <path> 이고 이 경로의 별명은 origin 이다</li>
<li>여러 원격 저장소를 등록시켜 각각의 저장소에 push 할 수 있다</li>
<li>일반적으로 이름은 origin 으로 짓는다</li>
</ul>
<p>git remote</p>
<ul>
<li>원격 저장소의 경로를 보여준다</li>
<li>v : 상세보기</li>
<li>git remote remove origin
<ul>
<li>origin 원격 저장소를 삭제한다</li>
</ul>
</li>
</ul>
<p>git push</p>
<ul>
<li>로컬을 원격으로 업로드 한다</li>
<li>git push origin <branch> : 현재의 커밋을 원격 저장소 origin 의 branch 이름의 브랜치에 저장한다</li>
<li>u : 로컬 저장소의 브랜치와 원격 저장소의 브랜치를 연결시킨다, 해당 옵션을 사용한 다음에는 새로운 브랜치가 생기기 전까지는 push 뒤에 경로를 붙일 필요가 없다</li>
<li>branch 를 생략하면 현재의 브랜치와 같은 이름의 브랜치에 저장한다, 이 과정을 위에 -u 가 도와준다, 추가로 이는 git global 에서 다시 설정할 수 있다</li>
<li>f, –force : 원격 저장소에 문제가 있거나 하는 이유로 로컬의 상태로 강제로 맞춰야 할 이유가 있을때 강제로 푸쉬하는방법</li>
<li>push origin –delete <branch name> : 원격에 있는 브랜치 지우기</li>
</ul>
<p>git pull</p>
<ul>
<li>원격저장소에 있는 내용을 로컬 저장소로 가져와 merge 또는 rebase 로 합친다</li>
<li>로컬 저장소와 원격 저장소 양쪽에 새로운 커밋이 있을 경우에는 그냥 push 를 하면 push 가 되지 않는데 이때는 먼저 pull 을 해 주어야 한다</li>
<li>이때의 모습은 양쪽이 하나의 부모를 두고 다른 작업을 커밋 한 브랜치를 합치는 것과 같은 모습으로 이루어 진다</li>
<li>merge 방식
<ul>
<li>git pull –no-rebase</li>
</ul>
</li>
<li>rebase 방식
<ul>
<li>git pull –rebase</li>
<li>이 후 다시 push 해준다</li>
</ul>
</li>
<li>위 pull 과정 중 충돌이 일어날 경우 각각 과정에 맞는 충돌 해결 방식을 사용하면 된다
<ul>
<li>git add .</li>
<li>git commit / git rebase –continue</li>
</ul>
</li>
</ul>
<p>branch</p>
<ul>
<li>로컬에서 새로운 브랜치를 만든 후</li>
<li>git push -u origin <new branch> 로 양쪽 브랜치를 연결시켜 준다</li>
<li>원격 저장소에 가보면 새로운 브랜치가 생성되어있다</li>
</ul>
<p>git fetch</p>
<ul>
<li>원격저장소에 있는 내용을 로컬 저장소로 가져와 확인한다</li>
<li>가상의 브랜치를 가져와 저장 한 후 해당 커밋을 확인하게 된다</li>
<li>pull 또한 fetch 를 한 후 변경사항이 있으면 merge 또는 rebase 를 하게 된다</li>
<li>git fetch 를 한 후 git checkout origin/main 을 하면 오리진의 변경 사항을 확인할 수 있다</li>
</ul>
<p>github page</p>
<ul>
<li>계정 별 무료 정적 웹페이지 호스팅</li>
<li>new reop 를 만든 후, 이름을 ‘계정이름.github.io’ 로 생성</li>
<li>최상위 폴더에 index.html 생성</li>
<li>push 후 계정이름.github.io 로 들어가서 확인</li>
</ul>
<p>ssh</p>
<ul>
<li>ssh 인증을 통한 github 로그인</li>
<li>한번 해두면 github 을 이용하는것이 간편해지기 때문에 해두면 좋다</li>
<li>내 컴퓨터에서 ssh 키 생성</li>
<li>settings - ssh and gpg keys 에서 ssh public key 등록</li>
</ul>
<p>gpg</p>
<ul>
<li>push 가 아닌 github 내부에서 수정을 하면 verified 가 붙게된다</li>
<li>로컬에서 작업하여 push 한 경우에도 gpg 키를 등록하면 verified 가 붙는다</li>
<li>필수사항은 아니다</li>
<li>컴퓨터에 gpg 툴을 설치한뒤 gpg key 를 생성한다</li>
<li>해당 gpg key 를 github 에 등록한다</li>
<li>커밋을 할 경우 -S 옵션을, 태그를 달 경우 -s 옵션을 추가하여 작업한다</li>
</ul>
<p>git action</p>
<ul>
<li>ci/cd 자동화 방식</li>
</ul>
<p>octotree</p>
<ul>
<li>크롬 익스텐션</li>
<li>레포의 파일을 쉽게 보수 있도록 해줌</li>
<li><a href="https://chrome.google.com/webstore/detail/octotree-github-code-tree/bkhaagjahfmjljalopjnoealnfndnagc">https://chrome.google.com/webstore/detail/octotree-github-code-tree/bkhaagjahfmjljalopjnoealnfndnagc</a></li>
</ul>
<p>github cli</p>
<ul>
<li>cli terminal 에서 github 을 이용할 수 있게해줌</li>
<li>설치 필요</li>
</ul>
<hr>
<p><strong>add 의 원리</strong></p>
<ul>
<li>add 를 하면 .git 파일 내부의 objects 폴더에</li>
<li>add 된 파일들의 내용이 들어있는 파일이 만들어 지고</li>
<li>index 파일에 add 된 파일의 이름과 그 내용이 담긴 object 파일이 저장된다</li>
<li>이때 object 파일의 이름은 add 되는 파일의 내용과 다른 요소들을 사용해 sha-1 을 이용해 해싱을 한 뒤</li>
<li>해싱 된 이름의 첫 두글자를 이름으로 하는 디렉토리를 만들어 그 아래에 저장한다</li>
<li>ex) f1.txt 파일의 내용이 a 일때 만약 aadk2js….이라는 해시값이 만들어 지면, 해당 파일을 add 했을 시 파일의 내용이 .git/objects/aa/dk2js… 에 저장된다</li>
<li>내용이 같은 파일이면 이름이 다르고 파일이 다르더라도 같은 오브젝트 파일을 가리킨다</li>
</ul>
<p><strong>commit 의 원리</strong></p>
<ul>
<li>커밋된 내용이 objects 폴더 안에 저장된다, 즉 레포도 오브젝트이다
<ul>
<li>해당 오브젝트에는</li>
<li>
<ol>
<li>tree</li>
</ol>
</li>
<li>
<ol start="2">
<li>parent</li>
</ol>
</li>
<li>
<ol start="2">
<li>커밋을 하는 사람의 정보</li>
</ol>
</li>
<li>
<ol start="3">
<li>커밋 메세지</li>
</ol>
</li>
<li>가 저장된다</li>
</ul>
</li>
<li>tree 의 값에는 해당 버전의 파일들의 이름과 그 내용이 담긴 오브젝트가 index처럼 저장되어있다</li>
<li>즉 커밋될 당시의 index 가 tree 로 저장이 된다</li>
<li>parent 의 값에는 해당 레포의 이전 레포의 오브젝트파일이 링크되어있다</li>
<li>이전의 레포가 없는 첫 레포의 오브젝트파일에는 parent 가 없다</li>
<li>즉 각각의 레포은 각각의 트리를 가지고 있으며 각각의 트리에는 각 레포의 저장된 파일의 이름과 그 파일의 내용의 오브젝트가 담겨있다</li>
<li>이 트리는 커밋 될 당시의 폴더의 상태를 그대로 담고 있으며 이를 사진을 찍었다 하여 스냅샷 이라고 한다</li>
<li>각각의 레포는 레포가 만들어질 당시의 스냅샷을 트리로 하여금 저장하고 있다</li>
</ul>
<p><strong>objects 폴더</strong>에 들어가는 파일을 <strong>object 파일</strong>이라고하고</p>
<ul>
<li>이는 3가지가 있다</li>
<li>
<ol>
<li>blob : 파일의 내용을 담고있는 오브젝트 파일</li>
</ol>
</li>
<li>
<ol start="2">
<li>tree : 파일명과 파일명에 해당되는 내용을 담고있는 오브젝트 파일</li>
</ol>
</li>
<li>
<ol start="3">
<li>commit : 트리와 부모 레포, 커밋을 한 사람, 커밋 코맨트를 담고있는 오브젝트 파일</li>
</ol>
</li>
</ul>
<p><strong>index 파일</strong></p>
<ul>
<li>존재하는 파일과 index 파일을 비교해 add 할 파일이 없는지 확인</li>
<li>이것이 현재 레포의 tree 와 차이가 있는 부분이 커밋 대기상태에 들어갔다고 판단함</li>
<li>현재의 tree 와 index, 실제 파일의 차이가 없다면 git status 는 아무것도 표시하지 않음</li>
<li>index 에 올라강 상태를 stage 에 올라갔다고도 함</li>
</ul>
<p><strong>커밋 과정중 파일 데이터의 이동</strong></p>
<ul>
<li>작업공간 –add-&gt; index –commit-&gt; repository(in tree)</li>
</ul>
<p><strong>branch 의 원리</strong></p>
<ul>
<li>HEAD 라는 텍스트 파일 내부에 refs/heads/main 로 링크</li>
<li>refs/heads/main 파일은 기본적으로 가장 최신 커밋의 오브젝트가 담겨있음</li>
<li>branch 를 만들면 refs/heads/ 아래에 브랜치 이름을 가진 파일이 생김</li>
<li>즉, refs/heads/main 또한 main 브랜치의 헤드이다</li>
<li>HEAD 는 현재 있는 브랜치의 헤드파일을 담고있다, 다른 브랜치로 이동하게 되면 HEAD 안에는 refs/head/main 에서 refs/head/other_branch 로 바뀌게 된다</li>
<li>HEAD 파일안에 있는 브랜치 파일이 가리키는 커밋이 현재의 커밋이 된다</li>
</ul>
<p><strong>reset 의 원리</strong></p>
<ul>
<li>HEAD 를 commit id 를 통해 해당 커밋을 가르키도록 한다</li>
<li>ORIG_HEAD 에는 정보를 잃어버릴 가능성이 있는 명령을 실행하기 전, 실행전 HEAD 가 가리키고 있는 커밋을 저장하게 된다</li>
<li>이 ORIG_HEAD 를 사용해 이정릐 상황으로 되돌아 갈 수 있다</li>
<li>logs/refs/heads/main 에는 main 브랜치의 HEAD 가 지금까지 이동한 로그를 가지고 있다</li>
</ul>
<p><strong>working directory &amp; index &amp; repository</strong></p>
<ul>
<li>working directory = working tree = working copy = 현재 일하고 있는 환경</li>
<li>index = staging area = cache = 현재 작업을 커밋 대기상태에 올려놓는 공간</li>
<li>repository = history = tree = 현재 커밋의 상태가 저장된 공간 ( commit-tree 에 저장된 내용)</li>
<li>git reset –hard : working directory, index, repository 의 내용이 전부 초기화 된다</li>
<li>git reset –soft : repository 의 내용만 초기화가 된다</li>
<li>git reset –mixed : index, repository 의 내용이 초기화가 된다</li>
</ul>
<p><strong>merge 의 원리</strong></p>
<ul>
<li>merge 를 실행중 충돌이 일어나면</li>
<li>인덱스에는 병합이 진행되는 파일의 비교를 위해 부모의 파일, 각 브랜치에서 수정된 파일이 추가가 된다</li>
<li>MERGE_HEAD 에는 머지가 되어 만들어질 커밋의 오브젝트파일이 링크된다</li>
<li>충돌어 수정해야 할 파일의 내용이 하나의 오브젝트 파일로 만들어진다</li>
</ul>
<p><strong>kdiff3 머징 툴의 사용</strong></p>
<ul>
<li>병합을 전문적으로 도와주는 툴</li>
<li>설치 : git config –global merge.tool kdiff3</li>
<li>이후 셋팅은 검색하기</li>
<li>충돌 이후 git mergetool 을 사용하면 충돌이 난 파일을 검색해 해당 툴을 열어준다</li>
</ul>
<p><strong>2 way merge &amp; 3 way merge</strong></p>
<ul>
<li>수정 된 양쪽 브랜치의 두개의 커밋만 보고 병합하는 방식</li>
<li>수정 된 두개의 브랜치와 base 커밋을 같이 보고 병합하는 방식</li>
<li>git 은 기본적으로 3 way merge 를 사용한다</li>
</ul>
<p><strong>merge 의 두가지 방식</strong></p>
<ul>
<li>fast-forward
<ul>
<li>main 에서 브랜치를 생성 후 머지를 할때, main 브랜치에 또다른 커밋이 없었을 경우 별도의 커밋 없이 main 브랜치가 새로 생긴 브랜치의 마지막 커밋을 가르키게된다</li>
<li>이것을 fast-forward, 빨리감기 라고한다</li>
<li>이 머징 이후 새로생긴 브랜치를 지워준다</li>
<li>이 방식은 새로운 커밋을 만들지 않는다</li>
<li>기존 브랜치를 분기했던 기록이 남지 않아 해당 기록을 남겨야 할때는 –no-ff 옵션을 사용한다</li>
</ul>
</li>
<li>recursive
<ul>
<li>main 에서 브랜치를 생성해 작업 후 main 메 머징을 할때, main 브랜치에 커밋이 있을 경우 발생한다</li>
<li>머지 되는 두 커밋의 공통 조상이 되는 커밋과 두 커밋을 three-way merge 를 사용해 두 커밋을 합친 뒤 해당 정보를 가진 새로운 레포를 커밋한다</li>
<li>새로생긴 레포는 main 이 가리키고있다</li>
<li>이 방식은 새로운 커밋을 만든다</li>
</ul>
</li>
</ul>
<p><strong>gitflow</strong></p>
<ul>
<li>협업을 위한 git 사용의 방법론</li>
<li>main : 제품출시, 배포</li>
<li>develope : 다음배포를 위한 개발</li>
<li>feature : 기능 개발</li>
<li>release : 출시 전 테스트</li>
<li>hotfix : 긴급 버그 수정</li>
</ul>

        </article>
        
        
    </main>

    

<footer>
    <p>Author: Dongyoon Kim - <a href="https://biisairo.github.io/">Home</a> - <a href="https://github.com/Biisairo">GitHub</a> - <a
            href="mailto:rlark1224@naver.com">Mail</a></p>
</footer>

</body>

</html>