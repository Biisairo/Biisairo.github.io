<!DOCTYPE html>



<html>

<head>
    <meta charset="UTF-8">
    <title>5 서버측의 LAN 에는 무엇이 있는가</title>
    <link rel="icon" href="https://biisairo.github.io/static/favicon.ico" type="image/x-icon">
</head>

<script>
    function toggleSection(id) {
        const section = document.getElementById(id);
        const header = section.previousElementSibling;

        if (section.style.display === 'none') {
            section.style.display = 'block';
            header.innerHTML = header.innerHTML.replace('▶', '▼');
        } else {
            section.style.display = 'none';
            header.innerHTML = header.innerHTML.replace('▼', '▶');
        }
    }
</script>

<body>
    <header>
    <nav>
        <ul>
            

            <li><a href="https://biisairo.github.io/">Home</a></li>
            
            <li><a href="https://biisairo.github.io/About/">About</a></li>
            
            <li><a href="https://biisairo.github.io/Study/">Study</a></li>
            
            <li><a href="https://biisairo.github.io/Contact/">Contact</a></li>
            
        </ul>
    </nav>

    <style>
    html,
    body {
        height: 100%;
        margin: 0;
    }

    body {
        display: flex;
        flex-direction: column;
        max-width: 720px;
        margin: 0 auto;
        padding: 2rem 1rem;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
            Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        line-height: 1.6;
        background: #222831;
        color: #EEEEEE;
    }

    header,
    footer {
        text-align: center;
        margin-bottom: 2rem;
    }

    nav ul {
        list-style: none;
        padding: 0;
        display: flex;
        justify-content: space-between;
        align-items: flex-end;

        flex-wrap: wrap;
        gap: 1rem;
    }

    nav li:first-child {
        margin-right: auto;
    }

    nav li:not(:first-child) {
        margin-left: 0;
    }

    nav li:first-child a {
        color: #EEEEEE;
        font-size: 1.5em;
        text-decoration: none;
    }

    nav li:first-child a:hover {
        color: #aadadf;
    }

    nav a {
        color: #00ADB5;
        text-decoration: underline;
        transition: color 0.3s ease;
    }

    nav a:hover {
        color: #66C1C9;
        text-decoration: none;
    }

    main a,
    article a,
    footer a {
        color: #33d3c8;
        text-decoration: underline;
        transition: color 0.3s ease;
    }

    main a:hover,
    article a:hover,
    footer a:hover {
        color: #66C1C9;
        text-decoration: none;
    }

    main {
        flex: 1;
        margin-bottom: 2rem;
    }

    h1,
    h2,
    h3 {
        line-height: 1.3;
        margin-top: 2rem;
        margin-bottom: 1rem;
        color: #00ADB5;
    }

    h2[onclick] {
        user-select: none;
        color: #2699b6;
    }


    ul {
        padding-left: 1.5rem;
    }

    article {
        margin-top: 2rem;
        border: 1px solid #33d3c8;
        padding: 1rem;
        border-radius: 5px;
    }

    footer p {
        font-size: 0.9rem;
        color: #AAAAAA;
    }
</style>

</header>

    <main>
        
        
        

        
        <h2 onclick="toggleSection('pages')" style="cursor: pointer;">▶ 하위 페이지</h2>
        <div id="pages" style="display: none;">
            <ul>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac/%ec%84%b1%ea%b3%b5%ea%b3%bc%20%ec%8b%a4%ed%8c%a8%eb%a5%bc%20%ea%b2%b0%ec%a0%95%ed%95%98%eb%8a%94%201%25%ec%9d%98%20%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac%20%ec%9b%90%eb%a6%ac/1%20%ec%9b%b9%20%eb%b8%8c%eb%9d%bc%ec%9a%b0%ec%a0%80%ea%b0%80%20%eb%a9%94%ec%8b%9c%ec%a7%80%eb%a5%bc%20%eb%a7%8c%eb%93%a0%eb%8b%a4.html">1 웹 브라우저가 메시지를 만든다</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac/%ec%84%b1%ea%b3%b5%ea%b3%bc%20%ec%8b%a4%ed%8c%a8%eb%a5%bc%20%ea%b2%b0%ec%a0%95%ed%95%98%eb%8a%94%201%25%ec%9d%98%20%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac%20%ec%9b%90%eb%a6%ac/2%20TCP%20IP%20%ec%9d%98%20%eb%8d%b0%ec%9d%b4%ed%84%b0%eb%a5%bc%20%ec%a0%84%ea%b8%b0%20%ec%8b%a0%ed%98%b8%eb%a1%9c%20%eb%a7%8c%eb%93%a4%ec%96%b4%20%eb%b3%b4%eb%82%b8.html">2 TCP IP 의 데이터를 전기 신호로 만들어 보낸</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac/%ec%84%b1%ea%b3%b5%ea%b3%bc%20%ec%8b%a4%ed%8c%a8%eb%a5%bc%20%ea%b2%b0%ec%a0%95%ed%95%98%eb%8a%94%201%25%ec%9d%98%20%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac%20%ec%9b%90%eb%a6%ac/3%20%ec%bc%80%ec%9d%b4%eb%b8%94%ec%9d%98%20%ec%95%9e%ec%9d%80%20LAN%20%ea%b8%b0%ea%b8%b0%ec%98%80%eb%8b%a4.html">3 케이블의 앞은 LAN 기기였다</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac/%ec%84%b1%ea%b3%b5%ea%b3%bc%20%ec%8b%a4%ed%8c%a8%eb%a5%bc%20%ea%b2%b0%ec%a0%95%ed%95%98%eb%8a%94%201%25%ec%9d%98%20%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac%20%ec%9b%90%eb%a6%ac/4%20%ec%95%a1%ec%84%b8%ec%8a%a4%20%ed%9a%8c%ec%84%a0%ec%9d%84%20%ed%86%b5%ed%95%b4%20%ec%9d%b8%ed%84%b0%eb%84%b7%ec%9d%98%20%eb%82%b4%eb%b6%80%eb%a1%9c.html">4 액세스 회선을 통해 인터넷의 내부로</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac/%ec%84%b1%ea%b3%b5%ea%b3%bc%20%ec%8b%a4%ed%8c%a8%eb%a5%bc%20%ea%b2%b0%ec%a0%95%ed%95%98%eb%8a%94%201%25%ec%9d%98%20%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac%20%ec%9b%90%eb%a6%ac/5%20%ec%84%9c%eb%b2%84%ec%b8%a1%ec%9d%98%20LAN%20%ec%97%90%eb%8a%94%20%eb%ac%b4%ec%97%87%ec%9d%b4%20%ec%9e%88%eb%8a%94%ea%b0%80.html">5 서버측의 LAN 에는 무엇이 있는가</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac/%ec%84%b1%ea%b3%b5%ea%b3%bc%20%ec%8b%a4%ed%8c%a8%eb%a5%bc%20%ea%b2%b0%ec%a0%95%ed%95%98%eb%8a%94%201%25%ec%9d%98%20%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac%20%ec%9b%90%eb%a6%ac/6%20%ec%9b%b9%20%ec%84%9c%eb%b2%84%ec%97%90%20%eb%8f%84%ec%b0%a9%ed%95%98%ec%97%ac%20%ec%9d%91%eb%8b%b5%20%eb%8d%b0%ec%9d%b4%ed%84%b0%ea%b0%80%20%ec%9b%b9%20%eb%b8%8c%eb%9d%bc%ec%9a%b0%ec%a0%80.html">6 웹 서버에 도착하여 응답 데이터가 웹 브라우저</a></li>
                
            </ul>
        </div>
        

        
        
        <article>
            <h1>5. 서버측의 LAN 에는 무엇이 있는가?</h1>
<h2>1. 웹 서버의 설치 장소</h2>
<h3>1. 사내에 웹 서버를 설치하는 경우</h3>
<ul>
<li>라우터에서 직접 연결하는 경우
<ul>
<li>가장 가까운 POP 의 라우터, 액세스 회선, 서버의 라우터를 경유해 서버에 도달</li>
</ul>
</li>
<li>위와 같은 방법이 현재 쓰이지 않는 이유
<ul>
<li>IP 주소의 부족
<ul>
<li>서버뿐만이 아닌 클라이언트또한 전부 글로벌 주소를 할당해야 함</li>
</ul>
</li>
<li>보안상의 이유
<ul>
<li>서버가 노출되어 있는 상태로 되어있게 됨</li>
</ul>
</li>
</ul>
</li>
<li>방화벽
<ul>
<li>네트워크를 외부로부터의 공격에서 지키기 위한 구조</li>
<li>특정 서버로 도달하는 특정 패킷만 통과시키고 그 외의 패킷을 차단하는 역할을 하게 됨</li>
</ul>
</li>
</ul>
<h3>2. 데이터센터에 웹 서버를 설치하는 경우</h3>
<ul>
<li>프로바이더와 같은곳에서 운영하는 데이터센터를 이용하는 방법</li>
<li>데이터센터는 프로바이더가 운영하는 NOC 나 IX 에 직접 연결이 되어있어 빠른 접속이 가능해짐
<ul>
<li>서버에 대한 액세스가 많아졌을 떄 효과적</li>
<li>데이터센터를 관리하는 주체가 프로바이더이기 때문에 안전성이 높음</li>
</ul>
</li>
</ul>
<h2>2. 방화벽의 원리와 동작</h2>
<h3>1. 패킷 필터링형이 주류이다</h3>
<h3>2. 패킷 필터링의 조건 설정 개념</h3>
<ul>
<li>패킷의 헤더를 조사하여 필터링
<ul>
<li>MAC 헤더
<ul>
<li>송신처 MAC 주소</li>
</ul>
</li>
<li>IP 헤더
<ul>
<li>송신처 IP 주소</li>
<li>수신처 IP 주소</li>
<li>프로토콜 번호</li>
</ul>
</li>
<li>TCP, UDP 헤더
<ul>
<li>송신처 포트 번호</li>
<li>수신처 포트 번호</li>
<li>TCP 컨트롤 비트</li>
<li>프래그먼트</li>
</ul>
</li>
<li>ICMP메시지 내용</li>
</ul>
</li>
</ul>
<h3>3. 애플리케이션을 한정할 때 포트 번호를 사용한다</h3>
<ul>
<li>특정 애플리케이션으로 향하는 패킷만 허용할 때 해당 애플리케이션에서 사용하는 포트번호를 조건으로 추가</li>
</ul>
<h3>4. 컨트롤 비트로 접속 방향을 판단한다</h3>
<ul>
<li>TCP 의 최초 접속 동작에서 사용하는 3개의 패킷에서 최초의 패킷에는 SYN 비트를 1로 설정하게 됨</li>
<li>이 값을 사용해 첫번째 패킷과 이후의 패킷을 구분할 수 있음</li>
</ul>
<h3>5. 사내 LAN 에서 공개 서버용 LAN 으로 조건을 설정한다</h3>
<h3>6. 밖에서 사내 LAN 으로 액세스 할 수 없다</h3>
<ul>
<li>조건에 따라 주소 변환이 일어났을 때 액세스 여부가 결정될 수 있음</li>
</ul>
<h3>7. 방화벽을 통과한다</h3>
<ul>
<li>방화벽에 여러 조건들을 설정해 놓고 해당 조건에 해당하는 패킷만 통과시킴</li>
<li>통과하지 못하는 패킷은 버리고 버린 기록을 남김
<ul>
<li>해당 기록을 확인하여 부정침입, 공격에 대한 대책을 새울 수 있음</li>
</ul>
</li>
</ul>
<h3>8. 방화벽으로 막을 수 없는 공격</h3>
<ul>
<li>방화벽은 단지 위 데이터의 조건만으로 패킷을 필터랑함</li>
<li>패킷 내부의 데이터에 위험한 내용이 담겨있는 등의 공격을 가하면 방화벽에서는 패킷을 통과시키게 됨</li>
<li>이를위한 다른 대책을 새울 필요가 생김</li>
</ul>
<h2>3. 복수 서버에 리퀘스트를 분배한 서버의 부하 분산</h2>
<h3>1. 처리 능력이 부족하면 복수 서버로 부하 분산된다</h3>
<ul>
<li>분산 처리
<ul>
<li>복수의 서버를 두어 서버 한대당 처리량을 줄이는 방식</li>
</ul>
</li>
<li>다수의 웹서버를 설치하여 한대가 담당하는 사용자 수를 줄이는 방법
<ul>
<li>클라이언트의 리퀘스트를 웹서버들에게 분배하는 과정이 필요
<ul>
<li>DNS 서버에서 분배하는 방법
<ul>
<li>라운드 로빈 방식
<ul>
<li>DNS 서버에 같은 도메인에 여러 IP 주소를 등록하는 방식</li>
<li>해당 도메인으로 요청이 들어오면 등록이 된 순서대로 IP 주소를 반환해 주게 됨</li>
<li>여러개의 웹 서버 중 하나가 고장이 나더라도 DNS 는 서버가 고장났는지 파악하지 못하기 때문에 고장 여부에 상관없이 IP 주소를 반환함</li>
<li>클라이언트와 웹서버가 복수의 페이지를 이용하여 대화를 할 때 대화가 연결되지 않음
<ul>
<li>첫번째 페이지의 내용과 두번째 페이지의 내용이 이어져야 할 경우 다른 웹서버를 사용하면 안됨</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>2. 부하 분산 장치를 이용해 복수의 웹 서버로 분할된다</h3>
<ul>
<li>부하 분산 장치, 로드 밸런서</li>
<li>DNS 에 웹서버가 아는 로드 밸런서의 주소를 등록</li>
<li>클라이언트는 직접 웹 서버에 요청을 보내는 것이 아닌 로드 밸런서에 요청을 보내게 됨</li>
<li>로드 벨런서가 판단하여 다수의 서버에 요청을 나누어 전달
<ul>
<li>판단 근거
<ul>
<li>대화가 복수의 페이지에 걸쳐있는 경우
<ul>
<li>웹 서버의 부하 상태</li>
<li>웹 서버와 정보를 교환하여 CPU, 메모리의 사용량을 확인하고 이를 바탕으로 부하가 적은 서버에 요청을 보냄</li>
</ul>
</li>
<li>대화가 복수의 페이지에 걸쳐있지 않은 경우
<ul>
<li>HTTP 는 기본적으로 모든 대화가 독립적 : stateless</li>
<li>프록시 를 사용하게 되면 송신자의 IP 를 확실하게 알 수 없게 되기 때문에 송신처 IP 로 클라이언트를 특정할 수 없음
<ul>
<li>클라이언트와 웹 서버 사이에서 액세스 동작을 중계하는 것</li>
</ul>
</li>
<li>HTTP 의 사양을 확장하여 전후관계를 판단하기 위한 정보를 HTTP 헤더에 부가하는 방식을 사용</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>4. 캐시 서버를 이용한 서버의 부하 분산</h2>
<h3>1. 캐시 서버의 이용</h3>
<ul>
<li>프록시를 사용하여 데이터를 캐시에 저장</li>
<li>프록시
<ul>
<li>웹 서버와 클라이언트 사이에서 웹 서버에 대한 액세스 동작을 중계하는 역할을 함</li>
<li>웹 서버에서 받은 데이터를 디스크에 저장해 두고 웹 서버를 대신하여 데이터를 클라이언트에 반송함</li>
<li>캐시
<ul>
<li>캐시 서버에 저장된 데이터</li>
</ul>
</li>
</ul>
</li>
<li>서버에서 직접 데이터를 전송하는 것 보다 속도가 빠름</li>
<li>웹 서버가 해야할 일 중 일부를 캐시 서버가 맡게 되면서 웹 서버의 부하가 줄어들게 됨</li>
</ul>
<h3>2. 캐시 서버를 갱신을로 콘텐츠를 관리한다</h3>
<ul>
<li>캐시 서버를 로드 밸런서와 마찬가지로 웹 서버 대신 DNS 에 등록</li>
<li>클라이언트는 웹 서버에 직업 요청을 보내는 것이 아닌 캐시 서버에 요청을 보내게 됨</li>
<li>캐시가 저장되어 있지 않은 경우
<ul>
<li>캐시 서버에서 요청 메시지에 캐시 서버를 경유한 것을 알리는 Via 헤더 필드를 추가하여 웹 서버에 전송
<ul>
<li>웹 서버가 한대일 경우 해당 웹 서버에 요청을 전송</li>
<li>저장한 캐시가 여러대의 웹 서버일 경우
<ul>
<li>메시지의 내용에 따라 전송 대상 웹 서버를 판단해야 함</li>
<li>리퀘스트 메시지의 URI 에 쓰인 디렉토리를 보고 판단할 수 있음</li>
</ul>
</li>
</ul>
</li>
<li>캐시 서버에서 웹 서버의 응답을 받음</li>
<li>응답 메시지에 Via 헤더를 부여해 클라이언트에 전송
<ul>
<li>클라이언트는 해당 헤더를 보고 이 데이터가 캐시 서버를 경유해 온 데이터임을 알 수 있음</li>
</ul>
</li>
</ul>
</li>
<li>캐시가 저장되어 있는 경우
<ul>
<li>캐시 서버가 클라이언트로 부터 요청을 받으면 해당 데이터가 캐시되어 있는지 확인</li>
<li>데이터가 존재할 시 웹 서버에 해당 데이터가 변경되었는지 확인을 요청
<ul>
<li>요청 헤더에 If-Modified-Since 헤더를 부여해 전송</li>
<li>웹 서버는 해당 헤더의 값과 데이터의 최종 갱신 일시를 비교</li>
</ul>
</li>
<li>데이터의 변경이 없으면 변경 사항이 없다는 것을 알리는 응답 메시지를 전송
<ul>
<li>해당 응답은 데이터를 넣은 응답에 비해 짧아 부담이 적음</li>
</ul>
</li>
<li>데이터의 변경사항이 없다는걸 안 캐시 서버가 캐시를 추출하여 클라이언트에게 응답을 보냄</li>
<li>데이터의 변경사항이 있는 경우 캐시 서버에 데이터가 없을 경우와 같이 작동
<ul>
<li>데이터를 웹 서버로 부터 받아와 Via 헤더를 부여해 클라이언트에게 발송</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>3. 프록시의 원점은 포워드 프록시이다</h3>
<ul>
<li>포워드 프록시
<ul>
<li>클라이언트 측에 두는 캐시 서버</li>
<li>프록시의 원형</li>
<li>방화벽을 실행한다는 추가의 목적</li>
</ul>
</li>
<li>방화벽의 목적은 인터넷의 부정 침입을 막는 것
<ul>
<li>모든 패킷을 막아버리면 가능하지만 인터넷과의 접속이 불가능해짐</li>
</ul>
</li>
<li>포워드 프록시에서 클라이언트의 요청을 먼저 받아 인터넷에 전송</li>
<li>포워드 프록시의 캐시를 사용해 이미 액세스 한 페이지의 데이터를 저장시켜 사용</li>
<li>포워드 프록시가 설정되어 있는 경우의 송신 동작
<ul>
<li>포워드 프록시가 설정되어 있지 않은 경우 요청은 상대 웹 서버에게 전송됨</li>
<li>포워드 프록시가 설정되어 있는 경우에는 모든 요청이 포워드 프록시로 가게 되어있음</li>
<li>HTTP 헤더의 URI 에 디렉토리만 적는것이 아닌 전체 URL 을 기입</li>
</ul>
</li>
</ul>
<h3>4. 포워드 프록시를 개량한 리버스 프록시</h3>
<ul>
<li>포워드 프록시를 사용할 경우 브라우저에서의 설정이 필수
<ul>
<li>해당 설정이 복잡하고 잘못 설정할 경우 제대로 작동하지 않음</li>
</ul>
</li>
<li>클라이언트에서 프록시를 설정하지 않고 서버측에 있는 캐시 서버에서 사용하는 방식을 리버스 프록시 라고 함</li>
</ul>
<h3>5. 트랜스페어런트 프록시</h3>
<ul>
<li>패킷의 IP 헤더의 HOST 헤더 필드를 사용해 캐시 서버에서 액세스 대상 웹 서버를 알아내 패킷을 전송하는 방법</li>
<li>보통의 리퀘스트 메시지를 사용하며 전송 대상을 캐싱할 필요도 없음</li>
<li>브라우저에서 설정하는 것이 없으므로 일반적인 요청 메시지를 보냄</li>
<li>DNS 서버에 프록시 주소를 등록하는 것이 아니기에 패킷은 바로 웹 서버로 흘러감</li>
<li>브라우저에서 웹 서버로 요청 메시지가 가는 길목에 트랜스페어런트 프록시를 설치</li>
<li>트랜스페어런트 프록시가 메시지를 가로채서 프록시에 페킷이 도달</li>
<li>경로가 많을 경우 모든 경로에 프록시를 설치해야 하므로 페킷이 한곳으로 모여서 갈 수 있도록 경로를 설정하고 모이는 지점에 프록시를 설치하도록 함</li>
<li>액세스 회선 같은 곳을 사용</li>
</ul>
<h2>5. 콘텐츠 배포 서비스</h2>
<h3>1. 콘텐츠 배포 서비스를 이용한 부하 분산</h3>
<ul>
<li>서버측에 있는 캐시 서버
<ul>
<li>서버의 부담을 줄일 수 있음</li>
<li>서버와 클라이언트 간의 트래픽은 줄지 않음</li>
</ul>
</li>
<li>클라이언트측에 있는 캐시 서버
<ul>
<li>서버의 부담을 줄이고 트래픽을 줄일 수 있음</li>
<li>서버의 운영자가 캐시 서버를 제어할 수 없음</li>
</ul>
</li>
<li>프로바이더와의 계약으로 인터넷 프로바이더 근처에 두는 캐시 서버
<ul>
<li>둘의 장점만 취합한 방법</li>
<li>사용자와 가까운 프로바이더에 캐시 서버를 설치해 웹 서버의 운영자가 제어하도록 함</li>
<li>클라이언트가 어디서 접속할지 모르기때문에 모든 POP 에 캐시 서버를 설치해야함
<ul>
<li>주요 프로바이더들에 캐시 서버를 설치해서 클라이언트가 캐시 서버를 먼저 사용하도록함</li>
<li>캐시 서버를 사용하면 돌아가는 길이긴 하나 직접 웹 서버에 접속하는 것 보다는 빠름</li>
</ul>
</li>
</ul>
</li>
<li>콘텐츠 배포 서비스
<ul>
<li>CDS (Content Delivery Service)</li>
<li>캐시 서버를 설치하고 웹 서버 운영자에게 캐시 서버를 제공해 주는 서비스</li>
<li>CDSP (CDS Provider)
<ul>
<li>콘텐츠 배포 서비스 사업자</li>
</ul>
</li>
<li>CDSP 가 중요 프로바이더와 계약해 캐시 서버를 설치하고 이들이 웹 운영자와 계약하여 캐시 서버를 빌려주는 방식</li>
</ul>
</li>
</ul>
<h3>2. 가장 가까운 캐시 서버의 관점</h3>
<ul>
<li>클라이언트는 인터넷에 설치된 다수의 캐시 서버에 액세스 하여 정보를 받아옴</li>
<li>캐시 서버를 이용하는 방법
<ul>
<li>DNS 서버에서 액세스를 분배
<ul>
<li>DNS 서버가 IP 주소를 반환할 때 가장 가까운 캐시 서버의 주소를 반환하도록 하는 것</li>
</ul>
</li>
<li>클라이언트로부터 최단거리의 캐시 서버를 찾는 법
<ul>
<li>서버는 미리 캐시 서버의 라우터들의 경로 정보를 수집해 둠</li>
<li>해당 경로표를 사용해 캐시 서버의 라우터에서 클라이언트측의 DNS 서버까지를 경로를 알아냄</li>
<li>해당 경로를 알면 대략적인 거리 또한 알 수 있음</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>3. 리피터용 서버로 액세스 대상을 분배한다</h3>
<ul>
<li>HTTP 의 헤더 중 Location 헤더를 사용</li>
<li>Location 헤더는 ‘해당 정보는 다른곳에 있으니 이쪽으로 다시 접속하라’ 라는 의미로 redirect 라고 함</li>
<li>리다이렉트를 사용해 액세스 대상을 가장 가까운 캐시 서버로 이동시키는 방법</li>
<li>리다이렉트용 서버를 DNS 에 등록시킨 다음 클라이언트가 리다이렉트 서버에 요청을 보내게 함</li>
<li>해당 서버에는 캐시 서버의 경로표가 등록되어 있어 클라이언트로부터 최단거리의 캐시 서버로 리다이렉트를 해주게 됨</li>
<li>리다이렉트는 클라이언트가 보내는 HTTP 메시지의 IP 를 이용하기 때문에 정밀한 최단거리 측정이 가능함
<ul>
<li>패킷의 왕복 시간을 이용해 최적의 캐시 서버에 액세스 하는것을 도움</li>
</ul>
</li>
</ul>
<h3>4. 캐시 내용의 갱신 방법에서 성능 차이가 난다</h3>
<ul>
<li>일반적인 캐시는 그때그때 최신화가 이뤄졌는지 확인하는 과정이 필요</li>
<li>대용량의 캐시 서버에서 이런식으로 캐싱을 하게 되면 응답 시간이 늘어나게 됨</li>
<li>CDS는 웹 서버에서 데이터가 갱신되었을 때 동시에 캐시 서버도 최신화를 하도록 되어있음</li>
</ul>

        </article>
        
        
    </main>

    

<footer>
    <p>Author: Dongyoon Kim - <a href="https://biisairo.github.io/">Home</a> - <a href="https://github.com/Biisairo">GitHub</a> - <a
            href="mailto:rlark1224@naver.com">Mail</a></p>
</footer>

</body>

</html>