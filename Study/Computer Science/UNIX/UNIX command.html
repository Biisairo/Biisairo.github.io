<!DOCTYPE html>



<html>

<head>
    <meta charset="UTF-8">
    <title>UNIX command</title>
    <link rel="icon" href="https://biisairo.github.io/static/favicon.ico" type="image/x-icon">
</head>

<script>
    function toggleSection(id) {
        const section = document.getElementById(id);
        const header = section.previousElementSibling;

        if (section.style.display === 'none') {
            section.style.display = 'block';
            header.innerHTML = header.innerHTML.replace('▶', '▼');
        } else {
            section.style.display = 'none';
            header.innerHTML = header.innerHTML.replace('▼', '▶');
        }
    }
</script>

<body>
    <header>
    <nav>
        <ul>
            

            <li><a href="https://biisairo.github.io/">Home</a></li>
            
            <li><a href="https://biisairo.github.io/About/">About</a></li>
            
            <li><a href="https://biisairo.github.io/Study/">Study</a></li>
            
            <li><a href="https://biisairo.github.io/Contact/">Contact</a></li>
            
        </ul>
    </nav>

    <style>
    html,
    body {
        height: 100%;
        margin: 0;
    }

    body {
        display: flex;
        flex-direction: column;
        max-width: 720px;
        margin: 0 auto;
        padding: 2rem 1rem;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
            Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        line-height: 1.6;
        background: #222831;
        color: #EEEEEE;
    }

    header,
    footer {
        text-align: center;
        margin-bottom: 2rem;
    }

    nav ul {
        list-style: none;
        padding: 0;
        display: flex;
        justify-content: space-between;
        align-items: flex-end;

        flex-wrap: wrap;
        gap: 1rem;
    }

    nav li:first-child {
        margin-right: auto;
    }

    nav li:not(:first-child) {
        margin-left: 0;
    }

    nav li:first-child a {
        color: #EEEEEE;
        font-size: 1.5em;
        text-decoration: none;
    }

    nav li:first-child a:hover {
        color: #aadadf;
    }

    nav a {
        color: #00ADB5;
        text-decoration: underline;
        transition: color 0.3s ease;
    }

    nav a:hover {
        color: #66C1C9;
        text-decoration: none;
    }

    main a,
    article a,
    footer a {
        color: #33d3c8;
        text-decoration: underline;
        transition: color 0.3s ease;
    }

    main a:hover,
    article a:hover,
    footer a:hover {
        color: #66C1C9;
        text-decoration: none;
    }

    main {
        flex: 1;
        margin-bottom: 2rem;
    }

    h1,
    h2,
    h3 {
        line-height: 1.3;
        margin-top: 2rem;
        margin-bottom: 1rem;
    }

    h1 {
        color: #00ADB5;
    }

    h2 {
        color: #0099A1;
    }
    
    h3 {
        color: #007B82;
    }

    h2[onclick] {
        user-select: none;
        color: #2699b6;
    }

    ul {
        padding-left: 1.5rem;
    }

    article {
        margin-top: 2rem;
        border: 1px solid #33d3c8;
        padding: 1rem;
        border-radius: 5px;
    }

    footer p {
        font-size: 0.9rem;
        color: #AAAAAA;
    }

    strong {
        color: #00b5a9;
    }
</style>

</header>

    <main>
        
        
        

        
        <h2 onclick="toggleSection('pages')" style="cursor: pointer;">▶ 하위 페이지</h2>
        <div id="pages" style="display: none;">
            <ul>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/UNIX/UNIX%20command.html">UNIX command</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/UNIX/UNIX%20permission.html">UNIX permission</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/UNIX/UNIX%20etc.html">UNIX etc</a></li>
                
            </ul>
        </div>
        

        
        
        <article>
            <h1>UNIX command</h1>
<table>
<thead>
<tr>
<th>종류</th>
<th></th>
<th>명령어</th>
</tr>
</thead>
<tbody>
<tr>
<td>확인</td>
<td></td>
<td>pwd ls file printenv ifconfig</td>
</tr>
<tr>
<td>생성</td>
<td></td>
<td>touch mkdir</td>
</tr>
<tr>
<td>내용출력</td>
<td></td>
<td>cat less tac rev head tail</td>
</tr>
<tr>
<td>검색</td>
<td>파일검색</td>
<td>locate find</td>
</tr>
<tr>
<td></td>
<td>내용검색</td>
<td>grep awk</td>
</tr>
<tr>
<td>출력</td>
<td></td>
<td>wc sort echo</td>
</tr>
<tr>
<td>파일관리</td>
<td></td>
<td>cd rm mv cp</td>
</tr>
<tr>
<td>데이터 조작</td>
<td></td>
<td>tr sed basename dirname bc/dc</td>
</tr>
<tr>
<td>권한</td>
<td></td>
<td>chmod chown groups addgroup adduser</td>
</tr>
<tr>
<td>기타</td>
<td></td>
<td>xarg ; &amp;&amp;</td>
</tr>
</tbody>
</table>
<p>pwd</p>
<ul>
<li>print working directort 의 약자</li>
<li>root 디렉토리로 부터 현재 디렉토리의 경로를 알려준다</li>
</ul>
<p>ls</p>
<ul>
<li>현재 디렉토리 내부의 목록을 보여준다</li>
<li>ls <path> 로 상대, 절대경로를 넣어 해달 경로의 목록을 확인할 수 있다</li>
<li>ls -a : dotfile 을 포함한 숨은 파일과 디렉토리들을 전부 보여준다</li>
<li>ls -l : 목록의 구성들의 세부 내용을 보여준다</li>
<li>ls -R : 해당 디렉토리와 그 하위에 있는 디렉토리까지의 모든 목록을 보여준다</li>
</ul>
<p>cd</p>
<ul>
<li>cd <path> 로 해당 디렉토리로 들어갈 수 있다</li>
</ul>
<p>touch</p>
<ul>
<li>touch <filename></li>
<li>빈 파일을 생성한다</li>
</ul>
<p>file</p>
<ul>
<li>file <filename></li>
<li>해당 파일의 타입을 프린트해준다</li>
</ul>
<p>mkdir</p>
<ul>
<li>mkdir <dirname></li>
<li>빈 디랙토리를 생성한다</li>
</ul>
<p>rm</p>
<ul>
<li>rm <filename></li>
<li>해당 파일을 지운다</li>
<li>rm -d <dirname> : 해당 폴더가 비어있다면, 폴더를 지운다</li>
<li>rm -r <dirname> : r 은 recursive 의 약어로 폴더와 폴더 안의 모든것을 재귀적으로 지운다, 즉 폴더 내부를 포함해 폴더를 지운다</li>
</ul>
<p>mv</p>
<ul>
<li>mv <src> <dest></li>
<li>src 를 dest 로 옮긴다</li>
<li>이때 dest 에 경로를 지정해 주지 않고, 혹은 경로 아래 filename 부분을 변경할 시 이름이 바뀌게된다</li>
</ul>
<p>cp</p>
<ul>
<li>cp <src> <dest></li>
<li>mv 와 같은 원리로 작동하나 원본이 남아있다고 생각하면 된다</li>
<li>R : 파일복사</li>
</ul>
<p>cat</p>
<ul>
<li>cat <filename></li>
<li>파일의 내용들을 전부 보여준다</li>
<li>cat <file1> <file2> 처럼 사용하면 여러 파일을 이어붙여서 보여준다</li>
</ul>
<p>less</p>
<ul>
<li>less <filename></li>
<li>파일의 내용을 터미널 밖에서 보여준다</li>
<li>man 페이지가 하나의 예</li>
</ul>
<p>tac</p>
<ul>
<li>cat 과 사용법이 같다</li>
<li>파일의 내용을 ‘역순으로’ 전부 보여준다</li>
<li>줄 단위의 역순이므로 첫째줄이 마지막에, 마지막 줄이 처음에 오게 된다</li>
</ul>
<p>rev</p>
<ul>
<li>cat 과 사용법이 같다</li>
<li>파일의 내용을 각 줄졀로 역순으로 보여준다</li>
<li>줄의 순서는 유지한 채 각 줄의 뒤집힌다</li>
</ul>
<p>head</p>
<ul>
<li>head <filename></li>
<li>파일의 첫 10줄을 보여준다</li>
<li>head -n <num> <filename> : 파일의 첫 num 줄만큼을 보여준다</li>
<li>head -c <num> <filename> : 파일의 첫 num byte 만큼을 보여준다</li>
</ul>
<p>tail</p>
<ul>
<li>head 와 사용법이 같다</li>
<li>n -c 도 공유한다</li>
</ul>
<p>wc</p>
<ul>
<li>word count 의 약어</li>
<li>wc -l <filename> : 파일의 줄 수를 새어준다</li>
<li>wc -w <filename> : 파일의 단어수를 새어준다</li>
</ul>
<p>sort</p>
<ul>
<li>sort <filename></li>
<li>파일 안의 각각의 줄을 알파벳 순서(아마 아스키코드)로 배열한다</li>
<li>정렬 된 결과만이 프린트 되어 나올 뿐, 파일에는 변화를 주지 않는다</li>
<li>sort -r <filename> : 역순으로 정렬된다</li>
<li>sort -n <filename> : 단순 아스키코드 순으로 정렬되던 줄들이 숫자의 크기별로 정렬된다</li>
<li>sort -u <filename> : 두개 이상의 값들은 무시됙 하나의 값만 프린트된다</li>
<li>sort -k <num> <filename> : 각 줄을 띄워쓰기로 나눠 제일 왼쪽을 1열로 간주 하며, num 열의 인자들을 기준으로 정렬한다</li>
</ul>
<p>echo</p>
<ul>
<li>echo “something”</li>
<li>echo 뒤에 오는 글자를 그대로 출력한다</li>
</ul>
<p>locate</p>
<ul>
<li>locate <word></li>
<li>특정 단어를 포함한 파일, 디렉토리를 찾는 명령어</li>
<li>미리 파일의 데이터베이스를 만든 후 데이터베이스의 안을 찾는 원리</li>
<li>속도는 빠르나 업데이트가 필요하다</li>
<li>e : 데이터베이스가 업데이트 되지 않았을 때 실제로 존재하는 파일만 보여준다</li>
<li>i : 대소문자 무시</li>
<li>l or –limit : 표시할 파일의 수 제한</li>
</ul>
<p>find</p>
<ul>
<li>find <dir></li>
<li>dir 아래 있는 모든 파일, 폴더를 보여준다</li>
<li>type f : 파일만 보여준다</li>
<li>type d : 폴더만 보여준다</li>
<li>name “name” : name 과 일치하는 요소만 보여준다, wildcard 를 사용하면 좋다</li>
<li>size <size> : size 에 맞는 파일을 찾아준다, +1G 처럼 1gb 이상, -50M 처럼 50mb 이하 로 검색할 수 있다</li>
<li>user <username> : 주인이 username 인 요소를 보여준다</li>
<li><timestamp> <num> : timestamp 에는 mmin, cmin, amin 등 기준으로 사용할 단위가, num 에는 30, -30, +30 등 숫자가 들어간다, 기호는 이상, 이하를 나타낸다</li>
<li>[a, c, m]newer file : anewer, cnewer, mnewer, 각각 타임스템프를 기준으로 최근데 수정된 파일을 보여준다</li>
<li>조합하기
<ul>
<li>find … | wc -l 을 하면 찾은 요소들의 갯수를 보여준다</li>
</ul>
</li>
<li>time stemp
<ul>
<li>mtime : modification time, 수정 시간, 파일의 내용이 수정되었을 때 변경</li>
<li>ctime : change time, 변경 시간, 파일의 소유자, 크기, 권한 등 속성값의 변화가 있을때 변경</li>
<li>atime : access time, 접근 시간, cat, less 등을 포함해 파일에 접근만 하여도 변경</li>
</ul>
</li>
<li>논리식
<ul>
<li>and : 조건에 and 를 사용, 사실 쓰지 않아도 적용되고 있었음</li>
<li>or : 조건에 or 를 사용</li>
<li>not : 다음으로 나오는 조건에 not 을 사용</li>
</ul>
</li>
<li>exec
<ul>
<li>find -exec command ‘{}’ ‘;’</li>
<li>{} 안에는 찾아낸 파일, 폴더의 경로가 들어가게 된다</li>
<li>처럼 찾아낸 전체를 넣는 것이 아닌 각각의 경로를 넣어서 다음 명령어를 실행한다</li>
<li>{} 와 ; 는 ’ ’ 로 감싸준다</li>
<li>exec cp ‘{}’ ‘{}_cp’ ‘;’ 처럼 사용하여 path 를 path_cp 로 변환해 저장 할 수 있다</li>
</ul>
</li>
</ul>
<p>xargs</p>
<ul>
<li>xargs command</li>
<li>파이프 라인에서 들어오는 표준 출력을 공백문자로 나눈 뒤 각각의 요소를 command 로 처리한다</li>
<li>echo “hello” “world” | xargs mkdir 을 하게되면 각각 hello 와 world 폴더가 생성된다</li>
<li>find 에서 -exec 를 사용하면 각각의 줄이 커맨드를 만나게 된다</li>
<li>와 xargs 를 사용해 같은 효과를 만들 수 있다</li>
<li>find -name “*.txt” - exec ls ‘{}’ ‘;’ 를</li>
<li>find -name “*.txt” | xargs ls 로</li>
</ul>
<p>grep</p>
<ul>
<li>grep &lt;pattern(word)&gt; <file></li>
<li>파일의 내용에서 특정 패턴을 검색한다</li>
<li>해당 패턴(단어)이 들어있는 줄을 출력해준다</li>
<li>i : 대소문자 무시</li>
<li>w : 문자 단위가 아닌 단어 단위 검색, 앞뒤가 공백문자여야한다</li>
<li>r : 현재 디렉토리에서 하위에 있는 모든 파일을 재귀적으로 확인한다, 파일이름을 명시할 필요가 없다</li>
<li>regex 를 이용
<ul>
<li>grep ‘[1-9]….’ file.txt</li>
<li>1에서 9까지의 숫자 네개가 연달아 나오는 글자가 있는 줄 탐색</li>
</ul>
</li>
<li>c : 숫자를 문자로써가 아닌 숫자로써 작용하도록 함
<ul>
<li>grep -c “$[1-9]” file.txt</li>
<li>$ 다음에 1~9의 숫자가 오는 줄 탐색</li>
</ul>
</li>
<li>o : 문자를 포함하는 줄이 아닌 해당하는 그 문자만 출력</li>
<li>piping to grep
<ul>
<li>파이프라인을 이용해 이전 커맨드의 출력에서 원하는 결론 도출</li>
</ul>
</li>
</ul>
<p>chmod</p>
<ul>
<li>chmod <mode> <fildnema></li>
<li>권한의 변경</li>
<li>u = user</li>
<li>g = group</li>
<li>o = other(world)</li>
<li>a = all</li>
<li>: 해당 권한 박탈</li>
<li>
<ul>
<li>: 해당 권한 부여</li>
</ul>
</li>
<li>= : 해당 권환으로 전환</li>
<li>ex) chmod u+r file.txt 해당 파일의 소유자에게 읽기권한 부여</li>
<li>ex) chmod a=x file.txt 해당 파일에 접근 하는 모두를 –x 권한으로 변경</li>
<li>octal
<ul>
<li>rwx 를 각각 이진수로 보고 팔진법으로 변환</li>
<li>ex) chmod 777 file.txt : 7 은 rwx 이므로 rwxrwxrwx 로 변환</li>
</ul>
</li>
</ul>
<p>chown</p>
<ul>
<li>chown :GROUP file.txt</li>
<li>파일의 소유그룹은 변경한다</li>
</ul>
<p>groups</p>
<ul>
<li>컴퓨터에 있는 그룹을 보여준다</li>
<li>groups <username> 을 하면 해당 유저의 그룹을 보여준다</li>
</ul>
<p>addgroup</p>
<ul>
<li>addgroup <groupname></li>
<li>해당 그룹을 생성한다</li>
</ul>
<p>adduser</p>
<ul>
<li>adduser USER GROUP</li>
<li>해당 그룹에 유저를 추가한다</li>
</ul>
<p>printenv</p>
<ul>
<li>모든 환경변수를 보여준다</li>
<li>명령어에서 $USER 와 같이 사용하면 $ 뒤에 붙은 단어가 변수명인 환경변수의 값이 대입된다</li>
<li>환경변수는 터미널에서 a=b 처럼 만들 수 있다</li>
</ul>
<p>alias</p>
<ul>
<li>alias <a>=<b></li>
<li>해당 커맨드를 입력 한 후에는 a 를 치면 b 를 친것으로 간주한다, 즉 a 를 치면 b 가 대입된다</li>
</ul>
<p>tr</p>
<ul>
<li>tr <str1> <str2></li>
<li>str1 의 char 들을 str2 의 char 들로 치환한다</li>
<li>ex) tr “asd” “qwe” 일때, a 는 q 로, s 는 w 로, d 는 e 로 바뀐다</li>
<li>c <str1> <str2> : str1 에 있는 char 들을 제외한 다른 문자들을 str2 로 바꾼다, 이때 str2 가 문자열이면 마지막 문자로 바뀐다</li>
<li>d <str> : str 에 있는 문자들을 지운다</li>
<li>s <str> : str 에 있는 문자들이 연속으로 나올 시 이를 정리하여 한번만 나오게 출력한다</li>
<li>c 와 d 를 조합하면 해당 문자를 제외한 모든 문자가 지워진다, 이런식으로 조합이 가능</li>
</ul>
<p>ifconfig</p>
<ul>
<li>네트워크 상태를 확인할 수 있다</li>
</ul>
<p>awk</p>
<ul>
<li>awk [옵션] ‘패턴, {액션}’ <filename></li>
<li>프로그래밍 언어라고 할 정도로 데이터 조작에 많은 기능을 가지고 있음</li>
<li>액션이 생략되면 default 액션인 print 가 작동</li>
<li>패턴이 생략되면 모든 데이터에 대해 액션이 작동</li>
<li>필드 : 데이터의 열 방향, 세로방향의 데이터, 첫번째 열부터 $1, $2… 로 명시, 마지막 열은 $NF 로 명시할 수 있다</li>
<li>레코드 : 데이터의 행 방향, 가로방향의 데이터, 첫번째 행부터 NR=1, NR=2…로 명시</li>
<li>패턴과 액션의 예
<ul>
<li>‘{print $1}’ 1열의 데이터를 출력한다</li>
<li>‘NR==2{print $2, $5}’ 2행 2열과 2행 5열의 데이터를 출력한다</li>
<li>‘/^bs/{print $2}’ bs로 시작하는 문자열이 있는 행(레코드)를 찾아 해당 행의 2열의 데이터를 출력한다</li>
<li>‘/as/{print $1+2}’ as 가 들어가는 문자열이 있는 행의 1번째 열의 값에 2를 더하여 출력하라</li>
</ul>
</li>
<li>{} 안에 printf 함수를 사용할 수 있다
<ul>
<li>함수에 들어가는 인자는 위와 같이 $2 같이 사용할 수 있다</li>
</ul>
</li>
<li>END
<ul>
<li>‘{sum+=$5}END{print sum}’ : 5열의 값을 전부 더해 sum에 저장</li>
</ul>
</li>
</ul>
<p>basename</p>
<ul>
<li>basename <filename></li>
<li>파일의 경로에서 경로를 제외하고 파일명만 출력해주는 커맨드</li>
<li>a : 여러 파일의 경로를 넣어서 각가 처리를 하게 하도록 한다</li>
<li>s &lt;확장자&gt; : -s .c 처럼 확장자를 넣으면 해당 확장자가 지워져서 출력된다</li>
<li>z :결과물이 개행으로 구분되지 않고 붙어나옴</li>
</ul>
<p>dirname</p>
<ul>
<li>dirname <filename></li>
<li>파일의 경로를 넣으면 파일 이름이 제거되고 경로만 남게된다</li>
<li>filename 과 달리 여러 파일의 경로를 넣을 수 있다</li>
<li>z : 결과가 개행으로 구분되지 않는다</li>
</ul>
<p>sed</p>
<ul>
<li>sed ‘s/str1/str2/g’ <filename></li>
<li>앞의 s 는 전체 범위를 나타내며 특정 범위로 조작 가능</li>
<li>뒤의 g 는 모든 줄을 나타내며 생략시 첫 줄에서만 작업이 진행됨</li>
<li>tr 과 다르게 각각의 char 로 적용을 하는 것이 아니라 하나의 문자열 단위로 작업이 진행 됨</li>
</ul>
<p>bc / dc</p>
<ul>
<li>계산기 기능</li>
<li>파이프라인으로 수식을 넣으면 계산값을 출력한다</li>
<li>bc 는 중위표기방식, dc 는 후위표기방식을 지원한다</li>
</ul>
<p>;</p>
<ul>
<li>command1 ; command2</li>
<li>세미콜론</li>
<li>기타 다은 언어와 마찬가지로 명령어가 끝나는 부분에 넣어 명령어를 구분해 준다</li>
<li>여러 명령어를 순차적으로 실행시킬 때 사용</li>
<li>이전 커맨드가 실패해도 아후 커맨드가 작동함</li>
</ul>
<p>&amp;&amp;</p>
<ul>
<li>command1 &amp;&amp; command2</li>
<li>; 과 같이 순차적으로 작동</li>
<li>; 와 달리 이전 커맨드가 실패할 경우 이후 커맨드가 작동하지 않음</li>
</ul>

        </article>
        
        
    </main>

    

<footer>
    <p>
        Author: Dongyoon Kim - <a href="https://biisairo.github.io/">Home</a> - <a href="https://github.com/Biisairo">GitHub</a> - <a
            href="mailto:rlark1224@naver.com">Mail</a>
    </p>
    <img src="https://hits.sh/biisairo.github.io.svg?label=Visitor&color=000000">
</footer>

</body>

</html>