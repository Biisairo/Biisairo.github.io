<!DOCTYPE html>



<html>

<head>
    <meta charset="UTF-8">
    <title>5 프로세스 관리</title>
    <link rel="icon" href="https://biisairo.github.io/static/favicon.ico" type="image/x-icon">
</head>

<script>
    function toggleSection(id) {
        const section = document.getElementById(id);
        const header = section.previousElementSibling;

        if (section.style.display === 'none') {
            section.style.display = 'block';
            header.innerHTML = header.innerHTML.replace('▶', '▼');
        } else {
            section.style.display = 'none';
            header.innerHTML = header.innerHTML.replace('▼', '▶');
        }
    }
</script>

<body>
    <header>
    <nav>
        <ul>
            

            <li><a href="https://biisairo.github.io/">Home</a></li>
            
            <li><a href="https://biisairo.github.io/About/">About</a></li>
            
            <li><a href="https://biisairo.github.io/Study/">Study</a></li>
            
            <li><a href="https://biisairo.github.io/Contact/">Contact</a></li>
            
        </ul>
    </nav>

    <style>
    html,
    body {
        height: 100%;
        margin: 0;
    }

    body {
        display: flex;
        flex-direction: column;
        max-width: 720px;
        margin: 0 auto;
        padding: 2rem 1rem;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
            Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        line-height: 1.6;
        background: #222831;
        color: #EEEEEE;
    }

    header,
    footer {
        text-align: center;
        margin-bottom: 2rem;
    }

    nav ul {
        list-style: none;
        padding: 0;
        display: flex;
        justify-content: space-between;
        align-items: flex-end;

        flex-wrap: wrap;
        gap: 1rem;
    }

    nav li:first-child {
        margin-right: auto;
    }

    nav li:not(:first-child) {
        margin-left: 0;
    }

    nav li:first-child a {
        color: #EEEEEE;
        font-size: 1.5em;
        text-decoration: none;
    }

    nav li:first-child a:hover {
        color: #aadadf;
    }

    nav a {
        color: #00ADB5;
        text-decoration: underline;
        transition: color 0.3s ease;
    }

    nav a:hover {
        color: #66C1C9;
        text-decoration: none;
    }

    main a,
    article a,
    footer a {
        color: #33d3c8;
        text-decoration: underline;
        transition: color 0.3s ease;
    }

    main a:hover,
    article a:hover,
    footer a:hover {
        color: #66C1C9;
        text-decoration: none;
    }

    main {
        flex: 1;
        margin-bottom: 2rem;
    }

    h1,
    h2,
    h3 {
        line-height: 1.3;
        margin-top: 2rem;
        margin-bottom: 1rem;
        color: #00ADB5;
    }

    h2[onclick] {
        user-select: none;
        color: #2699b6;
    }


    ul {
        padding-left: 1.5rem;
    }

    article {
        margin-top: 2rem;
        border: 1px solid #33d3c8;
        padding: 1rem;
        border-radius: 5px;
    }

    footer p {
        font-size: 0.9rem;
        color: #AAAAAA;
    }
</style>

</header>

    <main>
        
        
        

        
        <h2 onclick="toggleSection('pages')" style="cursor: pointer;">▶ 하위 페이지</h2>
        <div id="pages" style="display: none;">
            <ul>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/2%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%20%ea%b0%9c%ec%9a%94.html">2 운영체제 개요</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/3%20%ec%bb%b4%ed%93%a8%ed%84%b0%20%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98%20%eb%8f%99%ec%9e%91%20%ec%9b%90%eb%a6%ac.html">3 컴퓨터 시스템의 동작 원리</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/4%20%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8%ec%9d%98%20%ea%b5%ac%ec%a1%b0%ec%99%80%20%ec%8b%a4%ed%96%89.html">4 프로그램의 구조와 실행</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/5%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%ea%b4%80%eb%a6%ac.html">5 프로세스 관리</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/6%20CPU%20%ec%8a%a4%ec%bc%80%ec%a4%84%eb%a7%81.html">6 CPU 스케줄링</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/7%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%ea%b4%80%eb%a6%ac.html">7 메모리 관리</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/8%20%ea%b0%80%ec%83%81%eb%a9%94%eb%aa%a8%eb%a6%ac.html">8 가상메모리</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/9%20%eb%94%94%ec%8a%a4%ed%81%ac%20%ea%b4%80%eb%a6%ac.html">9 디스크 관리</a></li>
                
            </ul>
        </div>
        

        
        
        <article>
            <h1>5. 프로세스 관리</h1>
<h2>1. 프로세스의 개념</h2>
<ul>
<li>프로세스
<ul>
<li>실행중인 프로그램</li>
</ul>
</li>
<li>문맥 (context)
<ul>
<li>프로세스가 어떤 상태에서 수행되고 있는지 정확히 규명하기 위한 정보</li>
<li>시분할 환경에서 cpu 제어권을 뺏겼다가 다시 획득하며 다시 수행을 재개하는 시점에 이전의 수행 상태를 그대로 복구하기 위한 정보</li>
<li>프로세스의 주소공간(코드, 데이터, 스택의 상태), 레지스터에서 가지고 있던 값, 시스템 콜 등을 이용해 커널에서 수행한 일의 상태, 프로세스에 관해 커널에서 관리하고있던 정보 등</li>
<li>하드웨어 문맥
<ul>
<li>cpu 의 수행상태</li>
<li>프로그램 카운터의 값</li>
<li>각종 레지스터에 저장되어 있던 값</li>
</ul>
</li>
<li>프로세스의 주소공간
<ul>
<li>코드, 데이터, 스택으로 구성된 독자적인 주소공간</li>
</ul>
</li>
<li>커널상의 문맥
<ul>
<li>운영체제에서 프로세스를 관리하기 위한 자료구조</li>
<li>PCB</li>
<li>커널스택</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>2. 프로세스의 상태</h2>
<ul>
<li>실행 (running)
<ul>
<li>프로세스가 cpu 를 보유하고 명령을 실행 중인 상태</li>
</ul>
</li>
<li>준비 (ready)
<ul>
<li>cpu 만 보유하면 당장 명령을 실행시킬 수 있는 상태</li>
</ul>
</li>
<li>봉쇄 (blocked, wait, sleep)
<ul>
<li>cpu 를 할당 받더라도 명령을 실행 시킬 수 없는 상태</li>
<li>ex)
<ul>
<li>입출력 작업이 진행중인상태</li>
</ul>
</li>
</ul>
</li>
<li>시작 (new)
<ul>
<li>프로세스가 생성중인 상태</li>
<li>프로세스가 시작되어 프로세스를 위한 자료구조가 생성되었으나 메모리를 할당을 승인받지 못한 상태</li>
</ul>
</li>
<li>완료 (terminated)
<ul>
<li>프로세스가 종료중인 상태</li>
<li>프로세스가 종료되었으나 운영체제가 프로세스와 관련된 자료구조를 완전히 정리하지 못한 상태</li>
</ul>
</li>
<li>문맥 교환 (context switch)
<ul>
<li>다른 프로세스를 수행하기 위해 원래 수행중이던 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 과정</li>
</ul>
</li>
<li>CPU 디스패치 (dispatch)
<ul>
<li>준비상태에 있는 프로세스 중에 cpu 를 할당 받을 프로세스를 선택하고 cpu 의 제어권을 넘겨받는 과정</li>
</ul>
</li>
</ul>
<h2>3. 프로세스 제어블록</h2>
<ul>
<li>프로세스 제어블록 (process control block : PCB)</li>
<li>구성 요소
<ul>
<li>프로세스의  상태 (process state)
<ul>
<li>cpu 를 할당해도 되는지 여부</li>
</ul>
</li>
<li>프로그램 카운터 (program counter) 값
<ul>
<li>다음에 수행할 명령의 위치</li>
</ul>
</li>
<li>CPU 레지스터 (CPU register) 값
<ul>
<li>연산을 위해 현 시점에 레지스터에 저장된 값</li>
</ul>
</li>
<li>CPU 스케줄링 정보 (CPU scheduling information)</li>
<li>메모리 관리 정보 (memory management information)</li>
<li>자원 사용 정보 (accounting information)</li>
<li>입출력 상태 정보 (I/O status information)</li>
</ul>
</li>
</ul>
<h2>4. 문맥 교환</h2>
<ul>
<li>하나의 프로세스로 부터 다른 프로세스로 cpu 제어권이 이양되는 과정</li>
<li>수행중이던 프로세스의 정보를 PCB 에 담고 준비상태로 바뀌며</li>
<li>수행하려고 하는 프로세스는 PCB 에서 하드웨어로 데이터를 복원하고 실행상태가 됨</li>
<li>인터럽트가 발생해도 cpu 의 제어권이 운영체제로 이양되나 이는 프로세스의 실행 모드가 사용자모드에서 커널모드로 바뀌는 것 뿐 문맥 교환이 일어났다고 하지 않는다</li>
<li>모드변경에 비해 문맥 교환에서는 더 많은 오버헤드 (overhead) 가 생긴다</li>
<li>cpu 타이머에 너무 작은 시간을 주게 되면 잦은 문맥 교환이 일어나 너무 많은 오버헤드가 생기며</li>
<li>너무 큰 시간을 주게되면 스케줄링에 실패하게 된다</li>
</ul>
<h2>5. 프로세스를 스케줄링 하기 위한 큐</h2>
<ul>
<li>준비 큐 (ready queue)
<ul>
<li>cpu 사용을 기다리는 프로세스들의 큐</li>
<li>제일 앞에 있는 프로세스에 우선적으로 cpu 를 할당한다</li>
</ul>
</li>
<li>장치 큐 (device queue)
<ul>
<li>각각의 입출력장치를 사용하기 위한 큐</li>
<li>프로세스들이 입출력 장치의 사용이 필요할때 줄세우기 위한 큐 이다</li>
<li>프로세스가 요청한 작업이 끝나면 장치 컨트롤러가 cpu 에 인터럽트를 발생시키고 처리가 완료된 프로세스는 입출력 큐 에서 빠져나와 cpu 의 준비 큐에 들어가 cpu 할당을 기다림</li>
</ul>
</li>
<li>공유데이터 접근을 위한 큐
<ul>
<li>공유데이터를 동시 접근하면 일관성이 훼손될 수 있음</li>
<li>매 시점 하나의 프로세스만 접근해야하며 이를 위한 큐가 존재</li>
<li>하나의 프로세스가 자원을 취득, 사용, 반환할때까지 다른 프로세스의 접근을 막음</li>
</ul>
</li>
<li>작업 큐 (job queue)
<ul>
<li>시스템 내의 모든 프로세스를 관리하기 위한 큐</li>
<li>작업 상태와 무관하게 시스템 내의 모든 프로세스가 들어가게 됨</li>
</ul>
</li>
<li>준비 상태에 있는 프로세스는 준비큐에, 봉쇄 상태에 있는 프로세스는 장치 큐에 들어있음</li>
<li>상태 변화에 따라 각 큐를 오가며 실행되며 실행중인 모든 프로세스는 작업 큐에서 관리됨</li>
</ul>
<h2>6. 스케줄러</h2>
<ul>
<li>스케줄러 (scheduler)
<ul>
<li>어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 코드</li>
</ul>
</li>
<li>장기 스케줄러 (long term scheduler), 작업 스케줄러 (job scheduler)
<ul>
<li>어떤 프로세스를 준비 큐에 진입시킬지를 결정</li>
<li>준비 큐에 있는 프로세스들은 cpu 를 할당 받기만 하면 수행될 수 있는 프로세스이며 cpu 에서 실행되기 위해서는 프로세스가 메모리에 올라가있어야함</li>
<li>장기 스케줄러는 프로세스에게 메모리를 할당하는 문제에 관여</li>
<li>시작상태의 프로세스들 중 어떤 프로세스를 준비큐에 삽입할지를 관여</li>
<li>메모리에 동시에 올라가 있는 프로세스의 수(degree of multiprogramming)를 조절</li>
<li>시작 상태의 프로세스에게 메모리 할당을 승인할지 여부를 결정함</li>
</ul>
</li>
<li>단기 스케줄러 (short term scheduler), CPU 스케줄러
<ul>
<li>준비상태의 프로세스 중 어떤 프로세스를 다음으로 실행상태로 만들지를 결정</li>
<li>준비 큐의 어떤 프로세스에게 cpu 를 할당할지를 결정</li>
<li>시분할 시스템에서 타이머 인터럽트가 발생하면 단기 스케줄러가 호출됨</li>
</ul>
</li>
<li>중기 스케줄러 (medium term scheduler)
<ul>
<li>과거의 시분할 시스템에서는 적은 양의 메모리때문에 많은 프로세스가 메모리에 올라가기 힘들었기에 장기 스케줄러를 사용</li>
<li>지금의 시분할 시스템에서는 프로세스가 실행되면 장기 스케줄러 없이 곧바로 메모리를 할당 해 준비 큐에 넣게 됨</li>
<li>너무 많은 프로세스에게 메모리가 할당 되어 생기는 시스템 성능저하를 해결하기 위한 스케줄러</li>
<li>메모리에 적재된 프로세스의 수를 동적으로 조절</li>
<li>너무 많은 프로세스가 메모리에 올라가 있으면 cpu 수행에 필요한 메모리조차 없어지게 되며 보조기억장치와의 입출력이 많아져 속도가 느려지게 됨</li>
<li>이때 중기 스케줄러가 메모리에 올라가 있는 프로세스중 일부를 통채로 스왑 영역에 올리게됨
<ul>
<li>스왑 아웃 (swap out) 이라고 함</li>
</ul>
</li>
<li>스왑 아웃의 0순위 프로세스는 봉쇄 상태의 프로세스</li>
<li>이후에도 메모리 공간이 부족한 경우 타이머 인터럽트로 인해 준비 큐로 넘어가는 프로세스를 스왑 아웃 시킴</li>
</ul>
</li>
<li>중지 (suspended, stopped) 상태
<ul>
<li>중기 스케줄러로 인해 외부적인 이유로 프로세스의 수행이 정지된 상태</li>
<li>외부에서 다시 재개시키기 전에는 다시 활성화 되지 않음</li>
<li>메모리를 통채로 빼앗기고 스왑 아웃 된 상태</li>
<li>중지준비 상태
<ul>
<li>준비 상태에 있던 프로세스가 중기 스케줄러에 의해 스왑 아웃 된 상태</li>
</ul>
</li>
<li>중지봉쇄 상태
<ul>
<li>봉쇄 상태에 있던 프로세스가 중기 스케줄러에 의해 스왑 아웃 된 상태</li>
<li>봉쇄 되었던 조건을 만족하면 중지준비 상태로 변환</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>7. 프로세스의 생성</h2>
<ul>
<li>부모 프로세스
<ul>
<li>프로세스를 생성한 프로세스</li>
</ul>
</li>
<li>자식 프로세스
<ul>
<li>프로세스에 의해 생성된 프로세스</li>
</ul>
</li>
<li>자식프로세스가 먼저 죽게되며 부모프로세스는 죽은 자식프로세스의 처리를 담당</li>
<li>프로세스 자원의 획득
<ul>
<li>운영체제로 부터 직접 획득</li>
<li>부모의 자원을 공유</li>
</ul>
</li>
<li>프로세스 모델
<ul>
<li>부모와 자식이 공존
<ul>
<li>부모와 자식이 같이 cpu 를 사용하는 경쟁관계가 됨</li>
</ul>
</li>
<li>자식이 종료(terminate)될 때 까지 부모가 기다림(wait)
<ul>
<li>자식이 종료될 때 까지 부모가 봉쇄상태에 머뭄</li>
</ul>
</li>
</ul>
</li>
<li>프로세스가 생성되면 별도의 주소공간을 가짐</li>
<li>자식 프로세스가 생성되면 부모 프로세스의 주소공간을 그대로 복사해서 생성하게 됨
<ul>
<li>fork 를 하게 되면 프로세스 ID 를 제외한 모든 데이터를 자식 프로세스의 주소공간에 복사하게 됨</li>
</ul>
</li>
<li>원칙적으로 부모 프로세스가 종료되기 위해서는 그 아래의 자식 프로세스들이 모두 종료되어야 함</li>
<li>프로세스의 종료방법
<ul>
<li>프로세스가 운영체제에 종료를 알려 이루어지는 자발적 종료
<ul>
<li>프로세스가 명령을 모두 수행한 후 프로그램의 종료 시 exit() 시스템 콜 함수를 호출</li>
<li>종료를 통보받은 운영체제는 프로세스로 부터 자원을 회수하고 시스템 내에서 정리하게 됨</li>
<li>exit() 함수는 프로그래머의 명시 없이도 프로그램의 종료시에 자동으로 호출 됨</li>
</ul>
</li>
<li>부모 프로세스가 자식 프로세스를 강제종료 시키는 방법
<ul>
<li>abort() 함수를 통해 이뤄짐</li>
<li>자식 프로세스가 할당 자원의 한계치를 넘어서는 많은 양의 자원을 요구할 때</li>
<li>자식 프로세스에게 할당된 작업이 더이상 필요하지 않을 때</li>
<li>부모 프로세스가 종료되는 경우</li>
</ul>
</li>
</ul>
</li>
<li>사용자가 로그아웃 된 이후에도 프로세스를 계속 수행시켜야 하는 경우
<ul>
<li>로그아웃 후에도 존재하는 프로세스의 자식으로 해당 프로세스를 이양시킴</li>
</ul>
</li>
<li>fork() 함수
<ul>
<li>프로세스가 fork() 시스템 콜 함수를 호출</li>
<li>cpu 의 제어권이 커널로 넘어감</li>
<li>운영체제가 fork() 를 호출한 프로세스를 복제해 자식 프로세스를 생성</li>
<li>fork() 를 이용해 복제를 하게 되면 원래의 코드와 완벽히 같은 코드를 실행하게 됨</li>
</ul>
</li>
<li>exec() 함수
<ul>
<li>exec() 함수를 통해 복제된 프로세스를 덮어쓰기 함</li>
<li>exec() 시스템 콜 함수를 호출하면 해당 프로세스가 exec() 에서 실행하는 프로세스로 바뀌게 됨</li>
</ul>
</li>
<li>wait() 함수
<ul>
<li>부모 프로세스가 자식 프로세스의 종료를 기다리며 봉쇄상태가 되게 됨</li>
<li>자식 프로세스가 종료되면 부모 프로세스를 준비상태로 변경</li>
</ul>
</li>
</ul>
<h2>8. 프로세스 간의 협력</h2>
<ul>
<li>프로세스는 각각 독립된 공간을 가지기 때문에 서로 소통할 수 없음</li>
<li>IPC (Inter-Process Communication)
<ul>
<li>하나의 컴퓨터 안에서 실행중인 두 프로세스간에 발생하는 통신</li>
</ul>
</li>
<li>메시지 전달 방식 (message passing)
<ul>
<li>공유 데이터를 사용하지 않고 메세지를 주고 받으며 통신하는 방법</li>
<li>커널이 두 프로세스의 메세지 전달을 도와줌</li>
<li>커널에서 send, recieve 연산을 제공</li>
<li>통신을 원하는 두 프로세스가 커뮤니케이션 링크(communication link)를 생성한 후 send() 와 recieve() 를 통해 메세지를 주고 받게됨</li>
<li>직접 통신(direct communication)
<ul>
<li>두 프로세스가 직접 메세지를 주고 받는 방식</li>
<li>send, recieve 에 상대 프로세스를 명시하여 상대에게 바로 보낸다</li>
</ul>
</li>
<li>간접 통신(indirect communication)
<ul>
<li>메일박스라는 저장공간을 이용해 메세지를 주고받는 방식</li>
<li>메일박스에 send, recieve를 하여 같은 메일박스를 공유중인 프로세스와 통신한다</li>
</ul>
</li>
</ul>
</li>
<li>공유메모리 방식 (shared memory)
<ul>
<li>프로세스가 주소공간의 일부를 공유한다</li>
<li>운영체제의 시스템 콜을 이용해 사용한다</li>
</ul>
</li>
<li>커널에서 프로세스간의 통신을 지원해 주나 서로의 동기화가 제대로 되지 않으면 데이터의 일관성 문제가 생길 수 있다</li>
<li>해당 문제는 커널에서 책임져 주지 않으며 프로세서에서 직접 컨트롤 해야 한다</li>
</ul>

        </article>
        
        
    </main>

    

<footer>
    <p>
        Author: Dongyoon Kim - <a href="https://biisairo.github.io/">Home</a> - <a href="https://github.com/Biisairo">GitHub</a> - <a
            href="mailto:rlark1224@naver.com">Mail</a>
    </p>
    <img src="https://hits.sh/biisairo.github.io.svg?label=Visitor&color=000000">
</footer>

</body>

</html>