<!DOCTYPE html>



<html>

<head>
    <meta charset="UTF-8">
    <title>2 운영체제 개요</title>
    <link rel="icon" href="https://biisairo.github.io/static/favicon.ico" type="image/x-icon">
</head>

<script>
    function toggleSection(id) {
        const section = document.getElementById(id);
        const header = section.previousElementSibling;

        if (section.style.display === 'none') {
            section.style.display = 'block';
            header.innerHTML = header.innerHTML.replace('▶', '▼');
        } else {
            section.style.display = 'none';
            header.innerHTML = header.innerHTML.replace('▼', '▶');
        }
    }
</script>

<body>
    <header>
    <nav>
        <ul>
            

            <li><a href="https://biisairo.github.io/">Home</a></li>
            
            <li><a href="https://biisairo.github.io/About/">About</a></li>
            
            <li><a href="https://biisairo.github.io/Study/">Study</a></li>
            
            <li><a href="https://biisairo.github.io/Contact/">Contact</a></li>
            
        </ul>
    </nav>

    <style>
    html,
    body {
        height: 100%;
        margin: 0;
    }

    body {
        display: flex;
        flex-direction: column;
        max-width: 720px;
        margin: 0 auto;
        padding: 2rem 1rem;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
            Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        line-height: 1.6;
        background: #222831;
        color: #EEEEEE;
    }

    header,
    footer {
        text-align: center;
        margin-bottom: 2rem;
    }

    nav ul {
        list-style: none;
        padding: 0;
        display: flex;
        justify-content: space-between;
        align-items: flex-end;

        flex-wrap: wrap;
        gap: 1rem;
    }

    nav li:first-child {
        margin-right: auto;
    }

    nav li:not(:first-child) {
        margin-left: 0;
    }

    nav li:first-child a {
        color: #EEEEEE;
        font-size: 1.5em;
        text-decoration: none;
    }

    nav li:first-child a:hover {
        color: #aadadf;
    }

    nav a {
        color: #00ADB5;
        text-decoration: underline;
        transition: color 0.3s ease;
    }

    nav a:hover {
        color: #66C1C9;
        text-decoration: none;
    }

    main a,
    article a,
    footer a {
        color: #33d3c8;
        text-decoration: underline;
        transition: color 0.3s ease;
    }

    main a:hover,
    article a:hover,
    footer a:hover {
        color: #66C1C9;
        text-decoration: none;
    }

    main {
        flex: 1;
        margin-bottom: 2rem;
    }

    h1,
    h2,
    h3 {
        line-height: 1.3;
        margin-top: 2rem;
        margin-bottom: 1rem;
        color: #00ADB5;
    }

    h2[onclick] {
        user-select: none;
        color: #2699b6;
    }


    ul {
        padding-left: 1.5rem;
    }

    article {
        margin-top: 2rem;
        border: 1px solid #33d3c8;
        padding: 1rem;
        border-radius: 5px;
    }

    footer p {
        font-size: 0.9rem;
        color: #AAAAAA;
    }
</style>

</header>

    <main>
        
        
        

        
        <h2 onclick="toggleSection('pages')" style="cursor: pointer;">▶ 하위 페이지</h2>
        <div id="pages" style="display: none;">
            <ul>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/2%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%20%ea%b0%9c%ec%9a%94.html">2 운영체제 개요</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/3%20%ec%bb%b4%ed%93%a8%ed%84%b0%20%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98%20%eb%8f%99%ec%9e%91%20%ec%9b%90%eb%a6%ac.html">3 컴퓨터 시스템의 동작 원리</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/4%20%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8%ec%9d%98%20%ea%b5%ac%ec%a1%b0%ec%99%80%20%ec%8b%a4%ed%96%89.html">4 프로그램의 구조와 실행</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/5%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%ea%b4%80%eb%a6%ac.html">5 프로세스 관리</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/6%20CPU%20%ec%8a%a4%ec%bc%80%ec%a4%84%eb%a7%81.html">6 CPU 스케줄링</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/7%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%ea%b4%80%eb%a6%ac.html">7 메모리 관리</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/8%20%ea%b0%80%ec%83%81%eb%a9%94%eb%aa%a8%eb%a6%ac.html">8 가상메모리</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/9%20%eb%94%94%ec%8a%a4%ed%81%ac%20%ea%b4%80%eb%a6%ac.html">9 디스크 관리</a></li>
                
            </ul>
        </div>
        

        
        
        <article>
            <h1>2. 운영체제 개요</h1>
<h2>1. 운영체제의 정의</h2>
<ul>
<li>operation system</li>
<li>컴퓨터에 전원을 키는 동시에 가장 먼저 시작되는 프로그램</li>
<li>운영체제 전부가 메모리에 올라가는 것이 아닌 필요한 부분을 그때그때 올려서 사용함</li>
<li>커널(kernel) - 항상 메모리에 상주하는 운영체제의 한 부분, 좁은 의미의 운영체제, 운영체제의 핵심</li>
<li>이외의 시스템을 위한 유틸리티 프로그램 - 넓은 의미의 운영체제</li>
</ul>
<h2>2. 운영체제의 기능</h2>
<ul>
<li>컴퓨터 하드웨어와 사용자 사이에 존재</li>
<li>하드웨어
<ul>
<li>사용자가 직접 다루기 힘든 하드웨어의 관리</li>
<li>컴퓨터 시스템의 자원(resource)관리</li>
</ul>
</li>
<li>사용자
<ul>
<li>인터페이스 제공</li>
<li>컴퓨터 시스템을 편하게 사용할 수 있는 환경 제공</li>
</ul>
</li>
<li>자원의 관리
<ul>
<li>사용자가 자원을 효율적으로 사용하여 최적의 컨디션을 낼 수 있도록 도와줌</li>
<li>사용자 및 프로그램간에 자원이 형평성있게 분배될 수 있도록 도와줌</li>
</ul>
</li>
<li>보안</li>
</ul>
<h2>3. 운영체제의 분류</h2>
<ul>
<li>동시 작업을 지원하는지 여부
<ul>
<li>단일작업(single tacking)용 운영체제
<ul>
<li>한번에 한가지 프로그램만 실행 가능</li>
</ul>
</li>
<li>다중작업(multi tasking)용 운영체제
<ul>
<li>한번에 여러가지 프로그램 실행 가능</li>
<li>여러 프로그램이 cpu 와 메모리를 공유하게 됨
<ul>
<li>CPU 시분할 시스템 (time sharing system)
<ul>
<li>cpu 는 하나밖에 없지만 순간적으로는 하나의 프로그램밖에 실행하지 못하나 수 ms 의 짧은 시간단위로 여러 프로그램들이 번갈아 실행됨</li>
<li>결과적으로 사용자는 여러 프로그램들이 동시 실행되는 것으로 느낌</li>
</ul>
</li>
<li>다중 프로그래밍 시스템 (multi-programming system)
<ul>
<li>여러 프로그램이 조금씩 메모리 공간을 보유하며 동시에 여러 프로그램이 메모리에 올라가 있게됨</li>
</ul>
</li>
<li>대화형 시스템 (interactive system)
<ul>
<li>여러 프로그램이 실행중이면서 사용자 개개인은 각 프로그램에 대한 입력을 즉각적으로 볼 수 있게됨</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>↔ 다중처리기 시스템 (multi-processer system)
<ul>
<li>하나의 컴퓨터 안에 여러개의 cpu 가 설치된 경우</li>
<li>여러개의 cpu 에서 여러 프로그램들이 동시 실행됨</li>
</ul>
</li>
</ul>
</li>
<li>다중 사용자에 대한 동시 지원 여부
<ul>
<li>단일 사용자용 운영체제
<ul>
<li>한번에 한명의 사용자가 사용</li>
</ul>
</li>
<li>다중 사용자용 운영체제
<ul>
<li>한번에 여러명의 사용자가 사용</li>
<li>ex) 서버</li>
</ul>
</li>
</ul>
</li>
<li>작업을 처리하는 방식
<ul>
<li>일괄처리 방식
<ul>
<li>요청된 작업을 일정량씩 모아 한번에 처리</li>
<li>처리할 작업을 모아서 한번에 처리 후 결과를 받아냄</li>
<li>응답 시간이 길다</li>
<li>ex) 펀치카드를 디용한 컴퓨터</li>
</ul>
</li>
<li>시분할 방식
<ul>
<li>여러 작업을 수행할 때 컴퓨터의 처리능력을 시간단위로 분할해 사용</li>
<li>요청에 대한 결과를 즉각적으로 얻을 수 있다 → 대화형 시스템</li>
</ul>
</li>
<li>실시간(real time) 운영체제
<ul>
<li>정해진 시간안에 어떠한 일이 반드시 처리됨을 보장해야 하는 시스템</li>
<li>일정 시간안에 작업이 완료되지 못할 경우에는 동작이 되지 않거나 위험을 초래할 수 있는 경우</li>
<li>경성 실시간 시스템
<ul>
<li>주어진 시간을 지키지 못할 경우 위험을 초래할 수 있는 시스템</li>
<li>ex) 원자로, 로켓제어 등</li>
</ul>
</li>
<li>연성 실시간 시스템
<ul>
<li>시간단위로 전달되어야 올바른 기능을 수행 할 수 있는 시스템</li>
<li>ex) 실시간 스트리밍 등</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>4. 운영체제의 예</h2>
<ul>
<li>윈도우
<ul>
<li>MS-DOS 와 윈도우 3.1 을 발전시킨 개인용 운영체제</li>
<li>DOS 위에서 사용되는 것이 아닌 독립적인 운영체제로서 작동하도록 만들어 진 것이 윈도우 95 이후</li>
<li>플러그 앤 플레이 (plug and play) 지원 - 외부 하드웨어를 장착하면 감지 후 자동적으로 사용 할 수 있도록 설정</li>
<li>윈도우 사용자 간의 네트워크 프로그램 사용</li>
<li>누구든지 쉽게 사용하는 것이 목적</li>
<li>
<ul>
<li>윈도우 NT - 안정성이 높고 다중사용자용 운영체제로 사용됨</li>
</ul>
</li>
</ul>
</li>
<li>유닉스
<ul>
<li>벨 연구소에서 개발</li>
<li>프로그램 개발을 위해 설계됨</li>
<li>오픈소스</li>
<li>커널의 크기가 작음</li>
<li>이식성이 좋음
<ul>
<li>당시 운영체제가 대부분 어셈블리로 작성된 것에 비해 대부분의 코드가 C 로 작성됨</li>
<li>사람이 이해하기 쉽고 다른 기종에 이식하기도 쉬워짐</li>
</ul>
</li>
<li>안정성이 목적</li>
<li>
<ul>
<li>리눅스</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>5. 운영체제의 자원관리 기능</h2>
<ul>
<li>운영체제의 가장 핵심적인 기능</li>
<li>하드웨어 자원
<ul>
<li>cpu 와 메모리를 비롯한 주변장치, 입출력장치 등</li>
<li>한대의 cpu 와 한정된 메모리를 나누어 쓸 수 있도록해야함</li>
<li>입출력 장치의 관리</li>
<li>전원이 꺼지면 휘발되는 cpu 와 메모리의 특성상 보조 기억장치에 파일을 저장해야하며 이때 파일관리, 저장방식등을 관리</li>
</ul>
</li>
<li>CPU 스케줄링
<ul>
<li>하나의 cpu 에서 여러개의 프로세스가 수행될 수 있도록 cpu 를 관리 해 주어야 함</li>
<li>cpu 를 효율적으로 관리 하면서 특정 프로세스가 불이익을 당하지 않도록 하는 것</li>
<li>cpu 스케줄링 기법
<ul>
<li>선입선출 (First Come First Served: FCFS)
<ul>
<li>cpu 에 먼저 접근한 프로세스를 먼저 처리</li>
<li>장시간 cpu 를 사용하는 프로세스가 먼저 접근하면 뒤에 오는 프로세스들이 밀리게 됨</li>
</ul>
</li>
<li>라운드 로빈 (Round Robin)
<ul>
<li>위의 선입선출 기법의 단점을 해결</li>
<li>cpu 에 한번에 할당 받아 사용할 수 있는 시간을 제한함</li>
<li>긴 작업을 요하는 프로세스가 접근해도 정해진 시간이 지나면 cpu 의 사용을 멈추고 대기열로 돌아가게 됨</li>
</ul>
</li>
<li>우선순위 (Priority)
<ul>
<li>cpu 를 사용하기위해 대기중인 프로세스들에게 우선순위를 부여</li>
<li>우선 순위가 높은 프로세스먼저 할당</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>메모리 관리
<ul>
<li>메모리 - cpu 가 직접 접근할 수 있는 컴퓨터 내부의 기억장치</li>
<li>메모리의 어느 부분이 어느 프로그램에 의해 사용중인지를 주소를 사용해 파악</li>
<li>다수의 프로그램이 올라간 경우 프로그램간의 메모리를 침범하지 않도록 유지</li>
<li>메모리 관리 방식
<ul>
<li>고정 분할(fixes partition) 방식
<ul>
<li>메모리를 몇 개의 분할로 미리 나누어 관리</li>
<li>각각의 분할에 하나의 프로그램을 실행</li>
<li>미리 메모리를 나누어 두기에 사용할 수 있는 프로그램의 수를 제한하게 되며</li>
<li>나뉜 메모리보다 큰 프로그램을 실행할 수 없고</li>
<li>나뉜 메모리보다 작은 프로그램을 실행하면 메모리가 낭비됨
<ul>
<li>이때 남은 영역을 내부조각(internal fragmentation) 이라고 함</li>
</ul>
</li>
</ul>
</li>
<li>가변 분할(variable partition) 방식
<ul>
<li>매 시점 프로그램의 크기에 맞게 메모리를 분할해서 사용</li>
<li>물리적 메모리의 크기보다 큰 프로그램은 실행 불가</li>
<li>분할의 크기와 갯수가 동적으로 변하게 됨으로 관리가 필요함</li>
<li>내부조각은 발생하지 않으나 외부조각(external fragmentation) 이 발생함
<ul>
<li>프로그램이 할당되지는 않지만 남은 공간이 너무 작아 프로그램을 올리지 못하는 영역</li>
</ul>
</li>
</ul>
</li>
<li>가상메모리(virtual memory) 방식
<ul>
<li>모든 프로그램이 물리적 메모리의 주소와 별개의 0 부터 시작하는 가상 메모리 주소를 가짐</li>
<li>운영체제에서 해당 가상 주소를 물리적 메모리에 매핑시킴</li>
<li>메모리의 크기보다 큰 프로그램의 경우 프로그램의 모든 부분이 항상 실행되는 것이 아니므로 현재 사용중인 부분만 그때그때 메모리에 올리고 나머지 부분은 보조기억장치에 저장시킴
<ul>
<li>이때 사용되는 보조기억장치의 영역을 스왑 영역(swap area)이라고 부름</li>
</ul>
</li>
<li>프로그램을 실행 시키는 가상 메모리 주소공간은 페이지(page) 라는 동일한 크기로 분할되어 물리적 메모리와 스왑 공간에 저장됨</li>
<li>페이징
<ul>
<li>동일한 단위로 메모리를 나누는 기법</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>인터럽트 (interrupt)
<ul>
<li>주변장치들이 cpu 의 서비스가 필요할 때 발생시키는 신호</li>
<li>cpu 는 평소에는 스케줄링을 따라 일을 수행하다가 인터럽트가 발생하면 하던일을 멈추고 인터럽트에 의한 요청을 서비스 한다</li>
<li>ex
<ul>
<li>사용자가 키보드에 글자를 입력하면 키보드가 cpu 에 인터럽트를 발생시켜 사용자로부터 입력이 들어왔음을 알림</li>
</ul>
</li>
<li>인터럽트 처리를 끝낸 후 다시 원래의 하던 일을 실행
<ul>
<li>이를 위해 운영체제는 인터럽트가 들어오면 원래의 하던 작업의 상태를 저장</li>
</ul>
</li>
<li>인터럽트 처리 루틴
<ul>
<li>인터럽트가 발생했을 때 해주어야 할 작업을 정의한 프로그램 코드</li>
</ul>
</li>
</ul>
</li>
</ul>

        </article>
        
        
    </main>

    

<footer>
    <p>Author: Dongyoon Kim - <a href="https://biisairo.github.io/">Home</a> - <a href="https://github.com/Biisairo">GitHub</a> - <a
            href="mailto:rlark1224@naver.com">Mail</a></p>
</footer>

</body>

</html>