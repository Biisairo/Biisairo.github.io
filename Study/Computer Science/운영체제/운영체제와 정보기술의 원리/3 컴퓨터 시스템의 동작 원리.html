<!DOCTYPE html>



<html>

<head>
    <meta charset="UTF-8">
    <title>3 컴퓨터 시스템의 동작 원리</title>
    <link rel="icon" href="https://biisairo.github.io/static/favicon.ico" type="image/x-icon">
</head>

<script>
    function toggleSection(id) {
        const section = document.getElementById(id);
        const header = section.previousElementSibling;

        if (section.style.display === 'none') {
            section.style.display = 'block';
            header.innerHTML = header.innerHTML.replace('▶', '▼');
        } else {
            section.style.display = 'none';
            header.innerHTML = header.innerHTML.replace('▼', '▶');
        }
    }
</script>

<body>
    <header>
    <nav>
        <ul>
            

            <li><a href="https://biisairo.github.io/">Home</a></li>
            
            <li><a href="https://biisairo.github.io/About/">About</a></li>
            
            <li><a href="https://biisairo.github.io/Study/">Study</a></li>
            
            <li><a href="https://biisairo.github.io/Contact/">Contact</a></li>
            
        </ul>
    </nav>

    <style>
    html,
    body {
        height: 100%;
        margin: 0;
    }

    body {
        display: flex;
        flex-direction: column;
        max-width: 720px;
        margin: 0 auto;
        padding: 2rem 1rem;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
            Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        line-height: 1.6;
        background: #222831;
        color: #EEEEEE;
    }

    header,
    footer {
        text-align: center;
        margin-bottom: 2rem;
    }

    nav ul {
        list-style: none;
        padding: 0;
        display: flex;
        justify-content: space-between;
        align-items: flex-end;

        flex-wrap: wrap;
        gap: 1rem;
    }

    nav li:first-child {
        margin-right: auto;
    }

    nav li:not(:first-child) {
        margin-left: 0;
    }

    nav li:first-child a {
        color: #EEEEEE;
        font-size: 1.5em;
        text-decoration: none;
    }

    nav li:first-child a:hover {
        color: #aadadf;
    }

    nav a {
        color: #00ADB5;
        text-decoration: underline;
        transition: color 0.3s ease;
    }

    nav a:hover {
        color: #66C1C9;
        text-decoration: none;
    }

    main a,
    article a,
    footer a {
        color: #33d3c8;
        text-decoration: underline;
        transition: color 0.3s ease;
    }

    main a:hover,
    article a:hover,
    footer a:hover {
        color: #66C1C9;
        text-decoration: none;
    }

    main {
        flex: 1;
        margin-bottom: 2rem;
    }

    h1,
    h2,
    h3 {
        line-height: 1.3;
        margin-top: 2rem;
        margin-bottom: 1rem;
    }

    h1 {
        color: #00ADB5;
    }

    h2 {
        color: #0099A1;
    }
    
    h3 {
        color: #007B82;
    }

    h2[onclick] {
        user-select: none;
        color: #2699b6;
    }

    ul {
        padding-left: 1.5rem;
    }

    article {
        margin-top: 2rem;
        border: 1px solid #33d3c8;
        padding: 1rem;
        border-radius: 5px;
    }

    footer p {
        font-size: 0.9rem;
        color: #AAAAAA;
    }

    strong {
        color: #00b5a9;
    }
</style>

</header>

    <main>
        
        
        

        
        <h2 onclick="toggleSection('pages')" style="cursor: pointer;">▶ 하위 페이지</h2>
        <div id="pages" style="display: none;">
            <ul>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/2%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%20%ea%b0%9c%ec%9a%94.html">2 운영체제 개요</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/3%20%ec%bb%b4%ed%93%a8%ed%84%b0%20%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98%20%eb%8f%99%ec%9e%91%20%ec%9b%90%eb%a6%ac.html">3 컴퓨터 시스템의 동작 원리</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/4%20%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8%ec%9d%98%20%ea%b5%ac%ec%a1%b0%ec%99%80%20%ec%8b%a4%ed%96%89.html">4 프로그램의 구조와 실행</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/5%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%ea%b4%80%eb%a6%ac.html">5 프로세스 관리</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/6%20CPU%20%ec%8a%a4%ec%bc%80%ec%a4%84%eb%a7%81.html">6 CPU 스케줄링</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/7%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%ea%b4%80%eb%a6%ac.html">7 메모리 관리</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/8%20%ea%b0%80%ec%83%81%eb%a9%94%eb%aa%a8%eb%a6%ac.html">8 가상메모리</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/9%20%eb%94%94%ec%8a%a4%ed%81%ac%20%ea%b4%80%eb%a6%ac.html">9 디스크 관리</a></li>
                
            </ul>
        </div>
        

        
        
        <article>
            <h1>3. 컴퓨터 시스템의 동작 원리</h1>
<h2>1. 컴퓨터 시스템의 구조</h2>
<ul>
<li>내부장치
<ul>
<li>CPU</li>
<li>메모리</li>
</ul>
</li>
<li>외부장치
<ul>
<li>키보드</li>
<li>마우스</li>
<li>모니터 등등</li>
</ul>
</li>
<li>외부장치에서 내부장치로 데이터를 읽어와 연산을 수행하고 이를 다시 외부장치로 출력</li>
<li>컴퓨터로의 입력을 input, 출력을 output 이라고 하며 외부장치를 입출력장치 라고도 한다</li>
<li>외부장치에는 각 장치를 제어하는 컨트롤러가 들어있으며 각각의 장치를 제어하는 작은 cpu 이다</li>
<li>컴퓨터의 프로그램이 제어되려면 프로그램에 메모리에 올라가 있어야 한다</li>
<li>운영체제는 컴퓨터가 부팅될 때 부터 항상 수행되어있어야 한다</li>
<li>운영체제의 모든 부분이 메모리에 상주하면 메모리의 낭비가 일어나며 운영체제의 핵심적인 부분을 제외한 부분은 필요에 따라 메모리에 올린다</li>
<li>이때 항상 메모리에 상주하는 핵심부분을 커널이라고 한다</li>
</ul>
<h2>2. CPU 연산과 I/O 연산</h2>
<ul>
<li>입출력장치의 io 연산은 입출력 컨트롤러가, 컴퓨터 내부의 연산은 cpu 가 담당</li>
<li>입출력 컨트롤러와 cpu 는 동시에 수행이 가능하다 (독립적이다)</li>
<li>로컬 버퍼 (local buffer)
<ul>
<li>각 장치마다 장치를 제어하기 위한 장치 컨트롤러에는 장치에서 오고가는 데이터를 저장해 두기위한 메모리</li>
</ul>
</li>
<li>외부 장치로부터 입력이 들어올때
<ul>
<li>장치에서 처리된 데이터가 로컬 버퍼에 저장된 후 메모리에 전달</li>
<li>이때 로컬 버퍼로부터 데이터를 읽어오는 일은 입출력 컨트롤러가 담당</li>
<li>로컬 버퍼에 있던 데이터를 읽어오는 작업이 끝나면 장치 컨트롤러가 인터럽트를 발생시켜 cpu 에 보고</li>
<li>cpu 가 인터럽트를 감지하는 방법
<ul>
<li>cpu 는 메 시점 명령라인을 하나씩 읽어가며 수행</li>
<li>매번 명령을 수행할 때 마다 cpu 옆에있는 인터럽트 라인을 확인</li>
<li>인터럽트 라인에 인터럽트가 들어와있으면 명령을 수행하지 않고 인터럽트를 처리</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>3. 인터럽트의 일반적 기능</h2>
<ul>
<li>커널에는 인터럽트가 들어왔을때 해야할 일이 미리 전부 프로그래밍 되어있음</li>
<li>인터럽트가 발생하면 해당 인터럽트가 들어왔을 때 수행하도록 미리 정의된 코드를 찾아 수행</li>
<li>하드웨어 인터럽트
<ul>
<li>컨트롤러 등 하드웨어 장치가 인터럽트를 발생</li>
</ul>
</li>
<li>소프트웨어 인터럽트, 트랩(trap)
<ul>
<li>소프트웨어가 인터럽트를 발생</li>
<li>예외사항(execption)
<ul>
<li>0 으로 나누는 등의 비정상적인 작업을 시도할때</li>
<li>메모리 영역 밖으로 접근을 시도할때 등</li>
</ul>
</li>
<li>시스템 콜(system call)
<ul>
<li>프로그램이 운영체제 내부에 정의된 코드를 실행하고 싶을 때 운영체제에 서비스를 요청하는 방법</li>
<li>ex) 프로그램에서 키입력을 받고자 하는 경우</li>
</ul>
</li>
<li>사용자의 프로세스로부터 cpu 의 제어권을 운영체제로 이양되어 처리</li>
</ul>
</li>
<li>인터럽트 벡터 (interrupt vector)
<ul>
<li>커널 내에서 해당 인터럽트의 처리를 위하여 인터럽트마다 번호를 정해 처리해야 할 코드를 가리키는 자료구조</li>
</ul>
</li>
<li>인터럽트 처리 루틴 (interrupt service routine), 인터럽트 핸들러(interrupt handler)
<ul>
<li>실제 처리해야할 코드가 정의된 곳</li>
</ul>
</li>
</ul>
<h2>4. 인터럽트 핸들링 (interrupt handling)</h2>
<ul>
<li>인터럽트가 발생한 경우 처리해야 할 일의 절차
<ul>
<li>프로그램이 실행되는 중 인터럽트 발생</li>
<li>프로그램의 현재 상태를 PCB 에 저장
<ul>
<li>cpu 에서 실행중인 명령의 메모리 주소와 같은 정보</li>
<li>프로세스 제어 블록(Process Contol Block: PCB)을 사용
<ul>
<li>프로그램마다 존재</li>
<li>프로그램의 어느 부분이 실행중이었는지 저장</li>
<li>프로그램이 실행중이던 코드의 메모리 주소, 레지스터값, 하드웨어 상태 등이 저장</li>
</ul>
</li>
</ul>
</li>
<li>인터럽트 처리가 끝난 후 PCB 에서 CPU 에 복원한 뒤 다시 프로그램을 수행</li>
</ul>
</li>
<li>오늘날의 운영체제는 인터럽트가 발생 할 때만 실행됨
<ul>
<li>부팅 후 정상상태가 되면 사용자의 프로그램에 의해서만 cpu 가 사용됨</li>
<li>인터럽트가 발생할 때만 운영체제가 cpu 의 제어권을 가져감</li>
</ul>
</li>
</ul>
<h2>5. 입출력 구조</h2>
<ul>
<li>입출력(I/O) 란 시스템이 컴퓨터 외부의 입출력 장치들과 데이터를 주고받는것을 말함</li>
<li>동기식 입출력 (synchronous I/O)
<ul>
<li>입출력 요청이 들어왔을 때 입출력 작업이 완료된 후 프로그램이 후속 작업을 수행</li>
<li>cpu 가 입출력 연산이 끝날 때까지 기다리게 되며 자원이 낭비됨</li>
<li>일반적으로 입출력이 완료될 때 까지 다른 프로그램에게 cpu 사용권을 넘겨 자원 낭비를 방지함</li>
<li>입출력중인 프로그램을 봉쇄상태(blocked state) 로 전환시켜 cpu 를 할당하지 않게 됨</li>
<li>동기화의 보장
<ul>
<li>두 프로그램이 동시에 같은 입출력 장치에 연산을 요청할 때 우선순위가 꼬여 원하지 않는 결과가 나올 수 있음</li>
<li>각 장치별로 큐(queue)를 두어 요청한 순서대로 처리가 되도록 한다</li>
</ul>
</li>
<li>입출력 장치의 일이 끝나면 cpu 에 인터럽트를 만들어 입출력이 완료되었음을 알림</li>
<li>입출력이 완료되면 해당 프로그램의 봉쇄상태를 해제</li>
</ul>
</li>
<li>비동기식 입출력
<ul>
<li>입출력 연산을 요청한 뒤 연산이 끝나기를 기다리는 것이 아니라 cpu 의 제어권을 다시 프로그램에 돌려줌</li>
<li>프로그램이 입출력결과를 사용하는 것이 아닌 다른 연산을 수행할 경우 사용</li>
<li>이것과 무관하게 입출력이 끝나면 입출력장치는 인터럽트를 발생시켜 작업이 완료되었다는 것을 알림</li>
</ul>
</li>
</ul>
<h2>6. DMA (Direct Memory Access)</h2>
<ul>
<li>메모리는 CPU 에서만 접근이 가능한게 원칙</li>
<li>프로그램이 메모리에 접근하기 위해서는 CPU 에 인터럽트를 발생시켜 cpu 로 하여금 접근을 하도록 해야함</li>
<li>입출력 장치가 버퍼에서 메모리로 데이터를 옮길 때 마다 인터럽트를 발생시키면 cpu 의 업무에 방해가 되게 됨</li>
<li>cpu 이외에 메모리에 접근 가능한 장치를 두게 되며 이를 direct memory access (DMA) 라고 부른다</li>
<li>로컬버퍼에서 메모리로 데이터를 불러오는 과정을 cpu 가 아는 dma 가 맡게됨으로 cpu 가 인터럽트를 처리할 필요가 없게 됨</li>
<li>DMA 는 byte 단위가 아닌 block 이라는 큰 단위로 메모리를 읽어온 후 cpu 에 인터럽트를 발생시켜 작업의 완료를 알려줌</li>
</ul>
<h2>7. 저장장치의 구조</h2>
<ul>
<li>주기억장치
<ul>
<li>RAM 같은 휘발성(volatile) 메모리</li>
</ul>
</li>
<li>보조기억장치
<ul>
<li>플레시메모리, CD, 하드디스크같은 비휘발성(nonvolatile) 메모리</li>
</ul>
</li>
<li>보조기억장치의 용도
<ul>
<li>파일시스템
<ul>
<li>전원이 나가도 저장되어야 할 데이터들의 저장</li>
</ul>
</li>
<li>스왑 영역
<ul>
<li>상대적으로 비싸고 용량이 적은 메모리를 아끼기 위해 당장 필요한 부분은 메모리에 올려두고 다른 데이터를 보조기억장치의 스왑 영역에 저장</li>
<li>스왑 아웃 (swap out)
<ul>
<li>데이터를 스왑 영역에 저장하는 일</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>8. 저장장치의 계층 구조</h2>
<ul>
<li>primary memory
<ul>
<li>레지스터 - 캐시 메모리 - 메인 메모리</li>
<li>빠른 저장장치는 공간당 가격이 비싸 적은 용량만 사용</li>
<li>전원이 꺼지면 사라지는 휘발성 메모리</li>
</ul>
</li>
<li>secondary memory
<ul>
<li>가격이싸지만 속도가 느림</li>
<li>전원이 꺼져도 남아있는 비휘발성 메모리</li>
</ul>
</li>
<li>상위 저장장치에서는 필요한 데이터만 선별적으로 저장하여 사용</li>
<li>캐싱
<ul>
<li>적은 용량을 사용하여 느린 저장장치의 성능을 향상시키는 기법</li>
<li>느린 저장장치에 있는 내용 중 당장 사용하거나 빈번하게 사용하는 정보를 빠른 저장장치에 선별적으로 저장해 두 저장장치의 속도 차이를 매꾸는 방법</li>
</ul>
</li>
</ul>
<h2>9. 하드웨어의 보안</h2>
<ul>
<li>우리가 사용하는 운영체제는 여러개의 프로그램이 동시에 돌아가는 다중 프로그래밍(multi-programming) 환경에서 동작</li>
<li>프로그램이 다른 프로그램의 실행을 방해하거나 프로그램간의 충돌을 막기위한 보안기법이 필요</li>
<li>사용자모드 (user mode)</li>
<li>커널모드 (kernel mode, system mode)
<ul>
<li>운영체제가 cpu 의 제어권을 가지고 운영체제 코드를 실행하는 모드</li>
<li>모든 종류의 명령어를 사용 가능</li>
<li>메모리접근 등 중요한 정보에 접근할 수 있는 연산은 커널모드에서만 사용하도록함</li>
</ul>
</li>
<li>커널모드를 사용해도 프로그램이 cpu 제어권을 가지고 실행중인 동안 위와같은 작업을 수행하면 실행이 되버림</li>
<li>모드비트 (mode bit)
<ul>
<li>cpu 내부에 모드비트를 두어 프로그램을 감시</li>
<li>모드비트가 0 으로 세팅되어 있으면 커널모드</li>
<li>모드비트가 1 로 세팅되어 있으면 사용자모드</li>
<li>보안과 관련이 있는 명령어를 수행하기 전 모드비트를 확인 해 값이 0인 경우에만 수행</li>
<li>운영체제가 사용자프로그램에 cpu 제어권을 넘길때 모드비트를 1으로 세팅 후 권한을 넘김</li>
<li>인터럽트가 발생하면 cpu 제어권을 운영체제에게 넘기며 운영체제는 모드비트를 0으로 세팅 후 작업 수행</li>
<li>특권명령
<ul>
<li>위와같이 모드비트가 0일때만 사용할 수 있는 명령어</li>
</ul>
</li>
</ul>
</li>
<li>하드웨어 장치에서의 보안
<ul>
<li>모든 입출력 명령은 특권명령
<ul>
<li>허가되지 않은 사용자가 외부장치(하드디스크같은)에 접근하는걸 방지</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>10. 메모리 보안</h2>
<ul>
<li>여러 프로그램이 동시에 메모리에 올라가 실행되기 때문에 프로그램이 다른 프로그램이나 운영체제의 메모리영역을 침범하는걸 막아야 함</li>
<li>2개의 레지스터를 사용해 프로그램이 접근하려는 메모리 주소가 합법적인지 체크
<ul>
<li>기준 레지스터 (base register)
<ul>
<li>프로그램이 실행되는 동안 프로그램이 합법적으로 접근할 수 있는 영역의 가장 작은 주소가 저장</li>
</ul>
</li>
<li>한계 레지스터 (limit register)
<ul>
<li>프로그램이 기준 레지스터의 주소부터 접근할 수 있는 영역의 범위가 저장</li>
</ul>
</li>
<li>위 두 레지스터에 저장된 값을 사용해 현재 접근하려는 메모리 주소가 합법적인지 확인</li>
<li>이같은 방법은 메모리 영역이 연속적으로 위치하는 경우에만 사용</li>
</ul>
</li>
<li>사용자의 프로그램이 cpu 를 가지고 있는동안 사용하는 기법으로 특권명령은 아님</li>
<li>하드웨어적으로 접근이 가능한지 체크하는 방식</li>
<li>커널모드에서는 무제한으로 메모리에 접근이 가능하다</li>
</ul>
<h2>11. CPU 보호</h2>
<ul>
<li>일반적으로 cpu 는 하나밖에 없기 때문에 하나의 프로그램이 무한반복을 하는 등 cpu 를 독점할 수 있다</li>
<li>타이머(timer) 라는 하드웨어를 사용</li>
<li>하나의 프로그램이 정해진 시간동안 cpu 를 점유하고 있으면 타이머가 인터럽트를 발생시켜 운영체제가 cpu 제어권을 가질 수 있도록 함</li>
<li>운영체제는 해당 프로그램으로부터 cpu 를 빼앗아 다른 프로그램에게 이양시킴</li>
<li>정해진 시간은 매 클릭 틱(click tick) 마다 1씩 감소하다 0 이 되는 순간 인터럽트 발생</li>
<li>로드 타이머 (load timer)
<ul>
<li>타이머의 시간을 세팅하는 명령어</li>
<li>특권명령에 속함</li>
</ul>
</li>
<li>타이머는 시분할 시스템에서 프로그램이 현재 시간을 계산하기 위해서도 사용</li>
</ul>
<h2>12. 시스템 콜을 이용한 입출력 수행</h2>
<ul>
<li>입출력 명령은 전부 특권명령에 해당</li>
<li>사용자의 프로그램이 직접 사용할 수 없음</li>
<li>운영체제에 시스템 콜 이라는 서비스 대행을 요청</li>
<li>소프트웨어 인터럽트의 일종</li>
</ul>

        </article>
        
        
    </main>

    

<footer>
    <p>
        Author: Dongyoon Kim - <a href="https://biisairo.github.io/">Home</a> - <a href="https://github.com/Biisairo">GitHub</a> - <a
            href="mailto:rlark1224@naver.com">Mail</a>
    </p>
    <img src="https://hits.sh/biisairo.github.io.svg?label=Visitor&color=000000">
</footer>

</body>

</html>