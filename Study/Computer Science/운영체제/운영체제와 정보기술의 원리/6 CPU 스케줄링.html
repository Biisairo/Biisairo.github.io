<!DOCTYPE html>



<html>

<head>
    <meta charset="UTF-8">
    <title>6 CPU 스케줄링</title>
    <link rel="icon" href="https://biisairo.github.io/static/favicon.ico" type="image/x-icon">
</head>

<script>
    function toggleSection(id) {
        const section = document.getElementById(id);
        const header = section.previousElementSibling;

        if (section.style.display === 'none') {
            section.style.display = 'block';
            header.innerHTML = header.innerHTML.replace('▶', '▼');
        } else {
            section.style.display = 'none';
            header.innerHTML = header.innerHTML.replace('▼', '▶');
        }
    }
</script>

<body>
    <header>
    <nav>
        <ul>
            

            <li><a href="https://biisairo.github.io/">Home</a></li>
            
            <li><a href="https://biisairo.github.io/About/">About</a></li>
            
            <li><a href="https://biisairo.github.io/Study/">Study</a></li>
            
            <li><a href="https://biisairo.github.io/Contact/">Contact</a></li>
            
        </ul>
    </nav>

    <style>
    html,
    body {
        height: 100%;
        margin: 0;
    }

    body {
        display: flex;
        flex-direction: column;
        max-width: 720px;
        margin: 0 auto;
        padding: 2rem 1rem;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
            Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        line-height: 1.6;
        background: #222831;
        color: #EEEEEE;
    }

    header,
    footer {
        text-align: center;
        margin-bottom: 2rem;
    }

    nav ul {
        list-style: none;
        padding: 0;
        display: flex;
        justify-content: space-between;
        align-items: flex-end;

        flex-wrap: wrap;
        gap: 1rem;
    }

    nav li:first-child {
        margin-right: auto;
    }

    nav li:not(:first-child) {
        margin-left: 0;
    }

    nav li:first-child a {
        color: #EEEEEE;
        font-size: 1.5em;
        text-decoration: none;
    }

    nav li:first-child a:hover {
        color: #aadadf;
    }

    nav a {
        color: #00ADB5;
        text-decoration: underline;
        transition: color 0.3s ease;
    }

    nav a:hover {
        color: #66C1C9;
        text-decoration: none;
    }

    main a,
    article a,
    footer a {
        color: #33d3c8;
        text-decoration: underline;
        transition: color 0.3s ease;
    }

    main a:hover,
    article a:hover,
    footer a:hover {
        color: #66C1C9;
        text-decoration: none;
    }

    main {
        flex: 1;
        margin-bottom: 2rem;
    }

    h1,
    h2,
    h3 {
        line-height: 1.3;
        margin-top: 2rem;
        margin-bottom: 1rem;
        color: #00ADB5;
    }

    h2[onclick] {
        user-select: none;
        color: #2699b6;
    }


    ul {
        padding-left: 1.5rem;
    }

    article {
        margin-top: 2rem;
        border: 1px solid #33d3c8;
        padding: 1rem;
        border-radius: 5px;
    }

    footer p {
        font-size: 0.9rem;
        color: #AAAAAA;
    }
</style>

</header>

    <main>
        
        
        

        
        <h2 onclick="toggleSection('pages')" style="cursor: pointer;">▶ 하위 페이지</h2>
        <div id="pages" style="display: none;">
            <ul>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/2%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%20%ea%b0%9c%ec%9a%94.html">2 운영체제 개요</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/3%20%ec%bb%b4%ed%93%a8%ed%84%b0%20%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98%20%eb%8f%99%ec%9e%91%20%ec%9b%90%eb%a6%ac.html">3 컴퓨터 시스템의 동작 원리</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/4%20%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8%ec%9d%98%20%ea%b5%ac%ec%a1%b0%ec%99%80%20%ec%8b%a4%ed%96%89.html">4 프로그램의 구조와 실행</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/5%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%ea%b4%80%eb%a6%ac.html">5 프로세스 관리</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/6%20CPU%20%ec%8a%a4%ec%bc%80%ec%a4%84%eb%a7%81.html">6 CPU 스케줄링</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/7%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%ea%b4%80%eb%a6%ac.html">7 메모리 관리</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/8%20%ea%b0%80%ec%83%81%eb%a9%94%eb%aa%a8%eb%a6%ac.html">8 가상메모리</a></li>
                
                <li><a href="https://biisairo.github.io/Study/Computer%20Science/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c/%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%ec%99%80%20%ec%a0%95%eb%b3%b4%ea%b8%b0%ec%88%a0%ec%9d%98%20%ec%9b%90%eb%a6%ac/9%20%eb%94%94%ec%8a%a4%ed%81%ac%20%ea%b4%80%eb%a6%ac.html">9 디스크 관리</a></li>
                
            </ul>
        </div>
        

        
        
        <article>
            <h1>6. CPU 스케줄링</h1>
<h2>0.</h2>
<ul>
<li>프로그램이 실행되는 과정
<ul>
<li>메모리에 프로그램이 올라감</li>
<li>프로그램 카운터(PC) 레지스터가 가리키는 주소의 코드를 한줄씩 수행</li>
</ul>
</li>
<li>수행되는 기계어 명령어
<ul>
<li>CPU 에서 수행되는 명령
<ul>
<li>ex) add 명령
<ul>
<li>두 값을 더해 저장하는 명령어</li>
</ul>
</li>
<li>CPU 내에서 수행되기 때문에 수행속도가 빠르다</li>
<li>사용자 프로그램에서 사용할 수 있는 일반 명령</li>
</ul>
</li>
<li>메모리 접근을 위한 명령
<ul>
<li>load 명령
<ul>
<li>메모리의 값을 cpu 로 읽어들이는 명령어</li>
</ul>
</li>
<li>store 명령
<ul>
<li>cpu 에서 계산된 결과값을 메모리에 저장하는 명령어</li>
</ul>
</li>
<li>cpu 에서 수행되는 명령들 보다는 오래걸리나 비교적 짧은 시간이 소요</li>
<li>사용자 프로그램에서 사용할 수 있는 일반 명령</li>
</ul>
</li>
<li>입출력을 동반하는 명령
<ul>
<li>키보드에서 입력을 받거나 화면에 출력하는 등의 명령</li>
<li>시간이 오래 걸린다</li>
<li>특권명령으로 사용자프로그램이 직접 사용할 수 없고 운영체제를 통해서만 사용 가능</li>
</ul>
</li>
</ul>
</li>
<li>CPU 버스트(burst)
<ul>
<li>속도가 빠른 cpu명령어와 메모리 접근 명령어가 수행되는 단계들</li>
</ul>
</li>
<li>I/O 버스트
<ul>
<li>속도가 느린 입출력 명령어가 실행되는 단계들</li>
</ul>
</li>
<li>프로그램은 위의 두 과정이 반복되어 수행되며 실행됨</li>
<li>CPU 바운드 프로세스
<ul>
<li>CPU 버스트가 I/O 버스트에 비해 더 많이, 길게 수행되는 프로세스</li>
<li>계산 위주의 프로세스</li>
<li>소수의 긴 cpu 버스트로 구성</li>
</ul>
</li>
<li>I/O 바운드 프로세스
<ul>
<li>I/O 버스트가 CPU 버스트에 비해 더 많이, 길게 수행되는 프로세스</li>
<li>사용자로부터 인터렉션(interaction)을 계속 받아가면서 실행되는 대화형프로세스(interactive process)</li>
<li>다수의 짧은 cpu 버스트로 구성</li>
</ul>
</li>
<li>대부분의 프로세스는 짧은 cpu 버스트를 가진다
<ul>
<li>즉 대부분의 프로세스는 대화형 프로세스이며 사용자에게 빠른 응답을 보여주어야 하기 때문에 우선적인 CPU 할당을 해 주어야 한다</li>
<li>CPU 스케줄링 시 I/O 바운드 프로세스의 우선순위를 높여주어야 한다</li>
</ul>
</li>
</ul>
<h2>1. CPU 스케줄러</h2>
<ul>
<li>비선점형(nonpreemptive)
<ul>
<li>CPU 를 획득한 프로세스가 스스로 CPU 를 반납하기 전까지 CPU 를 빼앗기지 않는 방법</li>
</ul>
</li>
<li>선점형(preemptive)
<ul>
<li>CPU 를 강제로 빼앗을 수 있는 방법</li>
<li>할당시간(time quantum) 을 부여한 후 타이머 인터럽트를 발생시키는 방법</li>
</ul>
</li>
<li>CPU 스케줄링이 필요한 경우
<ul>
<li>비선점형 방식
<ul>
<li>실행 상태에 있던 프로세스가 봉쇄상태로 바뀌는 경우</li>
<li>실행상태에 있던 프로세스가 종료되는 경우</li>
</ul>
</li>
<li>선점형 방식
<ul>
<li>실행 상태에 있던 프로세스가 타이머 인터럽트에 의해 준비상태로 바뀌는 경우</li>
<li>I/O 요청에 의해 봉쇄상태에 있던 프로세스의 작업이 완료되어 준비상태로 바뀐경우</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>2. 디스패처 (dispatcher)</h2>
<ul>
<li>스케줄러에 의해 CPU 할당의 대상이 결정된 뒤 실제 CPU 를 이양하는 작업을 도와주는 코드</li>
<li>현재 수행중이던 프로세스의 문맥을 PCB 에 저장하고 새로운 프로세스의 PCB 에서 문맥을 복원한 후 해당 프로세스에 CPU 를 넘기는 과정을 진행</li>
<li>문맥이 복원 된 후에는 시스템의 상태를 사용자모드로 전환한 후 사용자 프로그램에게 CPU 의 제어권을 넘김</li>
<li>디스패치 지연시간(dispatch latency)
<ul>
<li>하나의 프로세스를 정지 시키고 다른 프로세스에게 CPU 를 전달하는데 걸리는 시간</li>
<li>문맥교환 오버헤드에 해당</li>
</ul>
</li>
</ul>
<h2>3. 스케줄링의 성능 평가</h2>
<ul>
<li>시스템 관점의 지표
<ul>
<li>CPU 이용량, 처리량</li>
</ul>
</li>
<li>사용자 관점의 지표
<ul>
<li>소요시간, 대기시간, 응답시간 등 시간과 관련된 지표</li>
</ul>
</li>
<li>CPU 이용률 (CPU utilization)
<ul>
<li>전체 시간 중 CPU 가 일을 한 시간의 비율</li>
<li>CPU 가 휴면(idle)상태에 머무르는 시간을 최소화 하는 것이 중요</li>
</ul>
</li>
<li>처리량 (throughput)
<ul>
<li>주어진 시간 동안 준비 큐 에서 기다리고 있는 프로세스 중 몇 개를 끝마쳤는지 (CPU 버스트를 완료한 프로세스의 개수)</li>
<li>CPU 의 서비스를 원하는 프로세스 중 몇 개가 원하는 만큼의 CPU 를 사용하고 CPU 버스트를 끝내 준비 큐 를 떠났는지를 측정산 것</li>
<li>주어진 시간동안 더 많은 처리를 하려면 CPU 버스트가 짧은 프로세스에게 먼저 할당하는 것이 좋다</li>
</ul>
</li>
<li>소요시간 (turnaround time)
<ul>
<li>프로세스가 CPU 를 요청한 시점부터 자신이 원하는 만큼 CPU를 다 쓰고 CPU 버스트가 끝날 때 까지 걸린 시간</li>
<li>준비 큐 에서 기다린 시간과 CPU 를 실제 사용한 시간의 합</li>
</ul>
</li>
<li>대기시간 (waiting time)
<ul>
<li>CPU 버스트 기간 중 프로세스가 준비 큐 에서 CPU 를 얻기위해 대기한 시간의 합</li>
<li>시분할 시스템에서는 타이머를 사용 해 하나의 프로세스가 CPU 를 연속적으로 사용할 수 없도록 막기 때문에 한번의 CPU 버스트 중에도 준비 큐 에서 기다린 시간이 있을 수 있음</li>
</ul>
</li>
<li>응답시간 (response time)
<ul>
<li>프로세스가 준비 큐에 들어온 후 첫번째 CPU 를 획득하기까지 걸린 시간</li>
<li>대화형 시스템에 적합한 성능 척도</li>
</ul>
</li>
</ul>
<h2>4. 스케줄링 알고리즘</h2>
<ul>
<li>선입선출(First Come First Served: FCFS) 스케줄링
<ul>
<li>프로세스가 준비 큐에 도착한 순서대로 CPU 를 할당하는 방식</li>
<li>콘보이 현상 (Convoy effect)
<ul>
<li>CPU 버스트가 긴 프로세스가 앞에있으면 뒤에있는 CPU 버스트가 짧은 프로세스들의 평균 대기시간이 길어지게 되는 현상</li>
</ul>
</li>
</ul>
</li>
<li>최단작업 우선 스케줄링 (Shortest Job First: SJF)
<ul>
<li>CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU 를 할당하는 방식</li>
<li>프로세스들의 평균 대기시간을 가장 짧게 하는 최적 알고리즘으로 알려져 있음</li>
<li>선점형 방식 : SJF 에서의 선점형 방식 (Shortest Remaining Time First: SRTF)
<ul>
<li>준비 큐에서 CPU 버스트가 가장 짧은 프로세스가 도착하면 CPU 를 빼앗아 더 짧은 프로세스에게 부여하는 방식</li>
</ul>
</li>
<li>기아 현상 (starvation)
<ul>
<li>짧은 CPU 버스트를 가지는 프로세스가 계속 준비 큐에 들어와 긴 CPU 버스트를 가진 프로세스가 영원히 CPU 를 할당받지 못하는 현상</li>
</ul>
</li>
</ul>
</li>
<li>우선순위 스케줄링 (priority scheduling)
<ul>
<li>준비 큐에서 기다리는 프로세스 중 우선순위가 높은 순서대로 CPU 를 할당하는 방식</li>
<li>우선순위 값(priority number) 를 통해 표시</li>
<li>어느 기준에 우선순위를 두느냐에 따라 SJF 와 같은 스케줄링이 될 수도있다</li>
<li>비선점형, 선점형으로 작동할 수 있다</li>
<li>기아현상이 발생할 수 있다</li>
<li>노화 기법 (aging)
<ul>
<li>기아현상을 해결하기 위한 방법</li>
<li>기다리는 시간이 길어지면 우선순위를 조금씩 높여 언젠가는 가장 높은 우선순위가 되어 CPU 를 할당 받을 수 있게 해주는 기법</li>
</ul>
</li>
</ul>
</li>
<li>라운드 로빈 스케줄링 (Round Robin Scheduling)
<ul>
<li>프로세스가 연속적으로 사용할 수 있는 시간이 제한하는 기법</li>
<li>해당 시간이 경과되면 프로세스로부터 CPU 를 회수 하며 준비 큐로 들어가게된다</li>
<li>할당시간 (time quantum)
<ul>
<li>프로세스마다 한번에 CPU 를 사용할 수 있는 최대 시간</li>
</ul>
</li>
<li>할당시간이 너무 긴 라운드 로빈 스케줄링은 FCFS와 같은 결과가 나게 됨</li>
<li>할당시간이 너무 짧으면 잦은 문맥교환으로 인한 오버헤드가 커짐</li>
<li>여러 종류의 이질적인 프로세스가 함께 실행되는 상황에서 효과적</li>
</ul>
</li>
<li>멀티레벨 큐 (multi level queue)
<ul>
<li>준비 큐를 여러개로 분할해 관리하는 방식</li>
<li>CPU 는 여전히 하나밖에 없으므로 어느 준비 큐에 있는 프로세스를 우선적으로 할당할지 스케줄링필요</li>
<li>프로세스가 준비 큐에 들어갈 때 어느 큐에 넣어줄지 결정 필요</li>
<li>성격이 다른 프로세스들을 별도로 관리하며 각 큐 별로 성격에 맞는 스케줄링을 각각 적용</li>
<li>일반적으로 대화형 작업을 담당하는 전위 큐(foreground queue), 계산 위주의 작업을 담당하는 후위 큐(background queue) 로 분리
<ul>
<li>전위 큐
<ul>
<li>응답 시간을 짧게 하기 위해 라운드 로빈 스케줄링을 사용</li>
</ul>
</li>
<li>후위 큐
<ul>
<li>응답 시간에 큰 의미가 없기에 FCFS 스케줄링을 사용</li>
</ul>
</li>
</ul>
</li>
<li>각 큐에 대한 스케줄링
<ul>
<li>고정 우선순위 방식 (fixes priority scheduling)
<ul>
<li>큐에 우선순위를 부여해 스케줄링하는 방식</li>
<li>우선순위가 낮은 큐는 우선순위가 높은 큐가 비어있을때 서비스하게 됨</li>
</ul>
</li>
<li>타임 슬라이스 방식 (time slice)
<ul>
<li>큐에 대한 기아현상을 해소하기 위함</li>
<li>각 큐에 CPU 시간을 적절히 분배
<ul>
<li>ex) 전위 큐에 80%, 후위 큐에 20% 를 부여</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>멀티레벨 피드백 큐 (Multilevel Feedback queue)
<ul>
<li>준비 큐를 나눈다는 방식은 멀티레벨 큐와 동일하나 프로세스가 하나의 큐에서 다른 큐로 이동이 가능한 방식</li>
<li>노화 기법을 큐에 적용할 수 있음
<ul>
<li>우선순위가 낮은 큐에서 오래 기다리면 우선순위가 낮은 큐에 높은 우선순위를 부여</li>
</ul>
</li>
<li>멀티레벨 피드백 큐를 정의하는 기준
<ul>
<li>큐의 수</li>
<li>각 큐의 스케줄링 알고리즘</li>
<li>프로세스를 상위 큐로 승격시키는 기준</li>
<li>프로세스를 하위 큐로 강등시기는 기준</li>
<li>프로세스가 도착했을 때 들어갈 큐를 정하는 기준</li>
</ul>
</li>
</ul>
</li>
<li>다중처리기 스케줄링 (multiple processor scheduling)
<ul>
<li>CPU 가 여러개인 시스템을 다중처리기 시스템(multi processor system) 이라고 함</li>
<li>프로세스를 준비 큐에 한줄로 세워 각 CPU 가 알아서 다음 프로세스를 꺼내갈 수 있도록 할 수 있음</li>
<li>프로세스별로 큐를 만들어 프로세스를 줄세울 수 있음
<ul>
<li>이 경우 한 cpu 에 작업이 편중되는 현상이 생길 수 있음</li>
<li>부하 균형 (load balancing)
<ul>
<li>cpu 별로 부하가 적절히 분산되도록 하는 메커니즘</li>
<li>대칭형 다중처리 (symmetric multi processing)
<ul>
<li>각 cpu 가 알아서 스케줄링을 하는 방식</li>
</ul>
</li>
<li>비대칭형 다중처리 (asymmetric multi processing)
<ul>
<li>하나의 cpu 가 다른 cpu 들의 스케줄링 및 데이터 접근을 책임지는 방식</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>실시간 스케줄링 (real time scheduling)
<ul>
<li>실시간 시스템(real time system) 에서는 각 작업마다 주어진 데드라인이 있어 정해진 시간안에 작업을 완료해야 하는 상황이 생김</li>
<li>경성 실시간 시스템 (hard real time system)
<ul>
<li>시간을 무조건 정확히 지켜야 하는 시스템</li>
</ul>
</li>
<li>연성 실시간 시스템 (soft real time system)
<ul>
<li>데드라인이 존재하나 지키지 않더라도 위험한 상황이 발생하지 않는 시스템</li>
</ul>
</li>
<li>EDF 스케줄링 (Earlist Deadline First)
<ul>
<li>먼저 온 요청을 먼저 처리하기 보단 데드라인이 얼마 남지 않은 요청을 먼저 처리하는 방식</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>5. 스케줄링 알고리즘의 평가</h2>
<ul>
<li>큐잉 모델 (queueing model)
<ul>
<li>이론가들이 수행하는 방식</li>
<li>프로세스들의 도착률과 CPU 의 처리율을 기반으로 성능지표값(performance index) 인 CPU 의 처리량, 프로세스의 평균 대기시간등을 구하는 방식</li>
</ul>
</li>
<li>시뮬레이션 (simulation)
<ul>
<li>가상의 환경에서 CPU 스케줄링 알고리즘을 작성한 후 CPU 요청을 넣어 나오는 결과를 확인하는 방식</li>
<li>가상의 요청이나 실제 시스템에서 추출한 요청값을 입력값으로 넣음</li>
<li>트레이스 (trace)
<ul>
<li>실제 시스템에서 추출한 입력값</li>
</ul>
</li>
</ul>
</li>
<li>구현 및 실측 (implementation &amp; measurement)
<ul>
<li>구현가들이 수행하는 방식</li>
<li>운영체제 커널의 CPU 스케줄링을 수행하는 코드를 수정하여 직접 확인하는 방식</li>
</ul>
</li>
</ul>

        </article>
        
        
    </main>

    

<footer>
    <p>Author: Dongyoon Kim - <a href="https://biisairo.github.io/">Home</a> - <a href="https://github.com/Biisairo">GitHub</a> - <a
            href="mailto:rlark1224@naver.com">Mail</a></p>
</footer>

</body>

</html>