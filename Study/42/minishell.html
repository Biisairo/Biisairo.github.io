<!DOCTYPE html>



<html>

<head>
    <meta charset="UTF-8">
    <title>minishell</title>
    <link rel="icon" href="https://biisairo.github.io/static/favicon.ico" type="image/x-icon">
</head>

<script>
    function toggleSection(id) {
        const section = document.getElementById(id);
        const header = section.previousElementSibling;

        if (section.style.display === 'none') {
            section.style.display = 'block';
            header.innerHTML = header.innerHTML.replace('▶', '▼');
        } else {
            section.style.display = 'none';
            header.innerHTML = header.innerHTML.replace('▼', '▶');
        }
    }
</script>

<body>
    <header>
    <nav>
        <ul>
            

            <li><a href="https://biisairo.github.io/">Home</a></li>
            
            <li><a href="https://biisairo.github.io/About/">About</a></li>
            
            <li><a href="https://biisairo.github.io/Study/">Study</a></li>
            
            <li><a href="https://biisairo.github.io/Contact/">Contact</a></li>
            
        </ul>
    </nav>

    <style>
    html,
    body {
        height: 100%;
        margin: 0;
    }

    body {
        display: flex;
        flex-direction: column;
        max-width: 720px;
        margin: 0 auto;
        padding: 2rem 1rem;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
            Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        line-height: 1.6;
        background: #222831;
        color: #EEEEEE;
    }

    header,
    footer {
        text-align: center;
        margin-bottom: 2rem;
    }

    nav ul {
        list-style: none;
        padding: 0;
        display: flex;
        justify-content: space-between;
        align-items: flex-end;

        flex-wrap: wrap;
        gap: 1rem;
    }

    nav li:first-child {
        margin-right: auto;
    }

    nav li:not(:first-child) {
        margin-left: 0;
    }

    nav li:first-child a {
        color: #EEEEEE;
        font-size: 1.5em;
        text-decoration: none;
    }

    nav li:first-child a:hover {
        color: #aadadf;
    }

    nav a {
        color: #00ADB5;
        text-decoration: underline;
        transition: color 0.3s ease;
    }

    nav a:hover {
        color: #66C1C9;
        text-decoration: none;
    }

    main a,
    article a,
    footer a {
        color: #33d3c8;
        text-decoration: underline;
        transition: color 0.3s ease;
    }

    main a:hover,
    article a:hover,
    footer a:hover {
        color: #66C1C9;
        text-decoration: none;
    }

    main {
        flex: 1;
        margin-bottom: 2rem;
    }

    h1,
    h2,
    h3 {
        line-height: 1.3;
        margin-top: 2rem;
        margin-bottom: 1rem;
    }

    h1 {
        color: #00ADB5;
    }

    h2 {
        color: #0099A1;
    }
    
    h3 {
        color: #007B82;
    }

    h2[onclick] {
        user-select: none;
        color: #2699b6;
    }

    ul {
        padding-left: 1.5rem;
    }

    article {
        margin-top: 2rem;
        border: 1px solid #33d3c8;
        padding: 1rem;
        border-radius: 5px;
    }

    footer p {
        font-size: 0.9rem;
        color: #AAAAAA;
    }

    strong {
        color: #00b5a9;
    }
</style>

</header>

    <main>
        
        
        <h2 onclick="toggleSection('groups')" style="cursor: pointer;">▶ 하위 그룹</h2>
        <div id="groups" style="display: none;">
            <ul>
                
                <li><a href="https://biisairo.github.io/Study/42/born2beroot/">born2beroot</a></li>
                
                <li><a href="https://biisairo.github.io/Study/42/minilibx/">minilibx</a></li>
                
                <li><a href="https://biisairo.github.io/Study/42/ft_transcendence/">ft_transcendence</a></li>
                
            </ul>
        </div>
        
        

        
        <h2 onclick="toggleSection('pages')" style="cursor: pointer;">▶ 하위 페이지</h2>
        <div id="pages" style="display: none;">
            <ul>
                
                <li><a href="https://biisairo.github.io/Study/42/ft_printf.html">ft_printf</a></li>
                
                <li><a href="https://biisairo.github.io/Study/42/get_next_line.html">get_next_line</a></li>
                
                <li><a href="https://biisairo.github.io/Study/42/pipex.html">pipex</a></li>
                
                <li><a href="https://biisairo.github.io/Study/42/minishell.html">minishell</a></li>
                
                <li><a href="https://biisairo.github.io/Study/42/philosopher.html">philosopher</a></li>
                
                <li><a href="https://biisairo.github.io/Study/42/net_practice.html">net_practice</a></li>
                
                <li><a href="https://biisairo.github.io/Study/42/rbtree.html">rbtree</a></li>
                
                <li><a href="https://biisairo.github.io/Study/42/IRC.html">IRC</a></li>
                
            </ul>
        </div>
        

        
        
        <article>
            <h1>minishell</h1>
<h1>parse</h1>
<ol>
<li>&quot;, ’ 를 기준으로 전부 나눈다.
<ul>
<li>‘hello world’ -&gt; ’ / hello world / ’</li>
</ul>
</li>
<li>&quot;, ’ 내부에 있는 문자열은 ABLE 로 처리한다</li>
<li>&quot;, ’ 는 SING, DOUB 로 처리한다
<ul>
<li>‘hello world’ -&gt; ’ / hello world / ’ (SING-&gt;ABLE-&gt;SING)</li>
</ul>
</li>
<li>$ 를 처리한다, 이때 둘러쌓인 &quot;, ’ 를 확인한다</li>
<li>공백을 찾아 SPCE 로 분리, 이때 DEAF 상태인 부분만 나눈다, ABLE 은 건들지 않는다</li>
<li>는 PIPE 로 분리</li>
<li>&lt;&lt;, &lt;, &gt;, &gt;&gt; 는 HERE, REIN, REOU, APPN 로 분리</li>
<li>빈문자열인 DEAF 은 삭제, 다른 DEAF 은 ABLE 로 변경</li>
<li>연속된 ABLE 합치기</li>
<li>SPCE 삭제</li>
</ol>
<p>error 1. HERE, REIN, REOU, APPN 뒤에 ABLE 가 없을 시 에러 2. PIPE 앞에 아무것도 없을 시 에러 3. PIPE 뒤에 아무것도 없을 시 에러</p>
<p>exe 시 erro 가 있으면 첫 erro 다음 node 가 blame 대상 erro 가 마지막 node 면 newline 이 blame 대상</p>
<h1>exe</h1>
<p>red - in, out 에 대해 해당 파이프 내에서 가장 마지막만 실행 된다 - &lt;, &lt;&lt; 가 여려개일경우 그 중 가장 마지막이 적용 - &gt;, &gt;&gt; 가 여러개일 경우 그 중 가장 마지막이 적용 - zsh 는 중복으로 실행한다 - | 전에 &gt;, &gt;&gt; 가 있는 경우 | 로 아무 결과도 넘어오지 않는다 - zsh 는 양쪽에 다 넘어가는데 bash 는 가로챈다 - | 다음에 &lt;, &lt;&lt; 가 있는경우 | 에서 아무것도 받지 않는다 - zsh 는 다 넘겨받는데 bash 는 가로막는다</p>
<ol>
<li>cmd 순회하면서 &lt;&lt; (heredoc) 있는지 확인</li>
<li>&lt;&lt; 가 있으면 각각 도큐먼트 파일 만들기
<ul>
<li>해당 파일의 이름은 limit + 숫자 join 하기</li>
<li>굳이 itoa 하지 않더라도 0번만 아니면 괜찬</li>
<li>heredoc 처리가 끝나 파일생덩이 끝난 후 cmd-&gt;rad 의 file 을 파일이름으로 바꾸기</li>
</ul>
</li>
<li>cmd 개수만큼 pipe 만들기</li>
<li>cmd 개수만큼 fork()</li>
<li>각각의 프로세스안에서 처리하기
<ul>
<li>red 가 있을경우
<ul>
<li>red in, out 중 마지막 찾기</li>
<li>open 한 뒤 redirect 하기</li>
</ul>
</li>
<li>red 가 없는경우
<ul>
<li>이전, 이후 파이프와 잇기</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1>허용함수</h1>
<h2>compile</h2>
<pre><code class="language-makefile">READLINE_LIB    = -lreadline -L/usr/local/opt/readline/libREADLINE_INC    = -I/usr/local/opt/readline/include
</code></pre>
<pre><code class="language-makefile">READLINE_LIB    = -lreadline -L /Users/$(USER)/.brew/opt/readline/libREADLINE_INC    = -I /Users/$(USER)/.brew/opt/readline/include
</code></pre>
<p>중 하나를 옵션으로 넣어야 함</p>
<h2>readline/readline.h</h2>
<p><a href="https://tiswww.cwru.edu/php/chet/readline/rltop.html">https://tiswww.cwru.edu/php/chet/readline/rltop.html</a> ** compile 시 -lreadline 붙이기**</p>
<h3>readline</h3>
<pre><code class="language-c">char *readline(const char *prompt)
</code></pre>
<p>터미널에 prompt 내용이 표시되며 그 뒤로 string 을 입력 받는다 prompt 는 빈 문자열이나 null 이 들어갈 수있다 입력받은 문자열은 malloc 되어진 문자열로 반환된다 사용된 반환값은 free 되어야한다</p>
<h3>return</h3>
<p>개행을 치기 전까지의 읽은 string을 malloc 으로 할당하여 반환한다 아무것도 치지 않을 경우 빈 문자열을 반환한다 라인을 읽는동안 EOF가 있으며 빈 문자열일경우 null 을반환 라인을 읽는동안 EOF가 있으며 비어있지 않은경우 newline 으로 처리</p>
<h3>rl_clear_history</h3>
<pre><code class="language-c">void rl_clear_history(void)
</code></pre>
<p>히스토리를 지운다</p>
<h3>rl_on_new_line</h3>
<pre><code class="language-c">int rl_on_new_line(void)
</code></pre>
<p>update funtion 에게 새로운(빈) 줄로 이동했다고 알린다 주로 새 줄을 outputting 한 수 사용한다</p>
<h3>return</h3>
<p>성공시 0 실패시 -1</p>
<h3>rl_replace_line</h3>
<pre><code class="language-c">void rl_replace_line(const char *text, int clear_undo)
</code></pre>
<p>rl_line_buffer 을 text 로 대체(replace) 한다 포인트와 마크는 가능한 보존된다 clear_undo 가 0 이 아닐 경우 현재 줄과 연결된 undo list 가 지워진다</p>
<h3>rl_redisplay</h3>
<pre><code class="language-c">void rl_redisplay(void)
</code></pre>
<p>rl_line_buffer 의 현재 내용을 반영하도록 화면에 표시되는 내용을 변경한다</p>
<h3>add_histroy</h3>
<pre><code class="language-c">void add_history(const char *string)
</code></pre>
<p>문자열을 history list 의 맨 뒤에 추가한다</p>
<h2>stdio.h</h2>
<h3>printf</h3>
<h3>perror</h3>
<h2>stdlib.h</h2>
<h3>malloc</h3>
<h3>free</h3>
<h3>exit</h3>
<h3>getenv</h3>
<pre><code class="language-c">char *getenv(const char *varname)
</code></pre>
<p>varname 항목의 환경변수 리스트를 검색한다</p>
<h3>return</h3>
<p>현재 환경에 지정괸 varname 의 값을 포함한 문자열을 반환 존재하지 않을 시 null 을 반환, errno 설정</p>
<h2>unistd.h</h2>
<h3>write</h3>
<h3>read</h3>
<h3>access</h3>
<h3>fork</h3>
<h3>getcwd</h3>
<pre><code class="language-c">char *getcwd(char *buf, size_t size)
</code></pre>
<p>현재 작업디렉토리의 full path 를 null-terminated 문자열로 반환 저장할 buf 와 buf 의 사이즈를 인자로 받음 char * 를 사용 시 반환값을 대입 char [] 를 사용 시 buf 에 입력</p>
<h3>return</h3>
<p>현재 작업 디렉토리의 경로를 반환 size 의 크기가 저장할 경로의 크기보다 작으면 null 반환, errno 설정 buf 가 null 일 시에 malloc 로 할당된 메모리에 저장하여 반환</p>
<h3>chdir</h3>
<pre><code class="language-c">int chdir(const char *path)
</code></pre>
<p>현재 작업 디렉토리를 변경 상대, 혹은 절대 디렉토리</p>
<h3>return</h3>
<p>성공시 0 실패시 -1, errno 설정</p>
<h3>unlink</h3>
<h3>execve</h3>
<h3>dup</h3>
<h3>dup2</h3>
<h3>pipe</h3>
<h3>isatty</h3>
<pre><code class="language-c">int isdtty(int fd)
</code></pre>
<p>파일지정자 fd 를 사용중인지 확인</p>
<h3>return</h3>
<p>사용중일시 1 사용하지 않을 시 0</p>
<h3>ttyname</h3>
<pre><code class="language-c">char *ttyname(int fd)
</code></pre>
<p>열려있는 파일지정자 fd 에 대한 터미널의 이름을 반환</p>
<h3>return</h3>
<p>가져오는데 성공하면 터미널의 이름을 반환 실패하면 null, errno 설정</p>
<h3>ttyslot</h3>
<pre><code class="language-c">int ttyslot(void)
</code></pre>
<p>/etc/ttys 파일의 항목 중 호출 프로세서에서 사용중인 터미널의 인덱스를 반환</p>
<h3>return</h3>
<p>/etc/ttys 파일의 항목 중 호출 프로세서에서 사용중인 터미널의 인덱스(slot number)를 반환 실패시 unix v6, v7, BSD-like system 에서는 0을 반환 실패시 V-like system 에서는 -1 을 반환</p>
<h3>사설</h3>
<p>legacy 함수 ttyslot 은 어떤 파일의 현재의 user’s entry 의 인덱스를 반환한다. - what file?? unix v6 에서는 /etc/ttys 파일을 사용했다 이 파일은 init 프로그램에 의해 읽혀지며 각각 terminal line 이 무슨 역할을 하는지를 알려준다 각 line 은 3개의 char 로 구성되어있다 첫번째 char 는 0 또는 1 이다 - 0 의 의미는 “무시” 이다 두번째 char 는 터미널 번호를 의미한다 - /dev/tty8 처럼 세번째 char 는 회선속도의 순서를 나타내는 getty 의 인자이다 - getty 는 get tty 의 줄임말로 터미널을 관리하는 유닉스 프로그램이다 - 로그인을 하게 해 준다..? - - (설명은 모르겠음) 일반적인 line 의 모양은 “18-” 처럼 생겼다 어떤 line 에 의지하는것은 1 을 0 으로 바꾼 뒤 초기화 신호를 보내고 다시 바꾼뒤 초기화 신호를 보내서 해결했다…????</p>
<p>unix v7 에서 포멧이 변경되었다 두번째 char 이 getty 의 인자로 바뀌고 - 0, 4 (설명은 모르겠음) 마지막에 tty 의 이름이 붙었다 일반적은 line 의 모양은 “14console” 처럼 생겼다</p>
<p>반면 /etc/utmp 라는 현재 로그인한 유저의 리스트가 담긴 파일이 있다 이것은 사이즈가 고정되어 있으며 파일의 인덱스는 ttyslot 호출로 /etc/ttys 에서 줄번호를 찾기위해 login 명령어로 결정되었다 (1 부터 시작한다)</p>
<p>결과적으로 ttyslot 은 /etc/ttys 파일에서 호출프로세스의 제어 터미널 인덱스를 반환한다 이는 보통 /etc/utmp 에서 현재 사용자 항목의 인덱스와 동일하다 BSD 는 여전히 /etc/ttys 파일이 있지만 v-like system 을 그렇지 않기에 참조할 수 없다 따라서 이러한 시스템의 ttyslot 설명에는 사용자 계정 데이터 베이스에서 현재 사용자의 인덱스를 반환한다고 나와있다</p>
<h2>fcntl.h</h2>
<h3>open</h3>
<h3>close</h3>
<h2>sys/wait.h</h2>
<h3>wait</h3>
<h3>waitpid</h3>
<h3>wait3</h3>
<pre><code class="language-c">pid_t wait3(int *status, int options, struct rusage *rusage)
</code></pre>
<p>wait 과 동일 종료된 프로세스의 상태와 자원 사용량을 알려줌</p>
<h3>return</h3>
<p>성공시 pid 실패시 -1 option 으로 WNOHANG 가 입력되었으며 자식프로세스가 아직 종료되지 않았을 경우 0</p>
<h3>wait4</h3>
<pre><code class="language-c">pid_t wait4(pid_t pid, int *status, int options, struct rusage *rusage)
</code></pre>
<p>waitpid 와 동일 종료된 프로세스의 상태와 자원 사용량을 알려줌</p>
<h3>return</h3>
<p>성공시 pid 실패시 -1 option 으로 WNOHANG 가 입력되었으며 자식프로세스가 아직 종료되지 않았을 경우 0</p>
<h2>signal.h</h2>
<h3>signal</h3>
<pre><code class="language-c">void (*signal(int sig, void (*func)(int)))(int)
</code></pre>
<p><code>signal(SIGINT, sig_func)</code></p>
<p>int sig 에 해당하는 signal 이 들어왔을 때 처리를 담당 func 에 함수를 넣어 시그널이 들어왔을 때 함수를 호출한다 해당 함수의 인자로는 해당 시그널이 들어간다 func 인자 - SIG_DFL : 기존의 방법을 따른다 - SIG_IGN : 시그널을 무시한다 - 함수이름 : 해당 함수를 호출한다</p>
<p>SIGKILL, SIGSTOP 은 handling 을 할 수 없다</p>
<h3>return</h3>
<p>성공시 이전에 실행되던 작업이 반환된다 즉 신호 처리 이후 반환값을 실행하면 이전 작업이 계속 진행된다 실패시 SIG_ERR 가 반환되며 errno 가 설정된다</p>
<h3>sigaction</h3>
<pre><code class="language-c">int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact)
</code></pre>
<p>int signum : 시그널 번호 struct sigaction *act : 설정할 행동, 새롭게 지정될 행동 struct sigaction *oldact : 이전행동, 함수 호출 이전의 행동이 저장</p>
<pre><code class="language-c">struct sigaction{    void (*sa_handler)(int);    void (*sa_sigaction)(int, siginfo_t *, void *);    sigset_t sa_mask;    int sa_flags;    void (*sa_restorer)(void);}
</code></pre>
<p>sa_handler : 시그널을 처리하기 위한 함수, SIG_DFL, SIG_IGN, 혹은 함수가 들어감 sa_sigaction : sa_flags 가 SA_SIGINFO 일때 handler 대신 작동하는 함수 sa_mask : 시그널을 처리하는 동안 블락할 시그널 집합의 마스크 - 블락된 시그널은 해당 처리가 끝난 뒤 다시 처리된다 sa_flags : 옵션, or 연산자로 여러개를 동시에 사용 가능 - SA_NOCLDSTOP : signum 이 SIGCHILD 일 경우 자식이 멈추었을때 부모에 SIGCHILD 가 전달되지 않는다 - SA_ONESHOT, SA_RESETHAND : 시그널을 받으면 설정된 행동을 취한 후 SIG_DFL 로 변경 - SA_RESTART : 시그널에 의해 방해 받은 시스템호출은 시그널 처리가 끝난 뒤 재시작한다 - SA_NOMASK, SA_NODEFER : 시그널을 처리하는 동안 전달되는 시그널은 블락되지 않는다 - SA_SIGINFO : handler 대신 sigaction 이 동작됨, sigaction 은 더 많은 인자를 받아 처리할 수 있으며 이는 시그널번호, 시그널이 만들어진 이유, 시그널을 받는 프로세스의 정보가 들어감</p>
<h3>return</h3>
<p>성공시 0 실패시 -1 반환</p>
<h3>sigemptyset</h3>
<pre><code class="language-c">int sigemptyset(sigset_t *set)
</code></pre>
<p>시그널집합 변수의 모든 내용을 삭제한다</p>
<h3>return</h3>
<p>성공시 0 실패시 -1</p>
<h3>sigaddset</h3>
<pre><code class="language-c">int sigaddset(sigset_t *set, int signum)
</code></pre>
<p>set 에 signum 을 넣는다</p>
<h3>return</h3>
<p>성공시 0 실패시 -1 반환</p>
<h3>kill</h3>
<pre><code class="language-c">int kill(pid_t pid, int signum)
</code></pre>
<p>해당 pid 를 가진 프로세스에 signum 신호를 보낸다 shell 에서의 kill 과 같은 동작을 시키려면 signum 에 SIGKILL 을 넣으면 된다</p>
<p>pid - 양수 : 지정한 pid 에 시그널 전송 - 0 : 함수를 호출하는 프로세스와 같은 그룹의 모든 프로세스에 시그널 전송 - -1 : 함수를 호출하는 프로세스가 전송할 수 있는 모든 프로세스에 시그널 전송 - -1 이외의 음수 : 절대값을가지는 프로세스에 시그널 전송</p>
<h3>return</h3>
<p>성공시 0 실패시 -1 반환</p>
<h2>sys/stat.h</h2>
<h3>stat</h3>
<p><a href="https://www.it-note.kr/173">https://www.it-note.kr/173</a> #### stat #### lstat #### fstat</p>
<pre><code class="language-c">int stat(const char *path, struct stat *buf)int lstat(const char *path, struct stat *buf)int fstat(int fd, struct stat *buf)
</code></pre>
<pre><code class="language-c">struct stat{dev_t st_dev; /*ID of device containing file */ino_t st_ino; /*inode number*/mode_t st_mode; /*protection*/nlink_t st_nlink; /*number of hard links*/uid_t st_uid; /*user ID of owner*/gid_t st_gid; /*group ID of owner*/dev_t st_rdev; /*device ID (if special file)*/off_t st_size; /*total size, in byte*/blksize_t st_blksize; /*blocksize for file system I/O*/blkcnt_t st_blocks; /*number of 512B blocks allocated*/time_t st_atime; /*time of last access*/time_t st_mtime; /*time of last modification*/time_t st_xtime; /*time of last status change*/}
</code></pre>
<p>파일의 크기, 권한, 생성일시, 최종 변경일 등 파일의 상태나 정보를 얻는 함수</p>
<p>symlink 파일인 경우 - stat : 원본의 정보를 가져옴 - lstat : 심볼릭 링크 파일의 정보를 가져옴</p>
<p>fstat 은 파일 디스크립터를 받으며 stat 와 같게 작동</p>
<h3>return</h3>
<p>성공시 0 실패시 -1 반환, errno 설정</p>
<h2>dirent.h</h2>
<h3>opendir</h3>
<pre><code class="language-c">DIR *opendir(const char *name)
</code></pre>
<p>지정한 디렉토리를 연다, 즉 디렉토리 내의 파일과 서브디렉토리를 검색</p>
<h3>return</h3>
<p>성공시 디렉토리 정보 구조체인 DIR 포인터 반환 실패시 null 반환</p>
<h3>readdir</h3>
<pre><code class="language-c">struct dirent *readdir(DIR *dir)
</code></pre>
<pre><code class="language-c">struct dirent{    long d_ino; // inode 번호    __kernel_off_t d_off; // 디렉토리 내에서의 오프셋    unsigned short d_reclen; // 엔트리의 길이    char d_name[256]; // 파일이나 디렉토리 이름};
</code></pre>
<p>opendir 로 연 디렉토리에 대해 안에있는 모든 파일과 디렉토리 정보를 구한다 첫 호출시에는 첫번째 파일에 대한 정보를 구하며 반복문을 통해 사용할 수 있다</p>
<h3>return</h3>
<p>성공시 파일, 혹은 디렉토리의 정보를반환 실패시 null 반환</p>
<h3>closedir</h3>
<pre><code class="language-c">int closedir(DIR *dir)
</code></pre>
<p>opendir 로 연 DIR * 를 닫는다</p>
<h3>return</h3>
<p>성공시 0 실패시 -1 반환</p>
<h2>string.h</h2>
<h3>strerror</h3>
<h2>sys/ioctl.h</h2>
<h3>ioctl</h3>
<pre><code class="language-c">int ioctl(int fd, unsigned ling request, ...)
</code></pre>
<p>device driver 와 통신하기 위한 system call 함수 - 디바이스 드라이버 : 장치와 어플리케이션을 이어줌</p>
<p>fd : open 한 디바이스의 fd 값 request : 디바이스에 전달할 명령 - 매크로가 지정되어있다 - _IO(type, nr) : 세번째 인자가 필요하지 않을 때 - _IOR(type, nr, size) : 세번째 인자가 드라이버에서 read 할 때 - _IOW(type, nr, size) : 세번째 인자가 드라이버에서 write 할 때 - _IORW(type, nr, size) : 세번째 인자가 드라이버에서 read, write 할 때 - type : 디바이스 드라이버 사이에서 ioctl 함수의 명령어가 서로 유일한 값을 가질 수 있도록 하는 8비트 매직넘버 - nr : 명령어를 구분하기 위해 사용되는 명령어마다의 유일한 정수값 - size : 디바이스 드라이버로 데이터가 넘어오거나 사용자 영역으로 넘겨줄 때 사용하는 데이터크기 (바이트)</p>
<p>struct ifreq 구조체를 매개변수로 받아 정보를 저장할 수 있다</p>
<h3>return</h3>
<p>성공시 0 실패시 -1</p>
<h2>termios.h</h2>
<p><a href="https://80000coding.oopy.io/13bd7bb7-3a7f-4b51-b84a-905c47368277">https://80000coding.oopy.io/13bd7bb7-3a7f-4b51-b84a-905c47368277</a></p>
<p>canonical input mode (표준 입력 모드) - 입력이 들어오면 개행, 혹은 EOF 와 같은 종료 문자가 나올 때 까지 처리를 기다리다가 한번에 한줄의 문장을 처리한다 noncanonical input mode (비표준 입력 모드) - 문자가 행으로 그룹화 되지 않으며 ERAGE 와 KILL 처리가 수행되지 않는다 - 문자를 읽자마자 바로 처리하는 방식</p>
<p>터미널의 속성을 가져와야 한다 termios 구조체</p>
<pre><code class="language-c">struct termios{    tcflag_t c_iflag; /* input flags */    tcflag_t c_oflag; /* output flags */    tcflag_t c_cflag; /* control flags */    tcflag_t c_lflag; /* local flags */    cc_t c_cc[NCCS]; /* control chars */    speed_t c_ispeed; /* input speed */    speed_t c_ospeed; /* output speed */};
</code></pre>
<p>여기서 터미널의 거의 모든 속성을 다룰 수 있다 EOF 와 같은 문자의 input 을 다루어야 하기에 input flag 를 확인한다</p>
<h3>tcgetattr</h3>
<pre><code class="language-c">int tcgetattr(int fd, struct termios *termios)
</code></pre>
<p>터미널 파일에 대한 속성을 얻어 termios 구조체에 저장한다</p>
<p>fd : terminal fild discriptor termios : 속성을 저장할 구조체 포인터</p>
<h3>return</h3>
<p>성공시 0 실패시 -1, errno 설정</p>
<h3>tcsetent</h3>
<pre><code class="language-c">int tcsetattr(int fd, int optional_actions, struct termios *termios)
</code></pre>
<p>터미널 파일에 대한 속성을 설정한다</p>
<p>[[42/c_iflag.png]] (반향 == echo) 이외 설정은 man termios 확인</p>
<p>기본적으로 모든 설정은 on 되어있는 상태이다</p>
<pre><code class="language-c">termios.c_lflag &amp;= ~(ICANON | ECHO);
</code></pre>
<p>와 같은 방법으로 off 시켜준다 - &amp;= : &amp; 의 이항연산자, and 연산으로 양쪽 비트가 전부 1 이면 1로, 둘중 하나라도 0 이면 0으로 바꾼다 - ~ : not 연산 - | : or 연산, 둘 중 하나라도 1 이면 1로 바꾼다</p>
<p>fd : 터미널 파일 fd optional_actions : 동작 선택 - TCSNOW : 속성을 바로 변경한다 - TCSADRAIN : 송신을 완료한 후 변경한다 - TCSFLUSH : 송수신을 완료한 후 변경한다 termios : 터미널 속성이 저장된 포인터</p>
<h3>return</h3>
<p>성공시 0 실패시 -1, errno 설정</p>
<h2>term.h</h2>
<p><a href="https://hyeonski.tistory.com/6">https://hyeonski.tistory.com/6</a> 컴파일 시 -lncurses 옵션</p>
<h3>tgetent</h3>
<pre><code class="language-c">int tgetent(char *bp, const char *name)
</code></pre>
<p>name 에 대한 항목을 가져옴</p>
<h3>return</h3>
<p>성공시 1 항목이 없는 경우는 0 terminfo 데이터 베이스를 찾을 수 없는 경우 -1 반환</p>
<h3>tgetflag</h3>
<pre><code class="language-c">int tgetflag(char *id)
</code></pre>
<p>해당 id가 사용 가능한지 알려준다</p>
<h3>return</h3>
<p>사용 가능하면 1 불가능하면 0</p>
<h3>tgetnum</h3>
<pre><code class="language-c">int tgetnum(char *id)
</code></pre>
<p>tgetflag 와 동일</p>
<h3>return</h3>
<p>사용이 불가능 하면 -1 반환</p>
<h3>tgetstr</h3>
<pre><code class="language-c">char *tgetstr(char *id, char **area)
</code></pre>
<p>tgetflag 와 동일 해당 내용을 문자열로 출력 area 에 저장</p>
<h3>return</h3>
<p>실패시 null 반환</p>
<h3>tgoto</h3>
<pre><code class="language-c">int tputs(const char *str, int affcnt, int (*putc)(int))
</code></pre>
<p>패딩 인포메이션을 str 에 적용</p>
<p>affcnt : 영향을 받는 행의 번호 int (*putc)(int) : char 가 한번에 하나씩 전달되는 putchar 와 동일한 효과</p>
<h3>return</h3>
<p>str 이 null 이면 에러 반환</p>
<h3>tputs</h3>
<h2>libft enable</h2>

        </article>
        
        
    </main>

    

<footer>
    <p>
        Author: Dongyoon Kim - <a href="https://biisairo.github.io/">Home</a> - <a href="https://github.com/Biisairo">GitHub</a> - <a
            href="mailto:rlark1224@naver.com">Mail</a>
    </p>
    <img src="https://hits.sh/biisairo.github.io.svg?label=Visitor&color=000000">
</footer>

</body>

</html>