# 1. 웹 브라우저가 메시지를 만든다

## 1. HTTP 리퀘스트 메시지를 작성한다

### 1. URL 에 입력에서 시작

- URL
    - http:, https:, file:, mailto: 등 으로 시작
- 사용하는 프로토콜에 맞는 도메인명을 사용

### 2. URL 해독

- 브라우저가 서버에 보내는 리퀘스트를 작성하기 위한 첫 단계
- URL 의 구성 요소
    - {프로토콜이름}://{서버이름}[/{디렉토리이름}/{파일명}]

### 4. HTTP 의 기본 개념

- 클라이언트 → 서버 : request 메시지
    - 무엇을
        - URI
    - 어떻게 해서
        - 메소드
        - GET, POST 등
    - 보충정보
        - 헤더 필드에 기재
- 서버 → 클라이언트 : response 메시지
    - 실행 결과
        - 스테이터스 코드
    - 헤더
    - 데이터

### 5. HTTP 요청 메시지 작성

- 리퀘스트 라인
    - 요청 메시지의 첫번째 줄
    - {메소드}{ }{URI}{ }{HTTP버전}
- 메시지 헤더
    - 두번째 이후의 줄
    - 부가적인 정보
    - 날짜, 데이터의 종류, 언어, 압축형식 등
- 공백 줄
    - 헤더와 본문을 구분하는 줄
- 메시지 본문
    - POST 등의 메소드에서 서버로 데이터를 전달하는 영역

### 6. 응답

- 스테이터스 코드
    - 정상종료인지 오류인지를 나타내는 코드
- 데이터
    - 태그
        - 화면에 정보를 표시할 때 해당 형태의 데이터를 찾아 넣음
- 하나의 request 메시지당 하나의 URI가 있음
    - 한번에 하나의 파일을 전송하게 됨
    - 여러개의 파일을 받을때는 여러번의 요청을 보냄

## 2. 웹 서버의 IP 주소를 DNS 서버에 조회한다

### 1. IP 주소의 기본

- 브라우저에서 HTTP 메시지를 작성한 후 OS 로 하여금 대상의 웹 서버로 전송
    - 브라우저에는 송출하는 기능은 없음
- URL 에 쓰여있는 서버의 도메인명에서 IP 주소를 찾아냄
- TCP/IP
    - 인터넷, 인트라넷 등의 기초가 되는 개념
    - 하나의 네트워크에 ‘라우터’를 이용하여 연결
- IP 주소
    - 네트워크 번호 + 호스트 번호
    - 32 비트의 디지털 데이터
    - 주로 . 으로 구분하여 4칸의 10진수로 표현
        - ex) 10.12.0.1
    - 어디까지가 네트워크 번호인지, 호스트 번호인지 알기 위해 넷마스크를 사용
- 넷마스크
    - 2진수로 IP 주소와 넷마스크를 비교해 넷마스크의 1 인 부분이 네트워크 번호, 이외의 부분이 호스트 번호
    - 둘을 AND 연산하면 네트워크 번호가 나온다
    - 호스트 번호가 전부 0 이면 특정 기기가 아닌 서브넷 자체를 가리킴
    - 호스트 번호가 전부 1 이면 서브넷 기기 전체에 패킷을 보내는 ‘브로드캐스트’
- 데이터의 운반
    - 메시지를 송신하면 서브넷 안의 허브를 통해 송신측의 가장 가까운 라우터로 전달
    - 라우터는 수신 상대의 IP 에 따라 다음 라우터로 데이터를 전송
    - 최종적으로 수신자가 있는 서브넷의 허브로 전달 후 수신

### 2. 도메인명과 IP 주소를 구분하여 사용하는 이유

- 실제 데이터를 전송할때는 IP 주소를 사용하여 전송 함
- IP 주소는 사람이 기억하기 어렵기 때문에 쉽게 사용할 수 있는 URL 주소를 사용 함
- DNS (Domain Name System)
    - 도메인명과 IP 주소를 변환시켜주는 서버

### 3. Socket 라이브러리가 IP 주소를 찾는 기능을 제공한다

- DNS 리졸버 (리졸버)
    - DNS 의 클라이언트에 해당
    - name resolution
        - DNS 를 사용해 IP 주소를 조사하는 것
    - socket 라이브러리의 gethostbyname 함수를 사용
- 리졸버는 Socket 라이브러리를 사용하여 만들어짐

### 4. 리졸버를 이용해여 DNS 서버를 조회한다

- 리졸버와 URL 를 입력하면 리졸버가 DNS 서버에 조회 메시지를 보내 IP 주소를 받아옴

### 5. 리졸버 내부의 작동

- 브라우저가 리졸버를 호출하면 브라우저의 제어권을 리졸버에게 넘겨줌
- 제어권을 받은 리졸버가 DNS 서버에 문의를 하기 위한 메시지를 작성
- 리졸버가 OS 에 포함된 프로토콜 스택을 호출하여 DNS 서버에 메시지를 전송
    - 프로토콜 스택
        - 프로토콜 드라이버, TCP/IP 소프트웨어 등으로 불림
        - OS 내부에 내장된 네트워크 제어용 소프트웨어
- DNS 가 메시지를 받고 찾고자 하는 도메인의 IP 주소가 존재하면 다시 리졸버에게 IP 주소를 전송
- 리졸버가 메시지를 해독한 후 IP 주소를 추출하여 프로세스에 전달
- 프로세스는 IP 주소를 메모리에 저장
- 프로세스에게 제어권이 넘어감
- DNS 서버에 메시지를 전송할 때도 DNS 서버의 IP 가 필요하나 이는 이미 설정이 되어있음

## 3. 전 세계의 DNS 서버가 연대한다

### 1. DNS 서버의 기본 동작

- 클라이언트가 보내는 조회 메시지
    - (a) 이름
        - 서버 이름이나 메일 배송 목적지(@뒤에오는 부분)
    - (b) 클래스
        - 인터넷 이외의 네트워크에서도 DNS 를 사용하고자 고안된 부분
        - 현재는 인터넷 이외의 기능들은 소멸하여 사용하지 않음
        - 항상 인터넷을 나타내는 ‘IN’ 을 사용
    - (c) 타입
        - 이름에 사용되는 정보의 종류
        - 타입에 따라 반환되는 정보가 달라짐
        - A (address) : IP 주소
        - MX : 메일 타입
        - PTR : IP 주소에서 이름을 조사
        - CANME : 이름에 닉네임 (alias) 를 붙임
        - NS : DNS 에 IP 주소를 등록
        - SOA : 도메인 속성 정보를 등록
- 리소스 레코드
    - 정보가 등록된 기록
    - 실제는 설정 파일등을 사용하여 저장함

### 2. 도메인의 계층

- 실제로는 많은 도메인을 등록하기 위해 정보를 분산시켜 다수의 DNS 서버에 등록하고 다수의 DNS 서버들을 연동하여 정보를 찾아냄
- 도메인명
    - www.a.b.c 와 같이 점과 글자들로 나누어진 계층 구조를 가짐
    - 계층 하나하나를 도메인 이라고 함
    - c 도메인 아래 b 도메인 아래 a 도메인 아래 www 도메인 의 구도
- DNS 는 하나의 도메인을 일괄적으로 취급하고 관리
    - 하나의 도메인을 분할할 수 없음
    - 하나의 DNS 서버에 여러개의 도메인을 저장
- 하위 도메인
    - [example.co.kr](http://example.co.kr) 이라는 도메인이 있을 때
    - sub1.example.co.kr, [sub2.example.co.kr](http://sub2.example.co.kr) 과 같은 하위 도메인을 만들어 사용할 수 있음
- 예시
    - www.cyber.co.kr
        - kr
            - 최상위 도메인
            - 한국에 할당 되어있음
        - co
            - 국내의 도메인을 분류하기 위한 도메인
            - company, 즉 회사들을 나타냄
        - cyber
            - [co.kr](http://co.kr) 에서 해당 회사에 할당 된 도메인
        - www
            - 최하위 도메인
            - 회사 내의 서버의 이름

### 3. 담당 DNS 서버를 찾아 IP 주소를 가져온다

- 상위 도메인이 저장되어있는 DNS 서버부터 순차적으로 저장
- IP 를 찾을때는 도메인 이름의 상위 도메인이 저장되어있는 DNS 부터 순차적으로 탐색하여 최종 도메인이 저장되어있는 곳에서 IP 를 찾아냄
- 최상위 도메인의 위에는 ‘루트 도메인’ 이 있으며 루트 도메인부터 탐색을 시작함
- 도메인 이름에는 루트 도메인이 생략되어 있음
- 실제로 명시할 때는 도메인 이름 마지막에 . 을 붙여 www.xxx.yyy. 처럼 표기
- 모든 DNS 서버에는 루트 도메인의 DNS 서버를 연결하여 어느 클라이언트가 접근하든 루트 도메인의 DNS 로 접근 할 수 있도록 함
- IP 주소를 찾아오는 단계
    - 가장 가까운 DNS 서버에 접속하여 해당 도메인이름이 등록되어있는지 확인
    - 등록되어있지 않을 시 루트 도메인의 DNS 에 클라이언트의 메시지를 전송
    - 루트 도메인 DNS 는 최상위 도메인의 DNS 서버 주소를 반송
    - DNS 서버가 최상위 도메인의 DNS 서버에 클라이언트의 메시지를 전송
    - 최상위 도메인의 DNS 서버는 하위 도메인의 DNS 서버 주소를 반송
    - 위의 작업을 반복하며 클라이언트에서 가장 가까운 DNS 서버는 원하는 도메인 이름의 IP 를 취득
    - 취득한 IP 주소를 클라이언트에게 전송
- 위 과정에서 무조건 하나의 도메인이 하나의 DNS 서버에 있는것이 아님
- 하위 도메인이 상위 도메인과 같은 DNS 서버에 있을 시 한단계를 건너뛰고 바로 하위 도메인을 탐색

### 4. DNS 서버는 캐시 기능으로 빠르게 회답할 수 있다

- DNS 는 한번 조사한 도메인 이름은 캐시에 기록함
- 해당 DNS 에 같은 이름에 대한 요청이 들어왔을 때 탐색을 하지 않고 바로 전송해 줄 수 있음
- 들어온 이름이 도메인에 등록이 되어있지 않을 경우또한 캐시에 기록 해 두어 탐색을 하지 않고 해당 도메인이 존재하지 않음을 알림
- 캐시에 정보가 등록된 후 도메인이 바뀔 수 있음
    - 캐시의 정보가 항상 정확하지 않음
    - DNS 에서 클라이언트에 정보를 전달할 때 해당 내용이 캐시에 있던 내용인지 DNS 에서 탐색한 내용인지를 알려줌

## 4. 프로토콜 스택에 메시지 송신을 의뢰한다

### 1. 데이터 송.수신 동작의 개요

- IP 주소의 조사가 끝난 뒤 상대의 웹 서버에 접속을 OS 의 프로토콜 스택을 통해 요청
- 해당 요청은 웹 뿐이 아닌 모든 네트워크 어플리케이션에 공통으로 작동
- 소켓 라이브러리를 사용
    - 소켓
        - 데이터의 출입구
        - 데이터가 지나가는 통로를 파이프라고 생각했을 때 파이프의 양쪽 입구
    - 서버에서 소켓을 만들어 두면 클라이언트에서 소켓을 만들어 둘을 연결하게 됨
    - 데이터의 전송이 끝나면 서버나 클라이언트 한쪽에서 파이프를 분리하여 연결을 끊음
- 데이터 송.수신 단계
    - 소켓 생성
    - 접속
    - 송수신
    - 연결 종료

### 2. 소켓의 작성 단계

- 클라이언트에서 socket 라이브러리를 사용해 소켓을 생성
- 소켓 생성함수를 호출해서 나오는 디스크립터를 메모리에 저장
- 특정 소켓을 식별하여 사용할때 디스크립터를 사용

### 3. 파이프를 연결하는 접속 단계

- 클라이언트에서 socket 라이브러리의 connect 함수를 사용 해 서버에 연결
- connect 를 사용할 때는 연결할 소켓을 지정하는 디스크립터, 서버의 ip 주소, 포트번호가 필요함
- 디스크립터를 사용해 클라이언트의 어느 소켓을 서버에 연결할지를 결정
- ip 주소를 사용해 해당 서버에 접속
- 포트번호를 사용해 해당 서버의 특정 포트에 접속
    - 포트번호는 애플리케이션에 종류에 따라 미리 지정이 된 값이 있음
        - http 는 80 번
        - 메일은 25 번

### 4. 메시지를 주고받는 송.수신 단계

- 연결이 되고 나면 socket 을 write 함수를 사용해 데이터를 전송
- 데이터를 받을때는 read 함수를 사용해 데이터를 수신
    - 데이터를 저장하기 위해 수신 버퍼를 사용

### 5. 연결 끊기 단계에서 송.수신이 완료된다

- 브라우저가 데이터 수신을 완료하면 송.수신이 종료됨
- socket 의 close 함수를 사용해 소켓의 연결을 끊고 소켓을 말소시킴