# 3. 컴퓨터 시스템의 동작 원리

## 1. 컴퓨터 시스템의 구조

- 내부장치
    - CPU
    - 메모리
- 외부장치
    - 키보드
    - 마우스
    - 모니터 등등
- 외부장치에서 내부장치로 데이터를 읽어와 연산을 수행하고 이를 다시 외부장치로 출력
- 컴퓨터로의 입력을 input, 출력을 output 이라고 하며 외부장치를 입출력장치 라고도 한다
- 외부장치에는 각 장치를 제어하는 컨트롤러가 들어있으며 각각의 장치를 제어하는 작은 cpu 이다
- 컴퓨터의 프로그램이 제어되려면 프로그램에 메모리에 올라가 있어야 한다
- 운영체제는 컴퓨터가 부팅될 때 부터 항상 수행되어있어야 한다
- 운영체제의 모든 부분이 메모리에 상주하면 메모리의 낭비가 일어나며 운영체제의 핵심적인 부분을 제외한 부분은 필요에 따라 메모리에 올린다
- 이때 항상 메모리에 상주하는 핵심부분을 커널이라고 한다

## 2. CPU 연산과 I/O 연산

- 입출력장치의 io 연산은 입출력 컨트롤러가, 컴퓨터 내부의 연산은 cpu 가 담당
- 입출력 컨트롤러와 cpu 는 동시에 수행이 가능하다 (독립적이다)
- 로컬 버퍼 (local buffer)
    - 각 장치마다 장치를 제어하기 위한 장치 컨트롤러에는 장치에서 오고가는 데이터를 저장해 두기위한 메모리
- 외부 장치로부터 입력이 들어올때
    - 장치에서 처리된 데이터가 로컬 버퍼에 저장된 후 메모리에 전달
    - 이때 로컬 버퍼로부터 데이터를 읽어오는 일은 입출력 컨트롤러가 담당
    - 로컬 버퍼에 있던 데이터를 읽어오는 작업이 끝나면 장치 컨트롤러가 인터럽트를 발생시켜 cpu 에 보고
    - cpu 가 인터럽트를 감지하는 방법
        - cpu 는 메 시점 명령라인을 하나씩 읽어가며 수행
        - 매번 명령을 수행할 때 마다 cpu 옆에있는 인터럽트 라인을 확인
        - 인터럽트 라인에 인터럽트가 들어와있으면 명령을 수행하지 않고 인터럽트를 처리

## 3. 인터럽트의 일반적 기능

- 커널에는 인터럽트가 들어왔을때 해야할 일이 미리 전부 프로그래밍 되어있음
- 인터럽트가 발생하면 해당 인터럽트가 들어왔을 때 수행하도록 미리 정의된 코드를 찾아 수행
- 하드웨어 인터럽트
    - 컨트롤러 등 하드웨어 장치가 인터럽트를 발생
- 소프트웨어 인터럽트, 트랩(trap)
    - 소프트웨어가 인터럽트를 발생
    - 예외사항(execption)
        - 0 으로 나누는 등의 비정상적인 작업을 시도할때
        - 메모리 영역 밖으로 접근을 시도할때 등
    - 시스템 콜(system call)
        - 프로그램이 운영체제 내부에 정의된 코드를 실행하고 싶을 때 운영체제에 서비스를 요청하는 방법
        - ex) 프로그램에서 키입력을 받고자 하는 경우
    - 사용자의 프로세스로부터 cpu 의 제어권을 운영체제로 이양되어 처리
- 인터럽트 벡터 (interrupt vector)
    - 커널 내에서 해당 인터럽트의 처리를 위하여 인터럽트마다 번호를 정해 처리해야 할 코드를 가리키는 자료구조
- 인터럽트 처리 루틴 (interrupt service routine), 인터럽트 핸들러(interrupt handler)
    - 실제 처리해야할 코드가 정의된 곳

## 4. 인터럽트 핸들링 (interrupt handling)

- 인터럽트가 발생한 경우 처리해야 할 일의 절차
    - 프로그램이 실행되는 중 인터럽트 발생
    - 프로그램의 현재 상태를 PCB 에 저장
        - cpu 에서 실행중인 명령의 메모리 주소와 같은 정보
        - 프로세스 제어 블록(Process Contol Block: PCB)을 사용
            - 프로그램마다 존재
            - 프로그램의 어느 부분이 실행중이었는지 저장
            - 프로그램이 실행중이던 코드의 메모리 주소, 레지스터값, 하드웨어 상태 등이 저장
    - 인터럽트 처리가 끝난 후 PCB 에서 CPU 에 복원한 뒤 다시 프로그램을 수행
- 오늘날의 운영체제는 인터럽트가 발생 할 때만 실행됨
    - 부팅 후 정상상태가 되면 사용자의 프로그램에 의해서만 cpu 가 사용됨
    - 인터럽트가 발생할 때만 운영체제가 cpu 의 제어권을 가져감

## 5. 입출력 구조

- 입출력(I/O) 란 시스템이 컴퓨터 외부의 입출력 장치들과 데이터를 주고받는것을 말함
- 동기식 입출력 (synchronous I/O)
    - 입출력 요청이 들어왔을 때 입출력 작업이 완료된 후 프로그램이 후속 작업을 수행
    - cpu 가 입출력 연산이 끝날 때까지 기다리게 되며 자원이 낭비됨
    - 일반적으로 입출력이 완료될 때 까지 다른 프로그램에게 cpu 사용권을 넘겨 자원 낭비를 방지함
    - 입출력중인 프로그램을 봉쇄상태(blocked state) 로 전환시켜 cpu 를 할당하지 않게 됨
    - 동기화의 보장
        - 두 프로그램이 동시에 같은 입출력 장치에 연산을 요청할 때 우선순위가 꼬여 원하지 않는 결과가 나올 수 있음
        - 각 장치별로 큐(queue)를 두어 요청한 순서대로 처리가 되도록 한다
    - 입출력 장치의 일이 끝나면 cpu 에 인터럽트를 만들어 입출력이 완료되었음을 알림
    - 입출력이 완료되면 해당 프로그램의 봉쇄상태를 해제
- 비동기식 입출력
    - 입출력 연산을 요청한 뒤 연산이 끝나기를 기다리는 것이 아니라 cpu 의 제어권을 다시 프로그램에 돌려줌
    - 프로그램이 입출력결과를 사용하는 것이 아닌 다른 연산을 수행할 경우 사용
    - 이것과 무관하게 입출력이 끝나면 입출력장치는 인터럽트를 발생시켜 작업이 완료되었다는 것을 알림

## 6. DMA (Direct Memory Access)

- 메모리는 CPU 에서만 접근이 가능한게 원칙
- 프로그램이 메모리에 접근하기 위해서는 CPU 에 인터럽트를 발생시켜 cpu 로 하여금 접근을 하도록 해야함
- 입출력 장치가 버퍼에서 메모리로 데이터를 옮길 때 마다 인터럽트를 발생시키면 cpu 의 업무에 방해가 되게 됨
- cpu 이외에 메모리에 접근 가능한 장치를 두게 되며 이를 direct memory access (DMA) 라고 부른다
- 로컬버퍼에서 메모리로 데이터를 불러오는 과정을 cpu 가 아는 dma 가 맡게됨으로 cpu 가 인터럽트를 처리할 필요가 없게 됨
- DMA 는 byte 단위가 아닌 block 이라는 큰 단위로 메모리를 읽어온 후 cpu 에 인터럽트를 발생시켜 작업의 완료를 알려줌

## 7. 저장장치의 구조

- 주기억장치
    - RAM 같은 휘발성(volatile) 메모리
- 보조기억장치
    - 플레시메모리, CD, 하드디스크같은 비휘발성(nonvolatile) 메모리
- 보조기억장치의 용도
    - 파일시스템
        - 전원이 나가도 저장되어야 할 데이터들의 저장
    - 스왑 영역
        - 상대적으로 비싸고 용량이 적은 메모리를 아끼기 위해 당장 필요한 부분은 메모리에 올려두고 다른 데이터를 보조기억장치의 스왑 영역에 저장
        - 스왑 아웃 (swap out)
            - 데이터를 스왑 영역에 저장하는 일

## 8. 저장장치의 계층 구조

- primary memory
    - 레지스터 - 캐시 메모리 - 메인 메모리
    - 빠른 저장장치는 공간당 가격이 비싸 적은 용량만 사용
    - 전원이 꺼지면 사라지는 휘발성 메모리
- secondary memory
    - 가격이싸지만 속도가 느림
    - 전원이 꺼져도 남아있는 비휘발성 메모리
- 상위 저장장치에서는 필요한 데이터만 선별적으로 저장하여 사용
- 캐싱
    - 적은 용량을 사용하여 느린 저장장치의 성능을 향상시키는 기법
    - 느린 저장장치에 있는 내용 중 당장 사용하거나 빈번하게 사용하는 정보를 빠른 저장장치에 선별적으로 저장해 두 저장장치의 속도 차이를 매꾸는 방법

## 9. 하드웨어의 보안

- 우리가 사용하는 운영체제는 여러개의 프로그램이 동시에 돌아가는 다중 프로그래밍(multi-programming) 환경에서 동작
- 프로그램이 다른 프로그램의 실행을 방해하거나 프로그램간의 충돌을 막기위한 보안기법이 필요
- 사용자모드 (user mode)
- 커널모드 (kernel mode, system mode)
    - 운영체제가 cpu 의 제어권을 가지고 운영체제 코드를 실행하는 모드
    - 모든 종류의 명령어를 사용 가능
    - 메모리접근 등 중요한 정보에 접근할 수 있는 연산은 커널모드에서만 사용하도록함
- 커널모드를 사용해도 프로그램이 cpu 제어권을 가지고 실행중인 동안 위와같은 작업을 수행하면 실행이 되버림
- 모드비트 (mode bit)
    - cpu 내부에 모드비트를 두어 프로그램을 감시
    - 모드비트가 0 으로 세팅되어 있으면 커널모드
    - 모드비트가 1 로 세팅되어 있으면 사용자모드
    - 보안과 관련이 있는 명령어를 수행하기 전 모드비트를 확인 해 값이 0인 경우에만 수행
    - 운영체제가 사용자프로그램에 cpu 제어권을 넘길때 모드비트를 1으로 세팅 후 권한을 넘김
    - 인터럽트가 발생하면 cpu 제어권을 운영체제에게 넘기며 운영체제는 모드비트를 0으로 세팅 후 작업 수행
    - 특권명령
        - 위와같이 모드비트가 0일때만 사용할 수 있는 명령어
- 하드웨어 장치에서의 보안
    - 모든 입출력 명령은 특권명령
        - 허가되지 않은 사용자가 외부장치(하드디스크같은)에 접근하는걸 방지

## 10. 메모리 보안

- 여러 프로그램이 동시에 메모리에 올라가 실행되기 때문에 프로그램이 다른 프로그램이나 운영체제의 메모리영역을 침범하는걸 막아야 함
- 2개의 레지스터를 사용해 프로그램이 접근하려는 메모리 주소가 합법적인지 체크
    - 기준 레지스터 (base register)
        - 프로그램이 실행되는 동안 프로그램이 합법적으로 접근할 수 있는 영역의 가장 작은 주소가 저장
    - 한계 레지스터 (limit register)
        - 프로그램이 기준 레지스터의 주소부터 접근할 수 있는 영역의 범위가 저장
    - 위 두 레지스터에 저장된 값을 사용해 현재 접근하려는 메모리 주소가 합법적인지 확인
    - 이같은 방법은 메모리 영역이 연속적으로 위치하는 경우에만 사용
- 사용자의 프로그램이 cpu 를 가지고 있는동안 사용하는 기법으로 특권명령은 아님
- 하드웨어적으로 접근이 가능한지 체크하는 방식
- 커널모드에서는 무제한으로 메모리에 접근이 가능하다

## 11. CPU 보호

- 일반적으로 cpu 는 하나밖에 없기 때문에 하나의 프로그램이 무한반복을 하는 등 cpu 를 독점할 수 있다
- 타이머(timer) 라는 하드웨어를 사용
- 하나의 프로그램이 정해진 시간동안 cpu 를 점유하고 있으면 타이머가 인터럽트를 발생시켜 운영체제가 cpu 제어권을 가질 수 있도록 함
- 운영체제는 해당 프로그램으로부터 cpu 를 빼앗아 다른 프로그램에게 이양시킴
- 정해진 시간은 매 클릭 틱(click tick) 마다 1씩 감소하다 0 이 되는 순간 인터럽트 발생
- 로드 타이머 (load timer)
    - 타이머의 시간을 세팅하는 명령어
    - 특권명령에 속함
- 타이머는 시분할 시스템에서 프로그램이 현재 시간을 계산하기 위해서도 사용

## 12. 시스템 콜을 이용한 입출력 수행

- 입출력 명령은 전부 특권명령에 해당
- 사용자의 프로그램이 직접 사용할 수 없음
- 운영체제에 시스템 콜 이라는 서비스 대행을 요청
- 소프트웨어 인터럽트의 일종