# 6. CPU 스케줄링

## 0.

- 프로그램이 실행되는 과정
    - 메모리에 프로그램이 올라감
    - 프로그램 카운터(PC) 레지스터가 가리키는 주소의 코드를 한줄씩 수행
- 수행되는 기계어 명령어
    - CPU 에서 수행되는 명령
        - ex) add 명령
            - 두 값을 더해 저장하는 명령어
        - CPU 내에서 수행되기 때문에 수행속도가 빠르다
        - 사용자 프로그램에서 사용할 수 있는 일반 명령
    - 메모리 접근을 위한 명령
        - load 명령
            - 메모리의 값을 cpu 로 읽어들이는 명령어
        - store 명령
            - cpu 에서 계산된 결과값을 메모리에 저장하는 명령어
        - cpu 에서 수행되는 명령들 보다는 오래걸리나 비교적 짧은 시간이 소요
        - 사용자 프로그램에서 사용할 수 있는 일반 명령
    - 입출력을 동반하는 명령
        - 키보드에서 입력을 받거나 화면에 출력하는 등의 명령
        - 시간이 오래 걸린다
        - 특권명령으로 사용자프로그램이 직접 사용할 수 없고 운영체제를 통해서만 사용 가능
- CPU 버스트(burst)
    - 속도가 빠른 cpu명령어와 메모리 접근 명령어가 수행되는 단계들
- I/O 버스트
    - 속도가 느린 입출력 명령어가 실행되는 단계들
- 프로그램은 위의 두 과정이 반복되어 수행되며 실행됨
- CPU 바운드 프로세스
    - CPU 버스트가 I/O 버스트에 비해 더 많이, 길게 수행되는 프로세스
    - 계산 위주의 프로세스
    - 소수의 긴 cpu 버스트로 구성
- I/O 바운드 프로세스
    - I/O 버스트가 CPU 버스트에 비해 더 많이, 길게 수행되는 프로세스
    - 사용자로부터 인터렉션(interaction)을 계속 받아가면서 실행되는 대화형프로세스(interactive process)
    - 다수의 짧은 cpu 버스트로 구성
- 대부분의 프로세스는 짧은 cpu 버스트를 가진다
    - 즉 대부분의 프로세스는 대화형 프로세스이며 사용자에게 빠른 응답을 보여주어야 하기 때문에 우선적인 CPU 할당을 해 주어야 한다
    - CPU 스케줄링 시 I/O 바운드 프로세스의 우선순위를 높여주어야 한다

## 1. CPU 스케줄러

- 비선점형(nonpreemptive)
    - CPU 를 획득한 프로세스가 스스로 CPU 를 반납하기 전까지 CPU 를 빼앗기지 않는 방법
- 선점형(preemptive)
    - CPU 를 강제로 빼앗을 수 있는 방법
    - 할당시간(time quantum) 을 부여한 후 타이머 인터럽트를 발생시키는 방법
- CPU 스케줄링이 필요한 경우
    - 비선점형 방식
        - 실행 상태에 있던 프로세스가 봉쇄상태로 바뀌는 경우
        - 실행상태에 있던 프로세스가 종료되는 경우
    - 선점형 방식
        - 실행 상태에 있던 프로세스가 타이머 인터럽트에 의해 준비상태로 바뀌는 경우
        - I/O 요청에 의해 봉쇄상태에 있던 프로세스의 작업이 완료되어 준비상태로 바뀐경우

## 2. 디스패처 (dispatcher)

- 스케줄러에 의해 CPU 할당의 대상이 결정된 뒤 실제 CPU 를 이양하는 작업을 도와주는 코드
- 현재 수행중이던 프로세스의 문맥을 PCB 에 저장하고 새로운 프로세스의 PCB 에서 문맥을 복원한 후 해당 프로세스에 CPU 를 넘기는 과정을 진행
- 문맥이 복원 된 후에는 시스템의 상태를 사용자모드로 전환한 후 사용자 프로그램에게 CPU 의 제어권을 넘김
- 디스패치 지연시간(dispatch latency)
    - 하나의 프로세스를 정지 시키고 다른 프로세스에게 CPU 를 전달하는데 걸리는 시간
    - 문맥교환 오버헤드에 해당

## 3. 스케줄링의 성능 평가

- 시스템 관점의 지표
    - CPU 이용량, 처리량
- 사용자 관점의 지표
    - 소요시간, 대기시간, 응답시간 등 시간과 관련된 지표
- CPU 이용률 (CPU utilization)
    - 전체 시간 중 CPU 가 일을 한 시간의 비율
    - CPU 가 휴면(idle)상태에 머무르는 시간을 최소화 하는 것이 중요
- 처리량 (throughput)
    - 주어진 시간 동안 준비 큐 에서 기다리고 있는 프로세스 중 몇 개를 끝마쳤는지 (CPU 버스트를 완료한 프로세스의 개수)
    - CPU 의 서비스를 원하는 프로세스 중 몇 개가 원하는 만큼의 CPU 를 사용하고 CPU 버스트를 끝내 준비 큐 를 떠났는지를 측정산 것
    - 주어진 시간동안 더 많은 처리를 하려면 CPU 버스트가 짧은 프로세스에게 먼저 할당하는 것이 좋다
- 소요시간 (turnaround time)
    - 프로세스가 CPU 를 요청한 시점부터 자신이 원하는 만큼 CPU를 다 쓰고 CPU 버스트가 끝날 때 까지 걸린 시간
    - 준비 큐 에서 기다린 시간과 CPU 를 실제 사용한 시간의 합
- 대기시간 (waiting time)
    - CPU 버스트 기간 중 프로세스가 준비 큐 에서 CPU 를 얻기위해 대기한 시간의 합
    - 시분할 시스템에서는 타이머를 사용 해 하나의 프로세스가 CPU 를 연속적으로 사용할 수 없도록 막기 때문에 한번의 CPU 버스트 중에도 준비 큐 에서 기다린 시간이 있을 수 있음
- 응답시간 (response time)
    - 프로세스가 준비 큐에 들어온 후 첫번째 CPU 를 획득하기까지 걸린 시간
    - 대화형 시스템에 적합한 성능 척도

## 4. 스케줄링 알고리즘

- 선입선출(First Come First Served: FCFS) 스케줄링
    - 프로세스가 준비 큐에 도착한 순서대로 CPU 를 할당하는 방식
    - 콘보이 현상 (Convoy effect)
        - CPU 버스트가 긴 프로세스가 앞에있으면 뒤에있는 CPU 버스트가 짧은 프로세스들의 평균 대기시간이 길어지게 되는 현상
- 최단작업 우선 스케줄링 (Shortest Job First: SJF)
    - CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU 를 할당하는 방식
    - 프로세스들의 평균 대기시간을 가장 짧게 하는 최적 알고리즘으로 알려져 있음
    - 선점형 방식 : SJF 에서의 선점형 방식 (Shortest Remaining Time First: SRTF)
        - 준비 큐에서 CPU 버스트가 가장 짧은 프로세스가 도착하면 CPU 를 빼앗아 더 짧은 프로세스에게 부여하는 방식
    - 기아 현상 (starvation)
        - 짧은 CPU 버스트를 가지는 프로세스가 계속 준비 큐에 들어와 긴 CPU 버스트를 가진 프로세스가 영원히 CPU 를 할당받지 못하는 현상
- 우선순위 스케줄링 (priority scheduling)
    - 준비 큐에서 기다리는 프로세스 중 우선순위가 높은 순서대로 CPU 를 할당하는 방식
    - 우선순위 값(priority number) 를 통해 표시
    - 어느 기준에 우선순위를 두느냐에 따라 SJF 와 같은 스케줄링이 될 수도있다
    - 비선점형, 선점형으로 작동할 수 있다
    - 기아현상이 발생할 수 있다
    - 노화 기법 (aging)
        - 기아현상을 해결하기 위한 방법
        - 기다리는 시간이 길어지면 우선순위를 조금씩 높여 언젠가는 가장 높은 우선순위가 되어 CPU 를 할당 받을 수 있게 해주는 기법
- 라운드 로빈 스케줄링 (Round Robin Scheduling)
    - 프로세스가 연속적으로 사용할 수 있는 시간이 제한하는 기법
    - 해당 시간이 경과되면 프로세스로부터 CPU 를 회수 하며 준비 큐로 들어가게된다
    - 할당시간 (time quantum)
        - 프로세스마다 한번에 CPU 를 사용할 수 있는 최대 시간
    - 할당시간이 너무 긴 라운드 로빈 스케줄링은 FCFS와 같은 결과가 나게 됨
    - 할당시간이 너무 짧으면 잦은 문맥교환으로 인한 오버헤드가 커짐
    - 여러 종류의 이질적인 프로세스가 함께 실행되는 상황에서 효과적
- 멀티레벨 큐 (multi level queue)
    - 준비 큐를 여러개로 분할해 관리하는 방식
    - CPU 는 여전히 하나밖에 없으므로 어느 준비 큐에 있는 프로세스를 우선적으로 할당할지 스케줄링필요
    - 프로세스가 준비 큐에 들어갈 때 어느 큐에 넣어줄지 결정 필요
    - 성격이 다른 프로세스들을 별도로 관리하며 각 큐 별로 성격에 맞는 스케줄링을 각각 적용
    - 일반적으로 대화형 작업을 담당하는 전위 큐(foreground queue), 계산 위주의 작업을 담당하는 후위 큐(background queue) 로 분리
        - 전위 큐
            - 응답 시간을 짧게 하기 위해 라운드 로빈 스케줄링을 사용
        - 후위 큐
            - 응답 시간에 큰 의미가 없기에 FCFS 스케줄링을 사용
    - 각 큐에 대한 스케줄링
        - 고정 우선순위 방식 (fixes priority scheduling)
            - 큐에 우선순위를 부여해 스케줄링하는 방식
            - 우선순위가 낮은 큐는 우선순위가 높은 큐가 비어있을때 서비스하게 됨
        - 타임 슬라이스 방식 (time slice)
            - 큐에 대한 기아현상을 해소하기 위함
            - 각 큐에 CPU 시간을 적절히 분배
                - ex) 전위 큐에 80%, 후위 큐에 20% 를 부여
- 멀티레벨 피드백 큐 (Multilevel Feedback queue)
    - 준비 큐를 나눈다는 방식은 멀티레벨 큐와 동일하나 프로세스가 하나의 큐에서 다른 큐로 이동이 가능한 방식
    - 노화 기법을 큐에 적용할 수 있음
        - 우선순위가 낮은 큐에서 오래 기다리면 우선순위가 낮은 큐에 높은 우선순위를 부여
    - 멀티레벨 피드백 큐를 정의하는 기준
        - 큐의 수
        - 각 큐의 스케줄링 알고리즘
        - 프로세스를 상위 큐로 승격시키는 기준
        - 프로세스를 하위 큐로 강등시기는 기준
        - 프로세스가 도착했을 때 들어갈 큐를 정하는 기준
- 다중처리기 스케줄링 (multiple processor scheduling)
    - CPU 가 여러개인 시스템을 다중처리기 시스템(multi processor system) 이라고 함
    - 프로세스를 준비 큐에 한줄로 세워 각 CPU 가 알아서 다음 프로세스를 꺼내갈 수 있도록 할 수 있음
    - 프로세스별로 큐를 만들어 프로세스를 줄세울 수 있음
        - 이 경우 한 cpu 에 작업이 편중되는 현상이 생길 수 있음
        - 부하 균형 (load balancing)
            - cpu 별로 부하가 적절히 분산되도록 하는 메커니즘
            - 대칭형 다중처리 (symmetric multi processing)
                - 각 cpu 가 알아서 스케줄링을 하는 방식
            - 비대칭형 다중처리 (asymmetric multi processing)
                - 하나의 cpu 가 다른 cpu 들의 스케줄링 및 데이터 접근을 책임지는 방식
- 실시간 스케줄링 (real time scheduling)
    - 실시간 시스템(real time system) 에서는 각 작업마다 주어진 데드라인이 있어 정해진 시간안에 작업을 완료해야 하는 상황이 생김
    - 경성 실시간 시스템 (hard real time system)
        - 시간을 무조건 정확히 지켜야 하는 시스템
    - 연성 실시간 시스템 (soft real time system)
        - 데드라인이 존재하나 지키지 않더라도 위험한 상황이 발생하지 않는 시스템
    - EDF 스케줄링 (Earlist Deadline First)
        - 먼저 온 요청을 먼저 처리하기 보단 데드라인이 얼마 남지 않은 요청을 먼저 처리하는 방식

## 5. 스케줄링 알고리즘의 평가

- 큐잉 모델 (queueing model)
    - 이론가들이 수행하는 방식
    - 프로세스들의 도착률과 CPU 의 처리율을 기반으로 성능지표값(performance index) 인 CPU 의 처리량, 프로세스의 평균 대기시간등을 구하는 방식
- 시뮬레이션 (simulation)
    - 가상의 환경에서 CPU 스케줄링 알고리즘을 작성한 후 CPU 요청을 넣어 나오는 결과를 확인하는 방식
    - 가상의 요청이나 실제 시스템에서 추출한 요청값을 입력값으로 넣음
    - 트레이스 (trace)
        - 실제 시스템에서 추출한 입력값
- 구현 및 실측 (implementation & measurement)
    - 구현가들이 수행하는 방식
    - 운영체제 커널의 CPU 스케줄링을 수행하는 코드를 수정하여 직접 확인하는 방식