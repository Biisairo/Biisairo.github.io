# 8. 가상메모리

## 0.

- 가상 메모리 (virtual memory)
    - 0번지 부터 시작하는 프로세스 자기만의 메모리 주소 공간
- 각각의 프로세서는 가상 메모리를 가지고 있으며 실제 사용될때는 이를 물리 메모리나 스왑 영역에 올려서 사용한다

## 1. 요구 페이징 (demand paging)

- 프로그램 실행 시 당장 사용할 페이지만 메모리에 올려 사용하는 방식
- 특정 페이지를 cpu 의 요청에 따라 메모리에 적재
- 실제 사용중인 부분만 메모리에 적재하고 다른 부분은 스왑 영역에 존재
- 유효-무효 비트를 사용해 해당 페이지가 메모리에 올라와 있는지 표시
- 페이지 부재 (page fault)
    - cpu 가 참조 하려는 페이지가 메모리에 올라와있지 않은 (유효-무효 비트가 무효인) 상황
- 요구 페이징의 페이지 부재 처리
    - cpu 가 무효 페이지에 접근 요청
    - MMU 가 페이지 부제 트랩 (page fault trap) 발생
    - cpu 커널모드 진입
    - 운영체제의 페이지 부제 처리 루틴 (page fault handler) 실행
    - 적법한 페이지인지 확인
        - 사용하지 않는 영역의 페이지에 접근하거나 해당 페이지에 대한 접근 원한을 위반한경우 (protection violation) 프로세스를 종료시킴
    - 적법한 페이지로의 접근인 경우 물리적 메모리에서 비어있는 프레임을 할당받아 페이지를 적재
        - 비어있는 프레임이 없는 경우 사용하지 않는 프로세스의 페이지를 스왑 공간으로 이동(스왑 아웃)
    - 페이지 부재처리는 디스크-메모리간에 데이터 이동이 필요해 많은 시간이 걸림
        - cpu 제어권을 뺏긴 봉쇄상태에서 진행됨
    - 데이터의 이동이 끝난 뒤 해당 페이지의 유효-무효 비트를 유효로 설정한 뒤 해당 프로세스를 준비 큐로 이동
- 요구 페이징의 성능
    - 페이지 부재의 발생 빈도에 따라 성능차이가 결정 됨

## 2. 페이지 교체 (page replacement)

- 페이지 부제가 발생했을 시 메모리에 남은 프레임이 없을때 이미 적재된 페이지를 스왑 아웃 하는 과정
- 교체 알고리즘 (replacement algorithm)
    - 페이지 교체시 어떤 페이지를 스왑 아웃할지를 결정하는 알고리즘
    - 페이지 부제율을 최소화 하는 것이 목표
    - 가까운 시일에 참조될 가능성이 적은 페이지를 스왑아웃 하는 것이 좋음
- 페이지 참조열 (page reference string)
    - 참조되는 페이지들의 번호를 시간의 순서에 따라 나열한 것
    - 해당 번호의 페이지가 이미 메모리에 적재되어있으면 메모리에 적중 (hit) 되었다고 함
    - 메모리에 없는 경우 페이지 부재가 발생한 것
- 최적 페이지 교체
    - 빌레디의 최적 알고리즘 (Belady’s optomal algorithm)
    - 미래에 어떤 페이지가 참조될 지 알고있는 상황에서 사용
        - 오프라인 알고리즘
        - ↔ 온라인 알고리즘
    - 페이지 교체 시 적재되어있는 페이지 중 가장 나중에 참조가 되는 페이지를 스왑 아웃
    - 실제 시스템에서는 어떤 페이지를 참조할 지 모르기때문에 실제로 사용할 수 있는 알고리즘은 아님
    - 어떠한 알고리즘 보다 적은 페이지 부재율을 보장하며 다른 알고리즘의 성능에 대한 상한선을 나타냄
- 선입 선출 알고리즘
    - 페이지 교체 시 제일 먼저 올라온 페이지를 스왑아웃
    - 물리적 메모리에 제일 먼저 적재된 페이지를 스왑아웃
    - 먼저 들어온 페이지를 자주 참조하는 경우 잦은 스왑아웃이 생김
- LRU (least recently used) 알고리즘
    - 시간 지역성 (temporal locality)
        - 최근에 참조된 페이지가 가까운 미래에 다시 참조될 가능성이 높은 성질
    - 가장 오래전에 참조 된 페이지를 스왑아웃
- LFU (least frequently used) 알고리즘
    - 페이지의 참조 횟수로 교체시킬 페이지를 정하는 방식
    - 적재 되어있는 페이지 중 과거에 참조 횟수가 가장 적었던 페이지를 스왑아웃
    - incache-LFU
        - 페이지가 물리적 메모리에 적재된 이후부터 카운트
        - 해당 페이지가 스왑아웃 되고 다시 적재되면 1부터 다시 카운트함
    - perfect-LFU
        - 메모리에 적재된 여부와 상관 없이 실제 해당 페이지를 참조한 횟수를 카운트
        - 메모리에서 쫒겨난 페이지들의 참조기록까지 전부 보관하고 있어야 하기때문에 상대적으로 오버헤드가 큼
- 클럭 (clock) 알고리즘
    - LRU, LFU 는 페이지의 참조시각, 참조횟수를 보관, 기록하고 비교해야 함으로 운영체제에 시공간적인 오버헤드가 생김
    - 하드웨어의 지원을 통해 오버헤드를 줄이는 방법
    - NUR(not used recently), NRU(not recently used) 라고도 불림
    - 최근에 참조된 것이 아닌, 참조가 된지 오래된 페이지 중 하나를 골라 스왑아웃
    - LRU 처럼 가장 오래되었다는 것을 보장하지는 않으나 하드웨어의 지원으로 훨씬 빠른 속도가 나오게 되어 많은 시스템에서 사용함
    - 참조 비트 (reference bit)
        - 각 프레임마다 하나씩 존재
        - 프레임의 페이지가 참조될 때 하드웨어에 의해 1 로 세팅됨
    - 페이지 프레임의 참조 비트를 순차적으로 확인
    - 참조비트가 1인 페이지는 0으로 초기화
    - 참조 비트가 0인 페이지부터 스왑아웃
    - 시곗바늘처럼 프레임들을 순차적으로 돌면서 스왑아웃시킬 페이지를 탐색
    - 모든 프레임을 한번씩 확인할 시간동안 페이지를 메모리에 유지시켜 둠으로서 페이지 부재율을 줄이도록 설계됨
        - 2차 기회 알고리즘 (second chance algorithm) 이라고도 부름

## 3. 페이지 프레임의 할당

- 여러개의 프로세스가 실행되고 있는 상황에서 어느 프로세스에 얼마만큼의 메모리를 할당 해 주어야 하는지를 결정해야 함
- 균등 할당 (equal allocation) 알고리즘
    - 모든 프로세스에 균등한 프레임을 할당
- 비례 할당 (proportional allocation) 알고리즘
    - 프로세스의 크기에 비례해 프레임을 할당
- 우선순위 할당 (priority allocation) 알고리즘
    - CPU 에서 당장 실행될 프로세스와 그렇지 않은 프로세스를 구분하여 전자쪽에 더 많은 프레임을 할당
- 실제로는 위의 알고리즘 뿐만 아니라 다른 정보들을 추가로 사용하여 할당하게 됨

## 4. 전역교체와 지역교체

- 전역교체 (global replacement)
    - 모든 페이지 프레임이 교체대상이 됨
    - 전체 메모리를 각 프로세스가 공유하며 교체 알고리즘에 따라 할당되는 메모리의 양이 가변적으로 바뀜
    - 전역으로 페이지 프레임을 관리하기 때문에 스왑 아웃되는 페이지가 수행중인 프로세스의 페이지와 다를 수 있음
- 지역교체 (local replacement)
    - 현재 수행중인 프로세스에게 할당 된 프레임만 교체가 됨
    - 프로세스마다 페이지 프레임을 미리 할당하는것이 전제
    - 프로세스별로 페이지를 관리하기 때문에 프로세스에게 할당된 프레임 내에서만 스왑할 수 있음

## 5. 스레싱 (thrashing)

- 프로세스가 적은 양의 프레임을 할당 받아 페이지 부재율 (page fault rate) 이 증가해 CPU 이용률 (CPU utilization) 이 떨어지는 현상
- 준비 큐에 프로세스가 존재하는 경우는 CPU 를 사용중이라는 뜻 이기 때문에 CPU 사용률이 높다
- 모든 프로세스가 I/O 작업을 함에 따라 CPU 를 사용하지 않게되는 경우 준비 큐가 비게되고 CPU 사용량이 줄게 된다
- CPU 사용량이 낮으면 운영체제는 메모리에 올라가는 프로세스의 양을 늘린다
- 다중 프로그래밍의 정도 (Multi-Programming Degree: MPD)
    - 메모리에 동시에 올라가 있는 프로세스의 수
- MPD 가 늘어나면 프로세스당 할당하는 프레임의 수가 줄어든다
- 할당받은 프레임의 수가 줄어들면 페이지 부재가 늘어난다
- 페이지 부제가 늘어남에 따라 스왑 인, 아웃이 늘어나고 이는 더 많은 I/O 입출력을 동반한다
- 위와같은 상황이 반복적으로 일어나며 CPU 이용률이 떨어지는 현상을 스레싱이라고 한다
- 해결방안
    - 워킹셋 (working-set) 알고리즘
        - 지역성 집합 (locality set)
            - 프로세스를 일정시간 동안 특정 주소영역을 집중적으로 참조하는 경향이 있음
            - 이때 집중적으로 참조되는 페이지들의 집합
        - 지역성 집합이 메모리에 동시에 올라갈 수 있도록 보장하는 메모리 관리 알고리즘
        - 워킹셋 (working-set)
            - 프로세스가 일정 시간동안 원활히 수행되기 위해 한꺼번에 메모리에 올라와 있어야 하는 페이지들의 집합
        - 프로세스의 워킹셋이 한번에 메모리에 올라갈 수 있는 경우에만 프레임을 할당함
        - 그렇지 않은 경우 프로세스에 할당된 프레임을 전부 반납시킨 뒤 프로세스의 주소공간 전체를 스왑 아웃 함
    - 페이지 부재 빈도 (page-fault frequency: PFF) 알고리즘
        - 프로세스의 페이지 부재율을 주기적으로 조사한 값을 이용하여 프로세스에 할당할 메모리 양을 동적으로 조절하는 방식
        - 특정 프로세스의 페이지 부재율이 정해둔 상한선을 넘어가면 프로세스에 할당된 프레임이 부족하다고 판단하여 추가 할당을 하게 됨
        - 이때 남은 프레임이 없으면 일부 프로세스를 스왑 아웃 시킴
        - 반대로 프로세스의 페이지 부재율이 정해둔 하한선 아래로 내려가면 프로세스에 할당된 프레임이 과하다고 판단하여 할당된 프레임의 수를 줄임