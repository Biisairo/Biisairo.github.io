# 5장

# HTTP/2 의 신택스 : 프로토콜 재정의

## 1. HTTP/2

- 스트림을 사용해 바이너리 데이터를 다중으로 송수신
- 스트림 내 우선순위 설정과 서버 사이드에서 데이터 통신을 하는 서버사이드 푸시 구현
- 헤더 압축

기존의 HTTP 가 제공하는 네개의 기본요소들은 바뀌지 않음

이전 버전에서 바뀌면서 달라진 점은 통신의 고속화

프로토콜의 개선사항 - 캐시 (age-max) - 통신 자체를 취소 - 캐시 (ETag, Date) - 변경이 없으면 바디 전송을 취소 - Keep-Alive - 액세스마다 연결에 걸리는 시간을 줄임 - 압축 - 응답 바디크기 절감 - 청크 - 응답 전송 시작이 빨라짐 - 파이프라이닝 - 통신 다중화

### 스트림을 이용한 통신 고속화

HTTP/2 의 최대 변경점을 기존 텍스트 기반 프로토콜에서 바이너리 기반 프로토콜로 변화했다는 점 각각의 데이터는 프레임 단위로 송수신이 됨

스트림 - 가상의 TCP 소켓 - 프레임에 따라 간단히 만들고 닫을 수 있음 - 일반 TCP 소켓과 같은 핸드셰이크가 필요없음

### HTTP/2.0 의 애플리케이션 계층

데이터를 바이너리화 TCP 소켓 레이어는 데이터를 프레임 단위로 분리할 수 있어 수신측의 버퍼를 비우기 쉽고 통신 상대에게 다음 데이터를 고속으로 보내줄 수 있음

### 플로 컨트롤

스트림을 효율적으로 흐르게 하기위해 이용되는 통신량 제어 처리 통신 속도가 지나치게 차이나는 기기의 조합으로 인한 사태를 방지

### 서버 푸시

우선운위가 높은 컨텐츠를 클라이언트가 요구하기 전에 전송할 수 있게 됨 웹소켓처럼 양방향 통신을 실현하는 것이 아닌 css, js, 이미지 등 웹 페이지를 구성하는 파일을 다운로드 하는데 이용

푸시된 컨텐츠는 사전에 캐시로 들어가며 클라이언트가 해당 컨텐츠를 요청하면 캐시에서 사용

### HPACK 을 이용한 헤더 압축

HTTP 에서 헤더에 자주 사용하는 이름이나 결과를 미리 사전에 등록 해 두고 사용하는 식으로 압축을 함

### SPDY, QUIC

SPDY - 구글이 개발한 HTTP 대체 프로토콜로 HTTP/2 전신이며 그대로 HTTP/2 로 구현됨 - HTTP 의 전송속도를 높이기 위해 개발

QUIC - 위의 SPDY 를 더 빠르게 만들기 위함 프로토콜 - TCP 와 UDP 를 통합해 더 적은 횟수로 통신을 가능하게 함

## 2. Fetch API

XMLHttpRequest 와 같이 서버 액세스를 하는 함수 js 에서 사용

- XMLHttpRequest 보다 서버 밖으로의 액세스 등 CORS 제어가 쉬워짐
- js 의 비동기 처리방식인 Promise 를 따름
- 캐시 제어 가능
- 리다이렉트 제어 가능
- 리퍼러 정책 설정 가능
- Service Work 내에서 이용 가능

### 사용법

1. XMLHttpRequest 처럼 객체를 만드는 것이 아닌 fetch 함수를 호출한다
2. 두번째 인자로 옵션 객체를 넣어준다
3. .then() 함수에 서버 응답이 돌아온 후에 호출되는 콜백을 넘겨준다
4. 위의 .then() 을 실행한 후 promise 를 반환하면 다시 .then() 을 호출한다

CORS 안전 메서드 - GET - HEAD - POST 금지 메서드 - CONNECT - TRACE - TRACK

### fetch 만이 할 수 있는 것

캐시 제어

[[Programming/http/fetch cache.png|500]]

리다이렉트 제어

[[Programming/http/fetch redirect.png|500]]

Service Work 대응 - 현재 service work 에서 외부로 접속

## 3. server-sent events

HTML5 의 기능 기술적으로 HTTP/1.1 의 청크 형식을 이용한 통신 기능을 바탕으로 만등러짐

청크의 **조금씩 전송** 한다는 특징을 응용해 서버에서 임의의 시점에 클라이언트에 이벤트를 통지

HTTP 는 기본적으로 **클라이언트의 요청->서버의 응답** 으로 이루어진 모델 통신의 시작은 클라이언트가 결정하며 클라이언트의 1회 요청에 서버는 1회 응답하는 것이 기본

서버에서 정보를 돌려주는 방식은 **코멧** 방식이 있다 클라이언트에서 정기적으로 서버에서 이벤트를 검출(폴링)하거나 요청을 받은 상태에서 응답을 보류하는(롱 폴링) 방법이 사용됨

server-sent events 는 롱 폴링 방식과 청크 방식응 조합해 한번의 요청에 대해 서버에서 여러번의 이벤트를 전송함

검증된 청크 방식을 사용하여 프록시 지원도 포함하고있어 하위호환에도 문제가 없음

청크방식을 이용하긴 하나 HTTP 위에 별도의 텍스트 프로토콜을 실어 사용 이것은 이벤트 스트림으로 불리며 MIME type 은 text/event-stream

네 종류의 태그를 사용 - id - 이벤트를 식별하는 ID - 재전송 처리에 사용 - event - 이벤트 이름 - data - 이벤트와 함께 보낼 데이터 - retry - 재접속 대기시간 (ms)

js 에서는 server-sent events 에 EventSource 클래스를 사용하여 액세스함

## 4. 웹 소켓

서버/클라이언트간에 오버헤드가 적은 양방향 통신을 지원 통신이 확립되면 서버/클라이언트 사이에서 일대일 통신을 수행

프레임 단위로 송수신 하며 상대방이 정해져 있으므로 전송할 곳의 관한 정보는 가지지 않음 - HTTP 에서 body 만 보내는 것과 같음

### 웹 소켓은 스테이트 풀

스테이트풀 통신 - 서버가 클라이언트의 상태를 보존함을 의미 - 둘간의 통신에서 이전의 요청이 다음의 요청에 영향을 미치게 된다 - 서버가 이전 통신에 관해 기억하고 있기 때문에 이전 통신의 정보를 다시금 보낼 필요가 없어 적은 오버헤드로 통신이 가능하다

### js 의 클라이언트 API

웹소켓은 HTTP 의 하위 레이어인 TCP 소켓에 가까운 기능을 제공하는 API 통신은 서버가 수신을 기다리는 상태에서 **반드시**클라이언트쪽에서 접속함

1. 서버가 특정 IP 주소, 포트번호로 시작한다 (Listen)
2. 클라이언트가 서버에 통신을 시작한다고 선언한다 (Connect)
3. 클라이언트가 보낸 접속 요청을 서버가 받아들인다 (Accept)
4. 서버에는 소켓 클래스의 인스턴스가 넘어온다
5. 서버가 받아서 처이라면 클라이언트의 소켓 인스턴스는 송, 수신을 할 수 있게된다

### 접속

프로토콜 업그레이드를 사용

클라이언트에서 서버로 연결 요청을 보냄 이때 upgrade 헤더를 이용해 websocket 으로 업그레이드를 요청

### Socket.IO

socket.io 라는 라이브러리를 사용해 쉽게 사용 가능

- 웹소켓을 사용할 수 없는 상황에서는 XMLHttpRequest 에 의한 롱 폴링을 사용해 웹소켓을 에뮬레이션
- 웹소켓 단절 시 자동으로 재접속
- 서버에서 클라이언트가 기대하는 절차로 XMLHttpRequest 통신을 핸들링할 수 있다

당시에는 웹소켓이 활발하게 사용되지 않아 하위호환성을 위해 많이 사용했지만 이제는 굳이…?

## 5. WebRTC : Web real time communication

지금까지의 프로토콜은 클라이언트/서버의 통신만을 위한 프로토콜 이었다면 WebRTC 는 클라이언트 끼리의 P2P 통신에도 이용됨 실시간 커뮤니케이션의 줄임말로 화상전화와 같은 실시간 통신을 위해 개발됨 사용법은 **https://webrtc.org/?hl=ko** 확인

사용의 목적이 다르기 때문에 사용되는 기능도 다르다 TCP 가 아닌 실시간에 더 최적화 된 UDP 사용

### 활용사례

client to client - 화상통화 시스템 - 제전송처리, 통신량의 제한을 직접 구현하는 UDP 를 사용 - 단 보안을 위해 UDP 용 TLS 인 DTSL 로 암호화 - 스크린 공유 - 파일교환 - 중앙 서버를 이용하지 않는 화상 회의 - 온라인게임

client to server - 고객센터 - IP 전화 - 중앙 서버를 이용한 화상회의

## 6. HTTP 웹 푸시

웹사이트에서 스마트폰의 앱과 같은 알람기능을 제공하는 기능 지금까지의 기능들은 모두 브라우저가 활성화 되어 있는 것을 전제로 작동함

웹 푸시는 브라우저가 그 시점에 실행되어 있지 않거나 오프라인 이어도 사용자에게 알림을 보낼 수 있음 service worker 를 사용

현재의 푸시 서비스와 연계하여 구현 됨

1. 브라우저에서 푸시 서비스 이용을 등록함
    - 푸시 알림은 사용자의 허가가 필요한 opt-in 방식
2. 사용자가 허가하면 푸시 서비스에 등록
3. 활성화 되면 service worker 로 등록한 push 이벤트 알람이 오게 됨
- 사용자가 push 알림을 승인하게 되면 푸시 서비스에 가입하게 되며 키를 생성함
    - 키의 정보는 푸시 서비스가 브라우저를 식별하는데에 사용
- 브라우저가 키를 서버에 보내면 서버는 알림을 특정 브라우저로 보낼 수 있게 됨
- 서버는 브라우저에서 온 키를 이용해 푸시 서비스를 요청