# 1장

# HTTP/1.0 신택스

- 매서드와 경로
- 헤더
- 바디
- 스테이터스 코드

## 1. HTTP 역사

- IETF (the Internet Engineering Task Force) : 인터넷의 상호 접속성을 향상시키는 것을 목표로 만들어진 임의 단체
- RFC (Request For Comments)
    - IETF 가 만든 규약 문서
    - 통신의 상호접속성 유지를 위한 공통화된 사양서 모음
- IANA (Internet Assigned Numbers Authority)
    - 포트번호와 파일타입(Content-Type) 등 웹에 관한 데이터베이스를 관리하는 단체
    - 통신타입(프로토콜) 이 아닌 파일타입(데이터) 와 같은 정보를 관리
- W3C (World Wide Web Consortium)
    - 웹 관련 표준화를 하는 비영리 단체
    - 통신 규격이 아닌 브라우저에 특화된 기능을 담당
    - HTML 의 사양정첵, server-sent events, 웹소켓 등, API 를 동반하는 통신 프로토콜 담당
- WHATWG (Web Hypertext Application Technology Working Group) : 웹 관련 규격을 논의하는 단체. W3C 와 겸하는 멤버가 많다

## 2. HTTP/0.9

단순히 경로를 통해 텍스트 정보가 담긴 파일을 가져오는 프로토콜로 시작 clint 에서 요청(**request**)을 하면 server 가 웹사이트 내용을 반환(**response**)해 준다

## 3. HTTP/0.9 -> HTTP/1.0

### 0.9 에서의 한계

- 하나의 문서밖에 전송하지 못함
- HTML 문서가 아닌 형식을 콘텐츠를 전달할 수 없음
- client 에서는 검색을 제외한 요청을 할 수 없음
- 새로운 정보의 전송, 갱신, 삭제할 수 없음
- 서버의 응답상태 알 수 없음

### 1.0 에서 추가된 것

- 요청 시 메서드 추가 : GET
- 요청 시 HTTP 버전 추가 : HTTP/1.0
- 요청시 헤더의 추가 : Host, User-Agent, Accept
- 응답 시 HTTP 버전과 스테이터스 코드 추가
- 응답 시 헤더의 추가 : Host, User-Agent, Accept

## 4. HTTP 와 전자메일 - 헤더

- 파일명(key):값 의 형식으로 본문 맨 앞에 부가
- 한줄에 하나의 값
- 본문과 헤더 사이에 하나의 빈줄
- 대, 소문자를 구별하지 않음
- 서버, 클라이언트 사이에 필요한 추가정보, 지시, 명령, 당부 등이 적힘
- 예시
    - client to server
        - User-Agent : 클라이언트가 자신의 애플리케이션의 이름을 적는 곳
        - Referer : 서버에서 참고하는 추가 정보, 클라이언트가 요청을 보낼 때 보고있던 페이지의 url 을 보내게 된다
        - Authorization
            - 서버에 인증정보 전달
            - RFC 표준
                - Basic
                - Digest
                - Aearer
            - 아마존 웹 서비스나 깃허브 API 등 자체 표준
    - server to client
        - Content-Type : 파일의 종류를 지정, MIME 식별자를 사용
        - Content-Length : 바디의 크기, 압축이 이루어 지는 경우 압축 된 크기
        - Content-Encoding : 압축이 이루어 지는 경우 압축 형식
        - Date : 문서 날짜
        - 이 밖의 X- 로 시작되는 헤더 : 각 애플리케이션에서 자유롭게 사용
- 이외에는 IANA 사이트에서 찾아보기

### MIME type

파일의 종류를 구별하는 문자열 - 초기에 전자메일을 위해 만들어짐

OS 에서는 - 윈도우 : 파일의 확장자 - mac os : resource fork 라는 이름의 파일의 메타데이터 를 보고 파일 종류를 판단함

브라우저에서는 MIME 타입이라는 식별자를 사용해 파일의 종류를 구분함 - 예시 : HTML 파일을 response 받았을때의 content-type - `Content-Type: text/html; charset=utf-8`

### content-type 의 보안

인터넷 익스플로러의 경우 옵션에 따라 MIME 타입이 아닌 내용을 보고 파일 형식을 추측함 - content sniffig

실제 보내는 형식이 아닌 다른 형식으로 추측을 할 수 있기때문에 막는것이 추세 - `X-Content-Type-Options: nosniff`

## 5. HTTP 의 조상 뉴스그룹

HTTP 가 생기기 이전 프로토콜인 NNTP 를 사용 여기서 method, status code 두개의 기능이 HTTP 에 도입됨

### method

지정된 주소에 있는 리소스에 대한 조작을 지시함 - GET : 서버와 헤더에 콘텐트 요청 - HEAD : 서버에 헤더만 요청 - POST : 새로운 문서 투고 - PUT : 이미 존재하는 url 의 문서를 갱신 - DELETE : 지정된 url 의 문서를 삭제

### status code

세자리 숫자로 구성되었으며 서버의 응답을 한눈에 파악할 수 있음 - 100 번대 : 처리가 계속됨 - 200 번대 : 성공시의 응답 - 300 번대 : 서버에서 클라이언트로의 명령, 오류가 아니라 정상처리, 리디렉트나 캐시이용을 지시 - 400 번대 : 클라이언트가 보낸 요청에 오류가 있음을 알림 - 500 번대 : 서버 내부에서 오류가 발생함

## 6. 리디렉트

300 번대 스테이터스코드 일부는 서버가 브라우저에 리디렉트를 지시함 300 이외의 경우는 `Location` 헤더를 사용해 리디렉트 할 곳을 서버에서 클라이언트에 전달 - 301, 302, 303, 307, 308 다섯가지가 있다

301, 308 : 요청된 페이지가 다른 페이지로 이동했을때 사용, 영구적으로 이동 302, 307 : 일시적인 이동, 모바일 전용사이트나 관리페이지를 표시 303 : 요청된 페이지에 반환할 컨텐츠가 없거나 원래 반환해야 할 페이지가 따로 있을 때 사용, 영구적 이동

클라이언트는 300 번대 status code 가 반환 되면 Location 헤더 값을 보고 다시 서버에 요청함

## 7. URL

URI : URL 과 URN 을 포함 URL (Uniform Resource Locator) : 위치를 지정 URN (Uniform Resource Name) : 이름 규칙을 사용

사실상 URN 을 거의 사용하지 않으므로 URI 와 URL 을 동일시 할 수 있음

### 구조

`https://profile.intra.42.fr/users/131666/resumes/7746` `스키마://호스트명/경로`

- 스키마 : https
- 호스트명 : profile.intra.42.fr
- 경로 : users/131666/resumes/7746

이외에 URL 사양에 포함되는 모든 요소가 들어간 예제 `스키마://사용자:패스워드@호스트명:포트/경로#프래그먼트?쿼리`

스키마 - 종류 : http, https, mailto, file, ftp, 등 - 브라우저가 스키마를 보고 적절한 접속 방법을 선택

호스트명 - 실제 통신을 하는 곳 - 하나의 호스트에 65535 개의 포트가 있으며 각각의 포트를 이용해 복수의 서버를 구동할 수 있음 - HTTP 는 80, HTTPS 는 443 을 사용함

사용자:패스워드 - ftp 등에서 사용되곤 함 - 위의 방식은 Basic 인증 방식으로 통신 내용이 보이거나 접속 로그가 남으면 패스워드가 누출될수 있기에 잘 사용하지 않음

프래그먼트 - HTML 페이지 내 링크에 앵커를 지정하는데 쓰임

쿼리 - 검색 용어를 지정하거나 표시할 웹에 특정 파라미터를 부여하는데 사용

URL 을 주소를 지정하지만 **사용자가 읽는 문장**

URL 의 길이에는 제한이 없으나 인터넷 익스플로러가 한번에 2083자 까지만 다룰 수 있어 **대체로 2000자** 의 규격이 생기게 됨

### 국제화

원래는 영, 숫자와 하이픈(-) 만 사용할 수 있었지만 퓨니코드가 구현된 브라우저는 인코딩을 해 다른 언어들도 사용할 수있게됨 퓨니코드는 xn- 으로 시작된 문자열을 생성

## 8. BODY

헤더의 끝에 빈 줄을 넣으면 그 뒤의 내용을 전부 바디가 됨

HTTP 응답에서의 body는 한번 응답에 하나의 파일을 반환함 form 이나 XMLHttpRequest 를 사용해 클라이언트에서 서버로 데이터를 전송 할때도 요청에 body 가 포함되는 것 외에는 같음 이때 읽어올 바이트의 수는 Content-Length 헤더로 지정

### GET 요청에서의 body

GET 이나 HEAD 요청에서는 body 를 포함하는 것이 **기대되지 않음**

하지만 **어떤 요청의 메세지라도 바디의 포함이 허용되어있으며 이를 염두에 두고 해석해야함**