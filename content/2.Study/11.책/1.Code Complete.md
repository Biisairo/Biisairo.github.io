# Code Complete

세미나 진도

31장 9시

- 강조 색
    
    이상함
    
    공감
    
    이해안감
    

# 5장 구현 설계

설계

- 컴퓨터 소프트웨어에 대한 명세를 동작 가능한 소프트웨어로 변환하기 위한 스키마에 대한 개념, 고안, 계획을 의미
- 코드를 작성하고 디버깅하기 위한 요구 사항들을 결합하는 작업

## 1. 설계의 문제점

문제

- 해결해야만 정의할 수 있는 문제
- 문제를 정확하게 정의하기 위해서는 문제를 한번 해결 해야함
- 작동하는 솔루션을 만들기 위해서는 문제를 두번 해결해야 한다는 의미

실수를 많이하고 실수를 고치는 것이 설계의 핵심

서로 상충되는 특징, 자원을 고려해 균형을 맞추는 일

디자인 재검토, 토론, 코드를 작성하고 수정하는 경험을 통해 진화하고 발전한다

## 2. 설계의 핵심 개념

복잡성 관리

- 본질과 비본질
    - 본질 : 사물이 그러한 사물이 되기 위한 필수 속성
    - 비본질 : 사물이 가질수도 있는 속성
    - 소프트웨어의 비본질(언어, 언어의 문법, 언어 사용의 어려움) 은 해결됨
    - 소프트웨어의 본질
        - 현실의 제약, 연관된 개념들의 복잡성
    - 복잡성 관리의 중요성
    - 컴퓨터 프로그램 전부를 머리에 담을 수 없으며 한번에 한 부분을 집중할 수 있도록 프로그램을 구성 하여야 함
    - 시스템 전체를 서브시스템으로 나누어 복잡성을 감소시킴
- 복잡성을 해결하기 위한 방법
    - 한 번에 처리해야 하는 본질적인 복잡성의 양을 최소화
    - 비본질적인 복잡성이 불필요하게 증가하지 않도록
- 바람직한 설계 - 품질 특성
    - 복잡성 최소화
        - 간단하고 이해하기 쉬운 설계
    - 유지 관리의 편리함
    - 느슨한 결합
        - 다른 부분들 과의 연결을 최소화
    - 확장성
    - 재사용성
    - 높은 팬인(fan-in)
        - 주어진 클래스를 사용하는 클래스의 수가 많은 것을 의미
    - 낮은 팬아웃(fan-out)
        - 주어진 클래스가 다른 클래스를 적게 사용하는 것을 의미
    - 이식성
    - 간결성
        - 더이상 추가적인 부분이 없도록 설계하는 것
    - 계층화
    - 표준기술 사용
- 설계 수준
    - 소프트웨어 시스템
        - 서브시스템/패키지로 분할
            - 패키지 내에서 클래스로 분할
                - 클래스 내에서 데이터와 루틴으로 분할
                    - 내부 루틴 설계
    - 1 수준 : 소프트웨어 시스템
        - 전체 시스템
    - 2 수준 : 서브시스템/패키지로 분할
        - 프로그램을 주요 서브시스템으로 어떻게 분할할지, 각각의 서브시스템들이 서로를 어떻게 이용할 지를 결정
        - 각각의 서브시스템이 서로 어떻게 커뮤니케이션 하는지에 대한 규칙을 결정
        - 가장 간단한 관계는 서브시스템이 서로의 루틴을 호출하는 것
        - 가장 복잡한 관계는 서브시스템의 클래스가 다른 서브시스템의 클래스를 상속받는 것
        - 순환관계를 끊는 것이 범용적인 규칙
        - 공통적인 서브시스템
            - 비즈니스 규칙
            - 사용자 인터페이스
            - 데이터베이스 접근
            - 시스템 의존성
    - 3 수준 : 클래스로 분할
        - 모든 서브시스템이 개별적인 클래스로 최소 단위로 분해되었음을 보장해야 함
        - 각 클래스가 시스템의 나머지 부분과 상호작용하는 세부 방법도 정의
            - 인터페이스의 정의
        - 객체와 클래스의 차이점
            - 클래스 - 프로그램 코드에서 보게 되는 정적인 것
            - 객체 : 프로그램을 실행할 때 생성되는 특정 값을 갖는 무언가
                - db 에서의 스키마/인스턴스와 같은 차이
    - 4 수준 : 루틴으로 분할
        - 각 클래스를 루틴로 분할
        - 클래스의 private 루틴을 상세하게 설계
        - 인터페이스의 이해와 이에 따른 인터페이스의 변경
    - 5 수준 : 내부 루틴 설계
        - 개별 루틴의 상세 기능 구현

## 3. 빌딩 블록의 설계 : 발견적 학습

객체를 설계하는 단계

- 객체와 특성(메서드와 데이터)을 규명
    - 객체는 실세계의 엔티티에 기반을 두게 됨
    - 직원, 고객 등등…
- 각 객체가 할 수 있는 일을 결정
- 각 객체가 다른 객체에게 허용하는 것을 결정
    - 포함, 상속관계
- 각 객체가 다른 객체에게 보일 것을 결정, 즉 public, private 인 부분은 결정
- 각 객체의 public 인터페이스를 정의

추상화

- 잘 만들어진 클래스의 인터페이스 - 해당 클래스의 내부적인 작업에는 신경 쓸 필요가 없게 만들어진 인터페이스
- 추상화가 잘 되어있는 경우 관련없는 세부사항을 무시할 수 있게 되며 복잡성을 줄일 수 있다
    - 집 - 창문, 문, 벽 등을 구성하는 방법에 대한 추상화
    - 문 - 나무, 손잡이, 경첩 등을 구성하는 방법에 대한 추상화
- 객체를 높은 수준에서 볼 수 있도록 하는 것

캡슐화

- 다른 수준에서 객체를 볼 수 없도록 하는 것
- 복잡한 부분을 볼 수 없도록 함으로써 복잡성을 관리
    - 집을 볼 수 있지고 문이 열려있는지 닫혀있는지에 대한 상태는 볼 수 있지만 문의 재질은 알 수 없도록 함

상속

- 객체들 간의 유사성과 차이점을 정의하는 것
- 상위 개념에서의 일반적인 특성을 정의하고 이를 상속받는 하위 개념을 추가로 정의
    - 나무 → 문 → 여닫이문

정보 은닉

- 캡슐화, 모듈화, 추상화의 시작
- 정보, 복잡성을 감추는데 중점을 둠
- 비밀
    - 변수, 파일의 포맷, 구현, 외부에 차단 될 필요가 있는 영역
- 비밀 보장권
    - 클래스는 비밀들을 숨기고 비밀 보장권을 보호해야 함
    - 가시성 : 클래스를 설계할 때 어떤 기능들이 노출되어야 하고 어떤 기능들이 비밀로 남겨져야 하는지를 정의하여야 함
- 예시
    - 메서드, 변수 등 정보에 직접 접근을 방지
    - 변수의 타입을 typedef 를 활용하여 특정하는 것을 방지
        - typedef int IdType
- 비밀의 종류
    - 복잡성을 감추기 위해 특별히 다룰 필요가 없는 데이터를 숨기는 것
    - 변경이 발생했을 때 변경의 원인을 감추는 것
- 정보 은닉의 장애물
    - 정보의 지나친 배분
        - 상수에 정보를 숨겨서 한 곳에서만 값을 관리하여 해결
        - 전역 데이터에 대한 접근을 관리하여 해결
    - 순환 참조
    - 클래스 데이터를 전역 데이터로 사용하는 것
    - 성능 손해
- 정보 은닉의 가치
    - 이 클래스에서 무엇을 숨겨야 하는가?
    - 내가 무엇을 숨겨야 하지?

변경될 수 있는 영역 규명

- 변경에 대비하는 단계
    - 변경될 것처럼 보이는 항목을 규명
        - 요구 사항 개발이 잘 수행 되었다면 잠재적인 변경의 가능성을 포함하고있을 것
    - 변경될 것 같은 항목을 분류
        - 위에서 규명한 변하기 쉬운 요소들을 고유한 클래스로 분류
    - 변경될 것처럼 보이는 항목을 고립
        - 변화될 부분과 고정된 부분들 분리시키고 해당 변경이 클래스 내부에 제한되어 외부에 영향을 주지 않도록 설계
        - 해당 클래스를 사용하는 외부의 클래스는 변경을 알아서는 안됨
- 변경될 수 있는 영역
    - 비즈니스 규칙
    - 하드웨어 의존성
        - 다른 하드웨어 환경을 대비
    - 입출력
        - 파일 포맷 등의 변경을 대비
    - 비표준 언어 기능
        - 해당 확장기능을 사용하지 않는 환경을 대비
    - 어려운 설계, 구현 부분
        - 오류, 수정을 대비
    - 상태 변수
        - bool 변수 사용 금지 - 열거형을 사용
            - 상태가 추가되는 것을 대비
    - 데이터 크기 제약
- 변경의 정도 예상하기
    - 변경이 예상되지 않는 부분만 클래스에서 큰 영향을 가지도록

느슨한 결합

- 결합
    - 클래스, 루틴이 다른 클래스와 루틴과 얼마나 밀접하게 연관되어 있는지
- 모듈
    - 클래스, 루틴을 가리키는 말
- 모듈간의 결합
    - 하나의 모듈이 다른 모듈을 사용하는 것
    - 모듈간의 결합이 서로 쉽게 사용할 수 있도록 느슨하게 결합되어야 함
- 모듈이 다른 모듈에 최대한 의존하지 않도록 해야함
- 결합의 기준
    - 크기
        - 모듈간의 연결 수
    - 가시성
        - 모듈 간 연결의 현저함
        - 얼마나 연결이 눈에 띄는지
    - 유연성
        - 모듈간의 연결을 얼마나 쉽게 변경할 수 있는가
        - 다른 모듈이 어떤 모듈을 쉽게 호출할 수 있도록
- 결합의 종류
    - 간단한-데이터-매개변수 결함
    - 간단한-객체 결합
    - 객체-매개변수 결합
        - 객체와 객체간에서 다른 객체를 전달하는 경우
        - 받는 객체가 주어진 객체에 대해 알고 있어야 함
    - 의미론적인 결합
        - 한 모듈이 다른 모듈의 내부 작동에 대한 지식을 사용하고 있는 경우
- 느슨한 결합은 모듈이 추가적인 추상화 수준을 제공할 수 있도록 함

설계 패턴의 사용

- 설계 패턴 - 흔히 발생하는 문제들을 해결하기 위해 이미 만들어진 해결책의 핵심 부분
- 이미 만들어진 추상화를 제공함으로 복잡성을 줄임
    - 코드에 대한 과한 설명 없이 사용하는 설계 패턴을 토대로 설명이 가능해짐
- 널리 사용되는 해결책을 규정함으로 오류를 줄임
    - 이미 만들어진 솔루션을 사용
- 설계에 알맞은 설계 패턴을 찾는 과정에서 오는 발견적 학습
- 원활한 의사소통

다른 발견적 학습

- 강한 응집력을 목표로
    - 루틴, 코드가 얼마나 중심적인 목적을 지원하고 있는지, 해당 클래스가 얼마나 집중되어 있는지
- 계층을 만들어라
    - 최상위의 추상적인 항목에서 점차 상세하고 구체적인 낮은 계층으로 이루어진 구조
    - 복잡성 관리를 달성하는 도구
- 클래스 계약의 형식화
- 책임의 할당
    - 객체에 책임을 할당
- 테스트를 위한 설계
- 실패를 피하라
    - 과거의 성공만 확인하지 말고 실패를 고려한다
- 바인딩 시간을 의식해라
    - 바인딩 시간 - 특정 값이 변수에 연결되는 시간
- 제어의 중심점을 만들어라
    - 클래스, 루틴, 전처리기 매크로, #include 파일, 명명된 상수 등
- 주먹구구식 기법의 사용
    - 작동하는 주먹구구식 해결법이 작동하지 않는 우아한 해결법 보다 낫다
- 다이어그램
    - 그림을 사용하여 높은 수준의 추상화를 할 수 있다
- 설계의 모듈화
    - 각 루틴, 클래스를 블랙박스처럼 만들어 내부를 랑 수 없도록
- 발견적 학습에 대한 요약
    - 실세계의 객체를 찾아라
    - 일관성있는 추상화를 구성하라
    - 세부사항을 캡슐화하라
    - 상속이 설계를 단순화 하는 경우 상속하라
    - 비밀을 숨겨라
    - 변경을 규명하라
    - 느슨한 결합을 유지하라
    - 널리 사용되는 설계 패턴을 찾아라
    - 강한 응집력을 목표하라
    - 계층을 만들어라
    - 클래스 계약을 형식화하라
    - 책임을 할당하라
    - 태스트를 위해 설계하라
    - 실패를 피하라
    - 바인딩 시간을 의식적으로 선택하라
    - 제어의 중심점을 만들어라
    - 주먹구구식 기법의 사용을 고려하라
    - 다이어그램을 그려라
    - 설계의 모듈화를 유지하라

발견적 접근 방법을 위한 지침

- 문제를 해결하는 방법
    - 문제의 이해
    - 계획의 고안
    - 계획의 실행
    - 검토

## 4. 설계 방법

반복

- 설계를 반복하고 다른 접근 방법을 시도해본다
- 고수준 문제를 작업함으로써 전체적인 저수준의 세부사항을 고려하는데 도움을 준다
- 저수준 문제를 작업함으로써 얻는 세부사항은 고수준에서의 현실적인 기초를 제공한다

분할 정복

- 프로그램을 서로 다른 관심의 영역으로 나누고 각 부분을 개별적으로 처리한다

하향식, 상향식 설계 접근 방법

- 하향식 설계
    - 분해 전략
    - 보다 쉽다
    - 구현의 세부사항을 뒤로 미뤄둔다
    - 높은 추상화 수준에서 설계를 시작
    - 기본 클래스, 구체적이지 않은 요소를 정의하면서 시작
    - 한번에 특정한 만큼만 집중할 수 있도록 도와줌
    - 계속해서 여러 수준에서 분해하고 작업하기를 반복
    - 분해하는 것 보다 코드를 작성하는 것이 쉬울 때 까지 분해를 반복한다
- 상향식 설계
    - 결합 전략
    - 전형적인 유틸리티를 초기에 규명해 간결하고 잘 구성된 설계가 될 수 있음
    - 구체적인 것 부터 시작해 일반적인 쪽으로 작업
    - 하향식 접근 방식이 너무 추상적인 경우, 보다 명백한 무언가로 작업해야 하는 경우
    - 이 시스템이 무엇을 해야 하는지에 대해서 내가 무엇을 알고 있는지
    - 객체의 구체적인 책임을 규명
    - 공통적인 객체를 규명하고 서브시스템 구조, 패키지, 객체 내에서의 합성, 상속을 사용해 객체들을 그룹화
    - 다음 상위수준에서 같은 작업을 반복

프로토타이핑

- 세부 구현을 제대로 이해하기 전에는 설계가 잘 작동하는 지 알 수 없는 경우가 있을 수 있음
- 특정 설계 질문에 답하기 위한 최소한의 임시 코드
- 사용하고 버리는 코드로서 취급해야함
    - 프로토타이핑을 위해 작성한 코드를 시스템에 포함시키려고 하면 프로토타이핑이 아닌 시스템을 구현해버림

협력적인 설계

- 동료와의 대화, 토론, 페어 프로그래밍
- 외부의 도움

설계를 얼마나 해야할까?

- 프로그램을 만듬에 있어서 고려할 수 있는 내용(팀원의 수준, 안정성의 정도, 프로젝트의 크기 등)을 기준으로 중요도를 파악

설계 작업 기록하기

- 설계 문서를 코드에 넣어라
- 설계의 논의와 결정을 위키에 기록하라
- 이메일로 요약을 작성하라
- CRC 카드를 사용하라
    - 클래스, 책임, 협력의 앞자를 딴 카드
    - 클래스의 이름, 클래스가 가지는 책임, 클래스와 협력하는 다른 클래스를 기록
- UML 다이어그램을 작성하라
    - Unified Modeling Language
    - 엔티티와 관계들에 대한 표현을 제공

## 정리

- 복잡성 관리, 단순화
- 한번에 처리해야 하는 본질적인 복잡성의 양을 최소화, 부수적인 복잡성의 증가를 방지
- 발견적 학습
- 반복적인 설계
- 정보 은닉, “무엇을 숨겨야하지?” 질문하기

복잡성 관리 → 설계의 가장 주된 이유

발견적 학습

지도자가 지도해 주는 것이 아닌 목표와 최소한의 지도를 통해 학습자가 스스로 탐구하여 최종 형태를 이루어 내는 것

여러번의 시행착오, 여러번의 반복된 설계가 좋은 프로그램을 만든다

# 6장 클래스 다루기

## 1. 클래스 기초 : 추상 데이터 형 (ADT)

ADT

- 데이터와 데이터를 다루는 연산의 집합

ADT 사용 지침

- 전형적인 저수준의 데이터를 데이터 형이 아닌 ADT 로 만들어라
- 파일과 같은 일반 객체들을 ADT 로 취급하라
- 간단한 항목이라도 ADT 로 취급하라
    - 간단한 연산이어도 코드가 스스로 설명할 수 있도록 하게 만들고 변경이 쉽도록 한다
- ADT 가 저장되어있는 매체에 독립적으로 ADT 를 참조하라

ADT 와 클래스

- ADT 는 클래스의 기본
- 클래스를 지원하는 언어에서는 ADT 를 클래스로 구현할 수 있다

## 2. 좋은 클래스 인터페이스

좋은 추상화

- 클래스 추상화에 대한 평가는 public 루틴의 집합, 클래스의 인터페이스를 기초로 함
- 좋은 추상 인터페이스는 작성하는 것이 좋은 클래스 인터페이스를 작성하는데 도움을 줌
    - 클래스 인터페이스에서 일관된 추상화 수준을 표현한다
        - 각각의 클래스는 하나의 ADT 를 구현해야한다
    - 클래스가 구현하고 있는 추상화가 무엇인지 확실하게 이해하여야 한다
    - 서로 반대되는 기능을 갖는 서비스 쌍을 제공하라
        - 삽입 ↔ 삭제
        - on ↔ off
    - 관련 없는 정보를 다른 클래스로 이동시켜라
    - 가능하다면 인터페이스를 의미론적이기 보다는 프로그래밍 적으로 만들어라
        - 의미론적인 인터페이스는 주석 등으로 표기하여야 한다
        - 프로그래밍 적으로 데이터 타입, 컴파일러에서 특정되게 하여야 한다
    - 수정 시 인터페이스의 추상화가 손상되는 것을 조심하라
    - 인터페이스 추상화와 어긋나는 public 멤버를 추가하지 말라
        - 루틴이 추가될 때마다 기존의 인터페이스에서 제공하는 추상화와 일관성이 있는지 질문한다
    - 추상화와 응집도를 함께 고려하라

좋은 캡슐화

- 클래스와 멤버에 대한 접근성을 최소화하라
    - 인터페이스 추상화의 무결성을 잘 유지하는 접근제어자를 사용
- 멤버 데이터를 public 으로 노출하지 말라
    - get/set 을 사용하는 방식으로 데이터를 캡슐화
- 내부의 세부적인 구현 사항들을 클래스의 인터페이스에 입력하지 않는다
    - 구현부와 인터페이스를 분리시킨다
    - 클래스의 선언부에는 구현에 관한 클래스의 포인터를 포함시켜 세부 구현사항을 숨긴다
- 클래스의 사용자들을 추측하지 말라
    - 사용자들의 동작을 추측하여 예상하면 안된다
- friend 클래스를 피하라
    - friend 클래스는 캡슐화를 위반한다
- public 루틴만을 사용한다고 public 인터페이스에 놓지 말라
- 코드를 작성할 때의 편의성보다 읽을 때의 편의성을 추구하라
- 캡슐화의 의미론적 위반을 주의하라
    - 작동 방식을 이해하기 위해 내부 구현을 봐야 한다면 추상적인 것이 아니다
- 지나치게 밀접한 결합을 주의한다
    - 클래스와 멤버의 접근성을 최소화하라
    - friend 클래스는 밀접하게 결합되기 떄문에 피하라
    - 파생 클래스가 기본 클래스와 느슨하게 연결되도록 데이터를 protected 보다 private 로 선언하라
    - 클래스의 public 인터페이스에서 멤버 데이터를 노출하지 말라
    - 캡슐화의 의미론적 위반을 경계하라
    - 데미테르의 법칙을 준수하라

## 3. 설계와 구현 문제

포함 관계 (has a 관계)

- 직원은 이름을 가지며(has a), 전화번호를 가지며…등등
- 최후의 수단으로 private 상속을 통해 has a 를 구현
    - 포함하는 클래스가 포함되는 클래스의 protected 멤버 함수, 데이터에 접근가능해짐
    - 조상 클래스와의 지나친 밀접 관계, 캡슐화 위반
- 4개 이상의 데이터 멤버들을 포함하는 클래스를 주의하라
    - 7±2 - 사람이 다른 작업을 할 때 기억할 수 있는 개별적인 항목의 수
    - 클래스의 멤버변수가 너무 많아지만 작은 클래스로 분리할 수 있는지 고려

상속 관계 (is a 관계)

- 한 클래스가 다른 클래스를 특수화 한다는 개념
- 공통적으로 사용되는 요소를 지정하는 기본 클래스와 이를 상속 받는 파생 클래스
- 반복되는 요소를 집중 시켜 반복을 피하기 위함
- 상속을 할 때 결정할 사항
    - 각 멤버 루틴에 대하여, 루틴이 파생 클래스에서 보일 것인가? 기본 구현을 포함할 것인가? 기본 구현이 override 가 가능할 것인가?
    - 각 데이터 멤버에 대하여, 데이터 멤버가 파생 클래스에서 보일 것인가?
- 상속의 구현
    - public 상속을 통해서 is a 를 구현
        - 새로운 클래스가 오래된 클래스의 특수화된 버전이다(is a)
        - 기본 클래스는 파생 클래스가 어떻게 작동할 지 예측하고 작동에 제약을 가할 수 있다
        - 파생 클래스가 기본 클래스의 계약을 완벽하게 따르지 않으면 잘못된 상속
    - 상속을 위해 설계하고 설명하라, 그렇지 않다면 상속을 금지하라
        - 클래스가 상속을 위해 설계되어지지 않았다면 상속을 하면 안된다
    - LSP, Liskov 치환원리를 따르라
        - 하위 클래스 사용자가 그 차이점을 알 필요 없이 기본 클래스의 인터페이스를 통해 사용할 수 있어야 한다
    - 상속 받고싶을 때만 상속을 받아라
        - 멤버 루틴에 대해 원하는 방식으로 상속 받기
            - 오버라이드가 가능한지, 구현이 필수적인지…
    - 오버라이드가 불가능한 멤버 루틴을 오버라이드 하지 말아라
        - 파생 클래스에서 오버라이드가 불가능한 루틴의 이름을 재사용하지 말아라
        - 기본 클래스의 private 함수를 파생 클래스에서 같은 이름으로 생성할 수 있지만 이는 override 가 아니며 혼란을 불러올 수 있다
    - 공용으로 사용되는 인터페이스, 데이터, 행위를 상속 트리의 가능한 위로 이동시켜라
        - 공용으로 사용되는 것들이 높게 이동할 수록 파생 클래스에서 이들을 사용하기 쉬워진다
        - 추상화를 깨지 않는 수준에서 높은 곳에 있는 것이 좋다
    - 인스턴스가 하나뿐인 클래스를 의심하라
        - 단일 인스턴스는 설계가 객체를 클래스로 오판하고있는 경우
        - 새로운 클래스 대신 객체를 생성
        - 싱글톤은 예외사항
    - 파생 클래스가 하나뿐인 기본 클래스를 의심하라
    - 루틴을 오버라이드 하고 파생된 루틴에서 아무것도 하지 않는 클래스를 의심하라
        - cat.scratch() 를 손톱이 없는 고양이에서 빈 함수로 override 하는 것이 아닌 cat 에 claw 클래스를 포함시키는 방식으로…
    - 깊은 상속을 피하라
    - 광범위한 형 검사보다 다형성을 택하라
        - 자주 반복되는 case 는 다형성을 사용해 깔끔하게 만들 수 있다
    - 모든 데이터를 protected 가 아닌 private 로 만들어라
        - 상속은 캡슐화를 부순다
- 다중 상속
    - 다중 상속은 과한 복잡성을 부를 수 있다
    - mixin
        - 객체에 일련의 속성을 추가하기 위한 간단한 클래스
        - displayable, sortable 같은 속성을 나타내는 추상클래스
        - 독립적으로 인스턴스화 하지 않음
    - mixins
        - 혼합물
        - mixin 들을 다중 상속받아 만들어진 결과물
    - mixin 들이 완전히 독립적이면 다이아몬드 상속과 같은 문제를 만들지 않는다
- 상속의 규칙
    - 상속과 관련된 문제를 겪지 않기 위한 규칙들
        - 데이터를 공유하고 행위를 공유하지 않는 클래스들
            - 클래스들을 포함할 객체 생성
        - 행위는 공유하고 데이터는 공유하지 않는 클래스들
            - 공통적인 루틴을 공유한 기본 클래스를 상속
        - 데이터와 행위를 공유하는 클래스들
            - 공통적인 데이터와 루틴을 정의한 기본 클래스 상속
        - 인터페이스를 제어하기 위한 기본클래스가 필요 - 상속
        - 인터페이스를 제어하고싶을 때 - 포함

멤버 함수와 데이터

- 멤버함수와 데이터를 효율적으로 구현하기 위한 지침
- 클래스에 가능한 적은 수의 루틴을 유지하라
- 원하지 않는 멤버 함수, 연산자들의 암시적 생성을 차단
- 호출되는 루틴의 수를 최소화
- 다른 클래스에 대한 간접 루틴 호출을 최소화
    - 데미테르의 법칙
        - 객체 A가 객체 B 를 인스턴스화 했을 때 객체 A는 객체 B의 루틴을 호출할 수 있다
            - objectA.getObjectB();
        - 객체 A는 객체 B가 인스턴스한 객체의 루틴은 호출할 수 없다
            - objectA.getObjectB().getObjectOfB(); ← 금지
- 일반적으로 클래스와 다른 클래스가 협력하는 정도를 최소화
    - 인스턴스화 되는 객체의 수
    - 인스턴스화 된 객체에 대한 서로 다른 직접적인 루틴 호출의 수
    - 인스턴스화 된 다른 객체에 의해서 리턴되는 객체에 대한 루틴 호출의 수

생성자

- 가능하다면 모든 멤버 데이터를 모든 생성자에서 초기화한다
- private 생성자를 사용하여 싱글톤 속성을 구현하라
- 다른 사항들이 증명될 때 까지 깊은 복사를 택하라

## 4. 클래스를 작성하는 이유

- 실세계의 객체를 모델링하라
- 추상 객체들을 모델링 하라
    - 실세계의 객체는 아니지만 다른 객체의 추상화를 제공하는 객체를 모델링
- 복잡성을 줄여라
    - 클래스를 작성한 뒤에는 클래스에 관한 세부 사항을 잊고 클래스를 사용할 수 있어야함 - 추상화되어야 함
- 복잡성을 고립시켜라
    - 오류가 발생했을 때 해당 오류가 지역적으로 분포하도록
    - 오류의 수정이 코드 전체에 영향을 미치는 것이 아니라 해당 클래스에서만 작용하도록
- 세부적인 정보를 숨겨라
- 변경의 영향을 제한하라
- 전역 데이터를 숨겨라
    - 접근 루틴에 의해 전역 데이터를 다루도록 함
- 매개변수의 전달을 간소화하라
    - 특정 변수가 여러 루틴들 사이에서 전달되고 있으면 해당 루틴들을 변수를 객체 데이터로 공유하는 클래스에 포함 시킬 수 있다
- 중앙 집중 관리하라
    - 한 곳에서 작업을 처리하도록
- 코드의 재사용을 도와라
    - 재사용이 가능한 코드라면 별도의 클래스로 나누어 재사용이 쉽도록 한
- 프로그램군(family)을 위한 계획을 작성하라
    - 프로그램이 변경될 것을 예상한다면 해당 부분들을 별도의 클래스로 입력하여 고립시킨다
- 연관된 기능을 패키지화하라
    - 관련된 기능들 적당한 그룹으로 패키지
- 특정한 리팩토링을 수행하라

피해야 할 클래스

- 만능 클래스를 생성하지 말라
- 관련없는 클래스들을 제거하라
    - 행위가 없고 데이터만 있는 클래스는 해당 클래스가 진짜 클래스인지 확인 후 데이터들이 다른 클래스들의 멤버 데이터가 될 수 있는지 확인
- 동사가 따라오는 클래스를 피하라
    - 데이터는 없이 행위로만 구성된 클래스의 루틴을 다른 클래스의 루틴으로 변환할 것을 고려

클래스 작성의 이유에 대한 요약

- 실세계의 객체를 모델링하라
- 추상 객체를 모델링하라
- 복잡성을 줄여라
- 복잡성을 고립시켜라
- 세부적인 정보를 숨겨라
- 변경의 영향을 제한하라
- 전역 데이터를 숨겨라
- 매개변수의 전달을 간소화하라
- 중앙 집중 관리하라
- 코드의 재사용을 도와라
- 프로그램군을 위한 계획을 작성하라
- 연관된 기능을 패키지화하라
- 특정한 리팩토링을 수행하라

## 5. 언어에 따른 문제

기본적으로 다른 언어라고 해도 개념은 같음

실제로 해당 개념을 구현하거나 구현할 때 제약이 다름

## 6. 클래스를 넘어서 : 패키지

클래스간의 의존성을 줄이고 독립적이 되도록

오류에 의한, 기능 추가에 의한 수정 등 특정 클래스가 변화하더라도 다른 클래스가 알지 못하도록

추상화를 잘 시켜 외부에서 사용이 용이하도록

좋은 클래스를 설계하는 법

추상화, 캡슐화를 깨지 않고

인스턴스와 객체간의 차이?

상속이 어려운 것이 나만 그런것이 아니었구나

객체를 어느 수준까지, 어느 정도로 나누는 것이 좋을까

- 사람의 손? 손가락? 그 이상?

# 7. 고급 루틴

루틴

- 한 가지 목적을 위해서 호출 가능한 개별적인 매서드, 프로시저

작성 이유

- 복잡성을 줄인다
- 추상화
- 중복 방지
- 서브 클래싱 지원
- 순서를 숨긴다
- 포인터 연산을 숨긴다
- 이식성
- bool 테스트의 단순화
- 성능개선

응집성

- 하나의 루틴이 한가지 일만 수행하는 것
    - cosin() 보다 cosAndTan() 가 응집성이 낮다
- 루틴의 이름이 가지고 있는(책임, 역할, 권) 일만 한다

함수? 프로시저? 차이를 주어야 하는 이유는?

루틴의 목적 반환값 == 이름 → 함수

이외 → 프로시저

# 8. 방어적인 프로그래밍

assert

- 코드에서 “절대로” 발생하면 안되는 오류를 처리
- 스스로 검사하기 위한 방어 수단
- 외부 입력 등으로 인한 오류는 오류 처리 하는 것이 맞다
- 신뢰할 수 있는 내부의 입력을 검사하기 위한, 스스로 확인하기 위한 수단으로 사용

오류 처리 기법

- 발생할 것 이라고 예상되는 오류를 처리
- 정확성
    - 잘못된 결과를 절대 반환하지 않는다
- 견고성
    - 프로그램의 종료보단 적당히 지속되는 것

예외

- 예외가 일어난 이유를 던진다
    - 오류를 처리하는 것이 간편해진다

방책

- 방책을(방화벽을) 담당하는 인터페이스를 생성
- 해당 인터페이스를 거치는 데이터는 깨끗한 데이터임을 신뢰할 수 있다
- 수술실을 들어가기 전에 살균실을 들어가는 것 과 같은 원리

디버그

- 개발 과정 에서의 공격적 프로그래밍
    - 오류의 가능성을 무시할 수 없도록 하라
    - 의도적인 가혹한 환경을 상정

선행 조건

- 루틴이 시작되기 이전에 참이어야 하는 조건
    - 매개 변수의 조건…

후행 조건

- 루틴이 끝난 후 참이어야 하는 조건
    - 반환 값의 조건…

방어적 프로그래밍의 중요성, 문제점

프로그램에 따라서 적당한 오류 처리 기법을 사용하자

적당한 수준의 방어가 좋다, 과한 방어적 프로그래밍은 프로그램의 성능에 영향을 준다

사용자의 입장에서 무시해도 되는 오류, 무시되면 안되는 오류를 생각하자

assert, 예외 처리의 차이

42 에서는 과한 예외 처리가 필수였음

사소한 오류가 평가에 영향을 미칠 수 있기 때문에 하나의 오류도 발생하면 안됨 (null guard)

때문에 어떤 오류까지 직접 처리해야 하는지가 주된 논쟁 중 하나

null guard 에 대해 어떻게 생각 하시는지

try-catch 문을 main 함수 내부에서 모든 코드에 씌우는 것…

# 9. 의사 코드 프로그래밍 프로세스

PPP (Pseudocode Programming Process)

낮은 수준에서 의사 코드를 짠다

- 의사 코드를 그대로 코드로 만들 수 있을 정도의 수준
- 높은 수준의 의사 코드는 코드의 세부 사항을 무시하게 된다
- 의사 코드를 기반으로 코딩을 한 후 의사 코드는 주석으로 남겨둔다

검토의 용이함

반복 적인 설계를 함에서 오는 설계의 개선

쉬운 수정

의사 코드 작성 순서

- 루틴의 설계
    - 루틴이 해야 하는 일에 대해 정리
- 사전에 필요한 조건들을 검사
- 루틴이 해결해야 하는 일을 정의
- 루틴의 이름 짓기
- 루틴의 테스트 방법을 결정
- 기 작성된 코드, 표준 라이브러리에서 사용 가능한 코드를 조사
- 오류 처리
- 효율성 고민
    - 캡슐화는 잘 되어있나…추상화는 잘 되어있나…코드는 읽기 쉬운가…
- 사용 가능한 알고리즘, 데이터 형 조사
- 의사 코드 작성

루틴의 헤더 주석

- 루틴이 무엇을 해야 하는 지에 대한 설명
- 데이터를 다루는 경우를 고려
- 의사 코드 검사

위 과정을 반복하면서 최적의 방법을 찾는다

의사 코드를 실제 코드가 적혀있는 수준에서 작성을 한 뒤 실제 코드를 짜기 전 해당 의사 코드를 사용해 검토와 디버깅을 요구한다

의사 코드가 완벽하다면 이를 기반으로 만들어 지는 코드 또한 완벽할 것이기 때문에 바로 코드를 작성하는 것이 아닌 완벽한 의사 코드를 작성하는 데에 많은 시간을 써야 한다

의사 코드가 실제 코드보다 수정이 간편하고 이해하기 쉬우며 타인에게도 설명해 주기 쉽다

수정이 간편한 의사 코드로 여러 번의 수정 작업을 수행하고, 이를 타인에게 보여줌으로써 더 나은 코드를 작성할 수 있다

다시 한번 설계의 중요성을 알리고 있다

실제로 ‘직관’에서 오는 설계, 코딩을 해 왔었기 때문에 이미 생각하는 내용이 머리에만 있는 상태로 진행을 하였다

충분히 검토가 되지 않은 경우도 있었고 코드를 작성하던 중 세부 사항을 잊어버려 여러 번 다시 생각하게 되는 경우도 있었다

코드 레벨 수준의 의사 코드는 실제로 코드 몇 줄과 1대 1 대응이 가능 해 지므로 완성된 의사 코드를 사용해 코드를 작성하는 것은 그 것 만으로 2번의 코드 작성을 의미한다

또한 의사 코드를 작성 하면서 겪은 시행착오를 포함 하면 여러 번의 반복 적인 설계가 들어가게 되는 것이라고 생각한다

첫 번째로 만들어지는 코드보다 두 번째로 만들어지는 코드가 좋은 것처럼 코드 작성 이전 여러 번의 설계가 들어가는 것이 중요성을 다시금 깨닿고있다

# 10. 변수 사용 시 일반적인 문제

변수의 초기화

- 선언과 동시에 초기화 한다
- 선언 근처에서 초기화 한다
- 해당 변수를 처 사용하는 곳 근처에서 초기화 한다
    - 근접성 원리

프로그램을 시작할 때 작업 메모리를 초기화 한다?

변수 참조의 지역

- span : 참조 사이에 있는 줄의 수
- span 이 작을 수록 읽기 쉽다

변수의 수명

- 변수가 생성되고 마지막으로 참조 될 때 까지 줄의 수
- 짧게 유지하는 것이 좋다

바인딩 시간

- 변수와 값이 서로 연결되는 시간
- 늦출수록 좋다..?
- 종류
    - 코드를 작성한 순간 (직접 값을 넣는 경우)
    - 컴파일 시간 (명명된 상수를 넣는 경우)
    - 로드 시간 (외부의 소스로부터 값을 받아 넣는 경우)
    - 객체 생성 시간 (해당 값이 있는 객체를 생성할 때 마다 값을 받아 넣는 경우)
    - 적시에 (just in time) (해당 값을 사용할 때 마다 받아 넣는 경우)
- 바인딩 시간이 늦을수록 변수의 사용이 유연해진다
- 유연성이 높아질 수록 코드의 복잡성은 강해진다

변수는 한 가지 목적만을 위해서 사용한다

- 함수, 객체에 책임, 역할, 권한을 주는 것과 마찬가지…?
- 한 변수를 두 가지 이상의 목적으로 사용하지 말 것
- 숨겨진 의미를 가지지 말 것
    - 변수의 의미가 여러가지 인 경우
        - 일반적으로는 양수, 에러일 경우 -1 을 가지는 변수
        - 양수와 음수일 때 각각 다른 역할을 하는 변수

→ 예전의 C 에서는 함수 초기에 변수를 선언했어야 했다고 한다

→ 이때는 어땠을까?

변수의 선언과 올바른 사용 방법

참조 span 은 적을수록 좋다

초기화는 최초로 사용하기 직전에 하는 것이 좋다

변수의 수명은 짧을수록 좋다

변수의 바인딩 시간은 늦을수록 유연성이 올라가지만 복잡도 또한 올라간다

변수는 한 가지의 목적으로만 사용 되어야 한다

변수 선언을 상단에 몰아서 하기?

- c99 부터 가능해진 변수 선언의 위치 자율
- c89 이전에는 왜 안됐나? 기술적인 문제?

많은 변수를 선언하기 vs 임시 변수 돌려쓰기

- while, for loop 등을 위한 index variable 의 중복 사용…

변수의 숨겨진 목적…printf, scanf, write, read, malloc 과 같은 함수들의 반환 값은?

# 11. 변수 이름의 효과

책임, 역할, 권한이 확실한 이름

다른 변수와 중복되거나 헷갈리지 않는 이름

듣기만 하면 찾아서 사용할 수 있는, 발음이 헷갈리지 않는 이름

유사한 의미를 가진 중복된 변수가 없는 이름

오해할 수 없는 명확한 이름

이 외에는 컨벤션에 맞게 지어진 합당한 이름으로 짓는다

당연하지만 당연하지 않은 내용들

이름을 명명함에 있어서 너무 길어 치기 귀찮은 경우를 피하고 이름을 간단히 명명할 때가 많았다

변수의 이름이 좀 더 길어지더라도 그에 맞는 이름을 지어주는 것이 의사소통에 더 이득이 될 것

# 12. 기본 데이터 형

숫자

- 0, 1 을 제외한 literal 은 define, 상수형으로
- 이 외의 숫자는 magic number 이므로 사용을 피한다
- 명시적 형 변환을 사용, 암시적 형 변환은 지양
- 서로 다른 형의 비교는 지양
- 정수
    - 나눗셈 확인
    - 오버플로우 검사
- 부동소수점
    - 정확하지 않다는 것을 인지
    - 라운딩 오류

문자, 문자열

- magic string 은 사용하지 않는다
- 언어가 unicode를 지원하는 방식에 대해 안다

불린(boolean) 변수

- 테스트의 용이

열거형

- 가독성, 수정의 용이성

명명된 상수

- 프로그램이 매개변수 화
    - 프로그램의 특징을 상수 화 시켜 한 곳에 두고 관리
- 가독성의 증가

배열

- 안전하지 않은 프로그램의 가능성
    - stack, queue 등 순차적인 접근이 가능한 자료구조를 먼저 생각한 뒤 배열의 사용을 고려한다

새로운 type 을 사용

- typedef 를 사용해 직접 type 을 명명한다
- 가독성, 코드의 이해를 돕는다
- 실제 세계의 자료형을 대입, 컴퓨터 데이터의 type 을 사용하지 않음
- typedef 를 사용하는 것이 아닌 class 를 생성하는 방법도 사용
- 기능 지향적으로 형의 이름을 생성
- 미리 정의 된 형과 겹치지 않도록

기본 데이터 타입에 대한 개관

해당 타입을 사용함에 있어서 타입을 그대로 사용하는 것이 아닌 좋은, 가독성 있는, 유지 보수하기 좋은 코드를 작성하기 위한 팁

-Wall -Werror -Wextra 옵션을 사용해 컴파일을 해 왔었다

덕분에 코드의 여러 문제가 될 부분을 미리 알고 코드를 수정할 수 있었다

이런 류의 경고 옵션들은 잘 사용하면 좋은 것 같다

magic number, magic string 이라는 단어를 보면서 생각을 가지게 만들었다

열거형을 자주 사용하지 않았는데 예시를 보니 확실히 가독성 측면이나 코드를 수정함에 있어서 좋은 결과가 나올 것 같다

상수, define 을 무의식 적으로 사용을 하지 않으려고 했었다

상수형을 사용하지 않고 define 을 많이 사용해왔다, 둘의 차이는? 어떤 방식이 더 유용할까?

메타 템플릿 프로그래밍에 대한 자료를 보면서 class, template class 를 사용해 커스텀 자료형을 만드는 것을 보았다, 메타 프로그래밍을 하는 것이 너무 어려워서 시도는 하지 못하였는데 어떤식으로 사용하게 되는지 좀 더 알아보고싶다

visual c++ warning level

# 13. 특이한 데이터 형

구조체

- 무작정 묶는 것이 아닌 비슷한 성향, 용도, 구성을 가진 변수를 묶는다

포인터

- 포인터는 언제나 오류가 나기 쉬운 변수
- 루틴, 클래스 단위로 고립, 격리시켜 오류가 확산되는 것을 막고 재사용성을 높인다
- 초기화 되지 않은 포인터는 위험할 수 있으므로 선언과 동시에 초기화하면 seg fault 오류를 낼 가능성이 적어진다
- 할당이 된 곳에서 해제하거나 생성자에서 할당하였으면 소멸자에서 해제하는 등 대칭적으로 삭제한다
- 사용하기 전 안전한 곳에 위치하고 있는지 확인 후 사용한다
- 포인터 변수를 많이 사용하더라도 헷갈리는 부분을 줄인다
- dangling pointer 를 막기 위해 삭제, 해제된 포인터는 null 로 초기화한다

전역 데이터

- 전역 데이터 수정 여부를 알지 못하는 문제
- 이름이 겹치게 되어 혼란이 생기는 문제
- 멀티 스레딩 에서의 문제
- 코드를 재사용하기 힘들어 지는 문제
- 모듈화, 관리의 용이성을 힘들게 하는 문제
- 사용해야 한다면?
    - 정리된 테이블에 보관
    - 명명된 상수 대신 사용
    - 열거형 대신 사용
    - 자주 사용되는, 아주 많은 참조를 가지는 경우 사용
- 다른 방법이 없을 때 최후의 수단으로 사용한다
- 접근 루틴을 사용한다
    - 직접 접근하는 것이 아닌 루틴을 통해서만 접근할 수 있도록 함
    - lock 을 사용해 접근을 제어한다
    - 접근을 추상화한다

잘 사용되지 않는, 혹은 일반적인 방법으로 사용하지 않고 주의를 해야 하는 변수들에 대해서 설명하고 있다

사실 포인터의 경우는 직접 체득한 정보와 거의 유사했다

요즘은 실제로 메모리가 손상이 되어 문제가 될 일은 없을 것 같아 해당 부분은 무시하고 넘어갔지만 그 외의 포인터, 할당 관리에 대한 내용은 실제로 많이 사용하고 있는 방식이었고, 매크로를 사용하는 것 또한 하나의 가비지 컬렉터의 구현이라고 생각하고 구현을 해 본 적이 있다

전역 데이터는 실제로 많이 사용하지 않아서 크게 생각해 본 적이 없었는데 이 책을 읽으면서 강조했던 추상화, 캡슐화를 위반할 수 있다는 점에서, 또 실제로 데이터가 그대로 공개됨으로서 생기는 문제에 대해서 생각을 해 보게 되었다

# 14. 직선형 코드 구성하기

순서가 중요한 명령문

- 의존성을 확실히 하라
    - 코드의 구성, 이름, 매개변수를 사용해 실행의 선후관계를 확실히 하라
    - 분명하지 않은 의존성은 주석으로라도 정리

순서가 중요하지 않은 명령문

- 가독성을 위해 하향식으로 작성하기
- 가독성을 위해 연관된 명령문을 그룹화하기

당연하지만 중요한 내용

실제로 내 코드에서 의존성을 어떻게 표현할 것 인가에 대해 생각을 많이 했었다

코드의 순서를 어떻게 해야 할 것인가…

# 15. 조건문 사용

if 문

- else 는 있는 것이 좋다? else 에 들어갈 내용이 없더라도 이유를 주석으로 처리해라?
- 조건문 안의 내용을 boolean 표현식을 반환하는 루틴을 사용해 단순화 시킨다
- 앞에 올수록 흔한 경우, 정상적인 경우 이다

case 문

- default 는 마지막 경우가 아닌 위의 경우를 제외한 모든 경우이다, 마지막 한 가지 경우를 위해 default 를 사용하지 말자
- break 를 잘 쓰자, break 없이 넘어가는 경우를 잘 쓰는 것은 힘들다

# 16. 루프 제어

루프 진입

- 진입은 한 곳 에서만
- 루프 직전에 초기화
- for, while 을 적절하게 사용
    - 간단한 곳에서만 for 사용

루프 중간

- 중괄호로 묶기
- 빈 루프 피하기
- 루프를 제어하기 위한 식은 루프의 시작, 끝에 배치
- 하나의 루프가 하나의 기능을 수행

루프 종료

- 종료 조건을 명확하게
- for 의 인덱스를 이유 없이, 임의로 조작하지 않도록
- 적절한 break, continue 사용
    - 루프를 벗어나기 위한 flag 를 조건문에 넣는 것보다 break 를 사용한다
- break 가 너무 많아지는 것을 주의

팁

- 잘못된 조건문을 막기 위해 서수, 열거형을 사용
- 루프의 인덱스에 의미 있는 이름의 변수를 사용
    - i, j, k 를 그대로 사용하는 것 보다 이름을 지어주는 것이 가독성에 있어 좋다

# 17. 특이한 제어 구조들

return 을 많이 하는 경우

재귀

goto 문

특이한 데에는 이유가 있다

다수의 사람이 사용을 하지 않는 문법에는 그만한 이유가 있다

goto 같은 경우 코드를 간결하게 만들어 줄 수 있고 읽기 쉽게 될 수 있으나 순차적인 논리 구조를 부순다는 점에서 코드 작성에 있어서 좋지 않은 영향을 준다고 생각한다

가끔 코드를 작성할 때 goto 와 같은 문법에 대해 생각해 보기도 하지만 결국 goto 를 사용하기보단 다른 방법을 생각해 내는 것이 더 말이 되는 코드를 작성하는 것에 가까워지게 된다고 생각된다

# 18. 테이블을 활용하는 방법

논리적인 접근이 아닌 테이블을 이용해 접근하는 방법

직접 접근 방식

- 테이블에 직접 접근하여 데이터를 가져오는 방식
    - 12달의일 수 를 배열에 넣어두고 월을 배열의 인덱스로 넣어 데이터를 가져온다
- 값을 논리적으로(if, else) 찾는 것이 아닌 테이블에서 “검색” 을 하게 된다

인덱스 접근 방식

- 자료가 담긴 테이블 이전에 인덱스 테이블을 사용
- 값을 인덱스 테이블에 넣어 키를 찾은 후(검색한 후) 키를 사용해 참조 테이블에서 자료를 가져온다

단계적 접근 방식

- 테이블의 값에서 한 단계 씩 여부를 판단
- 순차적 탐색, 이진 탐색으로 값이 해당 키에 맞는지 여부를 판단한 후 알맞은 키를 사용해 데이터를 탐색

다수의 데이터를 처리해야 하는 과제에서 실제로 테이블을 사용해 해결한 적이 있다

복쉘과 같은 작고 수많은 데이터를 while, if 를 사용해 처리하면 시간이 너무 걸리고 그래픽 카드에서 논리 연산을 하는 것은 성능 저하 일어나 이를 해결하기 위해 vram에 배열을 넣어서 해결했다

# 19. 제어와 관련된 일반적인 문제

boolean

- boolean 변수와 true, false 를 비교하지 말고 그 자체로 boolean 으로 취급
- 복잡한 표현식을 루틴을 만들어 사용
- 테이블 사용
- 부정보단 긍정을 사용
- boolean 을 제외한 0에 해당하는 자료형이 있는 경우(int 0, char ‘\0’) 명시적으로 비교

널 명령문(빈 명령문) 을 사용하면 눈에 띄도록

깊은 중첩을 피하라

구조적 프로그래밍

- 하나의 입구와 출구만이 있는 제어 구조를 사용한다는 개념
- 시작과 끝이 하나 뿐인 코드 블록
- 세 가지 핵심 요소
    - 순서 (sequence)
    - 선택 (selection)
    - 반복 (iteration)

제어 구조가 프로그램 전체의 복잡도에 영향을 미친다

프로그램의 복잡도

- 프로그램을 이해하기 위해 한번에 기억해야 하는 머릿속 객체의 수
- 프로그램을 이해하기 위해 얼마만큼의 노력을 들여야 하는가

제어문을 작성하면서 나올 수 있는 문제들과 그에 대한 조언

결국 여기서도 복잡도 이야기가 나온다

프로그램이 잘 돌아가게 하는 가장 주된 요소가 아닐까

결국 프로그램의 복잡도를 결정하는 요소는 제어문이라고 하고 이를 잘 제어하는 것이 좋은 프로그램을 작성할 수 있다고 한다

# 20. 소프트웨어의 품질에 대한 조망

소프트웨어 품질 특성

- 사용자가 느끼는 외적인 특성
    - 정확성
    - 유용성
    - 효율성
    - 신뢰성
    - 무결성
    - 적응성
    - 정밀성
    - 견고성
- 프로그래머가 생각해야 할 내적인 특성
    - 유지 보수성
    - 유연성
    - 이식성
    - 재사용성
    - 가독성
    - 테스트 용이성
    - 이해성

품질관리를 위해

- 위의 품질들을 향상 시키는 것을 목표로 삼고
- 당장의 배포보다 품질관리를 중요시 하고
- 테스트를 꼼꼼하게 하고
- 기술적으로, 공학적으로 관리한다

개발 프로세스

- 통제된 변경
- 결과의 측정
- 프로토타이핑

명확한 목표 설정

결함을 찾을 수 있는 여러 방법들을 사용하여 결함을 잡아내라

조사하는 것이 테스트보다 비용이 적다

결함이 빨리 발견될수록 수정하는데 드는 비용이 적다

테스트를 통한 결함 탐지는 이후 증상을 찾아내는데 드는 비용이 있다

프로그램을 만드는데 코드를 작성하는 시간은 얼마 되지 않는다

많은 시간은 오류를 찾고 디버깅 하는데 소비가 되며 이 시간을 줄이는 것이 좋은 프로그램을 빠르게 만드는 방법이다

품질을 생각하면서 코드를 작성하면 오류가 줄어들어 이에 걸리는 시간을 줄일 수 있게 된다

프로그램을 만드는데 걸리는 시간 중 가장 많은 시간이 디버깅이라는 데에 공감이 간다

또한 글에서 나온 것 처럼 아무리 시간을 오래 사용해도 실제로 코드를 작성하는 시간은 많지 않다

아얘 코드를 작성하기 전 많은 고민을 하고 짧은 시간 안에 코드를 확 작성하는 것이 효율이 좋다는 것은 이미 경험을 통해 알고있다

애매하게 시간이 걸릴때가 오히려 좋지 않은 코드가 나온다

# 21. 협력적인 구현

21.1 협력적인 개발 방법의 개요

- 책임감을 공유하기 위한 기법
- 여러 테스트보다 협력적인 훈련이 더 효율적이고 다른 테스트에서 찾을 수 없는 종류의 오류를 발견할 수 있다
- 이미 뛰어난 프로그래머들에게는 지식을 공유할 수 있고 미숙한 프로그래머들에게는 더 많은 가르침을 받을 필요가 있다
    - 코드의 형식, 주석, 변수의 명명과 같은 문화에서
- 코드의 공동 소유권으로 코드가 개인이 것이 아닌 팀의 소유가 되도록
    - 여러 사람의 리뷰에 의한 코드 품질 향상
    - 한 사람의 부재로 인한 마비의 방지
    - 모두가 버그를 잡고 에러를 수정함에서 오는 결함 수정 주기의 단축

21.2 짝 프로그래밍

- 한 프로그래머가 키보드를 잡고 다른 한 프로그래머가 실수를 감시하면서 코드를 작성하는 방식
- 성공 요건
    - 코드 작성의 표준화
    - 감시가 아닌 “pair”
    - 필요한 부분에서만
    - 짝을 바꾸거나 역할을 교대로
    - 속도를 맞춰서
    - 같이 모니터를 보면서
    - 잘 맞는 사람과
    - 최소 한 사람의 숙련자, 경력자와 함께
    - 한 명이 리더를 맡아서
- 품질 향상, 일정 단축, 협력적인 문화 보급, 신입 교육, 코드의 공동 소유 장려

21.3 형식적인 정밀 검사

- 설계, 코드 정밀 검사
    - 이전에 있었던 문제, 나타날 수 있는 문제를 체크 리스트 화 시켜 문제를 찾고 해결하는 방식
    - 이번의 체크 리스트는 다음 정밀 검사 때 제공하여 장기적인 결과의 향상을 도모
- 진행 상태의 평가를 위해서도 사용
- 대안을 찾거나 옳고 그름을 판별하는 것이 아닌 코드의 결함을 찾기 위한 과정
    - 작성자를 비판하여서는 안됨
    - 작성자로 하여금 검사가 품질 향상에 도움이 될 것 이라는 생각을 하도록 해야 함
    - 작성자는 비판을 그대로 인정하는 것이 아닌 검토 후 결함에 대해 생각하고 그것의 타당성을 생각해야 함
    - 작성자는 결함에 대한 방어를 검토 중에 하는 것이 아님
    - 결함에 대한 최종 결정권은 작성자에게 있음

21.4 다른 종류의 협력적인 개발 방법

워크-쓰루 (work-throughs)

- 개괄적인 검토
- 둘, 셋 이상이 모여 기술적인 문제에 대해 하는 모든 회의
- 코드를 리뷰하고 설계에 대해 토론하는 것

코드 읽기

- 코드를 읽고 오류를 찾는 방식
- 워크-쓰루와 정밀 검사 사이의 방식
- 두 명 이상의 검토자들이 코드를 나눠 받고 검토자들에 의해서 발견 된 결함을 위주로 회의
- 검토자들의 개별적인 검토에 중점

코드 설계, 작성 과정 중에 프로그램의 결함을 줄일 수 있는 협력적 프로그래밍 방법을 소개한다

짝 프로그래밍, pair programming 은 두 사람이 하나의 코드를 같이 작성하며 한 명이 코드를 작성하고 한 명이 옆에서 그 코드를 검사하며 프로그래밍을 하는 방식

정밀 검사는 작성 중인, 작성된 설계, 코드를 여러 사람이 보면서 결함을 찾아 내는 방식

42 에서는 혼자 코드를 작성 하지만 후에 주어진 체크 리스트를 기반으로 여러 명의 사람과 1:1로 코드의 결함을 찾고 해당 결함에 대해 이야기를 하는 시간을 갖는다

pair programming 이 제대로 이뤄질 수 있을까? pair 가 된 두 사람이 동등한 관계가 아닌 경우 결국 한 사람이 다른 한 사람을 실시간으로 ‘감시’ 하면서 실시간 코드 리뷰를 하는 방식으로 이루어 질 것 같다

# 22. 개발자 테스트

테스트의 종류

- 테스트 사이즈에 맞춰서
    - 단위 테스트
    - 컴포넌트 테스트
    - 통합 테스트
    - 회귀 테스트
    - 시스템 테스트
- 테스트 하는 주체에 맞춰서
    - 블랙박스 테스트
        - 테스트 하는 사람이 테스트 되는 항목의 내부 작동을 볼 수 없을 때
    - 화이트박스 테스트
        - 테스트 하는 사람이 테스트 되는 항목의 내부 작동을 볼 수 있을 때 - 개발자가 하는 테스트
- 테스트는 오류를 발견하기 위한 방법
- 디버깅은 발견된 오류의 원인을 진단하고 수정하기 위한 방법

22.1 소프트웨어 품질에서 개발자 테스트의 역할

- 오류를 찾는 것, 성공적인 테스트는 소프트웨어를 부수는 것
- 테스트가 모든 오류를 찾을 수 없음, 오류가 없다는 것은 테스트가 완벽하지 않거나 비효율적인 테스트라는 것을 의미할 수 있음
- 테스트가 소프트웨어의 품질을 향상 시키지 않음, 품질의 지표
- 오류를 찾을 것 이라는 가정, 오류가 없을 것 이라 생각하고 하는 테스트는 오류를 찾을 수 없음
- 얼마나 많은 시간을 써야 하는가?
- 테스트의 결과로 무엇을 할 것 인가?
- 모든 부분은 다른 부분과 결합되기 전 unit test 를 하여야 한다
    - 테스트 되지 않은 부분들이 합쳐진 후 오류가 발생하면 모든 부분을 검사하여야 한다

22.2 개발자 테스트에 대한 바람직한 접근 방법

- 각각의 연관된 요구 사항이 구현되었는지 테스트
- 각각의 연관된 설계 사항이 구현되었는지 테스트
- 요구 사항과 설계 사항의 상세 테스트를 위한 기초 테스트
- 이전 테스트들의 체크 리스트를 사용
- 코드 작성 이전? 이후?
    - 테스트를 작성하고 코드를 작성하면 테스트에 드는 비용이 줄어든다
    - 테스트를 미리 작성하면 결함을 미리 발견, 인지하고 코드를 작성할 수 있다
    - 테스트를 미리 작성하면 요구 사항과 설계에 대해 먼저 생각 해 볼 수 있다
    - 테스트를 미리 작성하면 요구 사항에 있을 문제를 조기에 노출 시킨다
    - 테스트를 미리 작성하면 코드 작성 이후에도 테스트가 가능하다
    - “테스트를 먼저 작성하라”
- 개발자 테스트의 한계
    - 코드가 ‘터지는’ 상황에 대한 테스트가 아닌 코드가 ‘작동하는지’ 에 대한 테스트를 하는 경향
        - clean test 보다 dirty test 를 하라
    - 실제보다 적은 테스트 커버리지
        - 더 많은 부분을 테스트 하여야 한다
    - 정교하지 못한 테스트
        - 더 정교한 테스트, 더 hard 한 테스트

22.3 여러가지 테스트 트릭

- 모든 경우를 다 테스트 할 수는 없다
- 가장 오류에 가까운 ‘테스트 케이스’ 를 선택하여 확인한다
- 코드 커버리지, 논리 커버리지
    - 프로그램의 모든 경로를 테스트 하는 접근 방법
- 데이터 흐름 테스트
    - 데이터 사용이 적어도 제어 흐름은 오류를 유발할 가능성이 있다는 기본 개념
    - 데이터의 상태
        - 정의 - 초기화 되었지만 사용되지 않음
        - 사용 - 루틴의 인자로서 사용되었음
        - 삭제 - 한번 정의되었지만 다른 방법에 의해 정의가 해제됨
        - 들어감 - 변수가 사용되기 직전에 루틴에 들어감
        - 빠져나옴 - 변수가 사용된 직후 루틴을 빠져나감
    - 테스트 하여야 할 수준
        - 모든 정의
        - 모든 정의 - 사용
- 등가 분할
    - 좋은 테스트 케이스는 데이터의 넓은 부분을 다룬다
    - 두 테스트가 같은 오류를 만들면 하나의 테스트 케이스만 있으면 된다
- 오류 추측
    - 직관, 경험에 의해 테스트 하는 방법

22.4 전형적인 오류

- 오류는 균일하게 퍼져있는 것이 아니다, 주로 주요한 클래스에 집중되어있다
- 오류의 종류는 아주 다양하다
    - 대부분의 오류는 적은 수정으로 수정될 수 있다
    - 많은 오류가 프로그래머의 잘못이다
    - 오타로 인한 오류
    - 설계의 잘못된 이해로 인한 오류
- 테스트의 오류

22.5 테스트 지원 도구

- mock test
    - 가짜 데이터를 반환하거나 실제 루틴을 호출하는 가짜 루틴같은 mock 객체, mock 데이터를 사용
    - JUnit, CppUnit 과 같은 mock test 를 위한 테스트 프레임워크를 사용
- 테스트 데이터 생성기
- 커버리지 모니터
    - 조사되고 있는 코드와 그렇지 않은 코드를 추적하기 위한 도구
- 데이터 레코더/로깅
- 심볼릭 디버거
- 시스템 교란기
- 오류 데이터 베이스
    - 반복적으로 발생하는 오류를 검사하고 새로 만들어지는 오류에 대한 기록을 한다

22.6 테스트를 향상시키는 방법

- 계획 세우기
- 다시 테스트하기
- 자동화하기

22.7 테스트 기록을 보존하는 방법

- 테스트를 기록함에 있어 넣어야 할 항목들
- 프로젝트 테스트가 아닌 개인 테스트 또한 기록해 두기

테스트의 중요성

# 23. 디버깅

23.1 디버깅 문제의 개요

디버깅은 품질을 향상시키는 것이 아닌 진단하는 방법

결함은 기회다

- 시행착오에 의한 프로그래밍을 하면 안된다
- 결함을 기회로 배울 수 있다

비효율적인 접근 방법

- 추측하기
- 문제를 완벽하게 이해하기
- 분명한 곳이 아닌 이곳 저곳에서 오류를 수정하기
- 미신에 의한 디버깅

23.2 결함의 발견

결함을 찾고 결함을 이해하는 것

과학적으로 디버깅 하기

간헐적인 결함을 예측 가능한 안정적인 결함으로

- 결함이 신뢰할 수 있게 발생하도록한다
- 예측이 불가능한 오류
    - 초기화 오류, 시간으로 인한 문제, dangling pointer 문제
- 오류를 발생시키는 단순한 테스트 케이스를 찾아라

오류의 원인을 찾기

결함을 찾는 팁

순차적 대입 (brute-force) 디버깅

구문 오류

23.3 결함의 수정

결함을 수정하는 것은 쉽지만 쉽다는 것은 오류를 내기도 쉽다는 것

문제를, 프로그램을 이해하라

23.4 디버깅에서 심리학적으로 고려해야 할 사항들

“그러길 원하는 것” 과 “실제” 의 심리적 거리

코드를 예상한 대로 보는 것이 아닌 그 자체로 보아야 한다

예상으로 문제 부분을 무시하는 일을 막자

23.5 디버깅 도구

diff

컴파일러

테스트 프레임워크

디버거

결함을 찾아내는 다양한 방법과 그를 해결함에 있어서 가져야 할 마음가짐

# 24. 리팩토링

리팩토링의 의의

이유

방법

주의점

24.1 소프트웨어 진화의 종류

진화가 프로그램의 품질을 향상시키는가?

구현 중 변경되는가 유지 보수 과정 중 변경되는가?

소프트웨어의 진화는 의식적으로 일어나야 한다

개선의 기회가 있을 때 개선해야 한다

24.2 리팩토링에 대한 소개

리팩토링

- 소프트웨어를 보다 쉽게 이해할 수 있고
- 적은 비용으로 수정할 수 있도록
- 겉으로 보이는 동작의 변화 없이 내부 구조를 변경하는 것

리팩토링을 하는 이유

- 리팩토링을 필요로 하는 코드들…

리팩토링을 하면 안되는 이유

- 리팩토링 ≠ 변경
- 리팩토링은 단순한 변경이 아닌 프로그램의 품질을 향상시키고 복잡성을 줄이는 전략

24.3 구체적인 리팩토링

데이터 수준 리팩토링

명령문 수준 리팩토링

루틴 수준 리팩토링

클래스 구현 리팩토링

클래스 인터페이스 리팩토링

시스템 수준 리팩토링

24.4 안전한 리팩토링

리팩토링을 안전하게 하는 방법

리팩토링을 하면 안되는 경우

리팩토링을 남용하지 말 것

24.5 리팩토링 전략

리팩토링을 해야 할 시기를 정하는 방법

언제 리팩토링을 해야하나?

# 25. 코드 최적화 전략

과거에도 최적화의 필요성에 대한 논란이 왔다 갔다 했음

25.1 성능의 개요

성능 ≠ 좋은 코드 인 것을 염두 하자

성능과 코드 최적화

- 프로그램 요구 사항
- 프로그램 설계
- 클래스, 루틴의 설계
- 운영체제 상호작용
- 코드 컴파일
- 하드웨어
- 코드 최적화

25.2 코드 최적화에 대한 소개

성능 향상의 가장 효율적인 방법은 아님

효율적은 코드 ≠ 좋은 코드

파레토 법칙

- 20%의 노력으로 80%의 결과를 얻을 수 있다
- 작은 부분이 큰 영향을 미친다

노부인들의 이야기(오래된 구전)

- 미신, 오래된 이야기를 믿고 최적화 하지 마라

최적화의 시기

- 좋은 설계, 올바른 프로그램, 유지 보수성이 좋은 프로그램이 정확하게 완성된 뒤 성능을 검사하라
- 최적화가 필요하다는 것을 알 때 까지 최적화는 필요하지 않다

컴파일러 최적화

- 직관적이고 분명한 코드가 교묘한 코드보다 컴파일러가 최적화 하기 쉽다

25.3 느리고 비대한 부분들

비효율성의 공통적인 원인을 찾아 프로파일링한다

공통적인 연산의 상대적인 성능 비용을 비교한다

- 특정 연산은 비용을 더 잡아먹는다

25.4 측정

실제 분쟁 지역을 판별하고 최적화 한 뒤 전후 차이를 측정 해 본다

경험으로 최적화 하지 말고 실제 값으로 최적화 한다

- 경험적으로 빨랐다고 이번에도 실제로 빨라진다는 보장은 없다

측정은 정확하게

- 일반적인 시계가 아닌 CPU 클럭 틱을 사용 한다던가…

25.5 반복

성능 저하의 원인을 규명한 뒤 여러 기법을 반복 사용하여 효과를 올린다

코드의 최적화

성능은 단지 품질의 한 가지 요소일 뿐 이며 보통 가장 중요한 요소가 아니다

1. 최적화에 실패할 경우를 대비한 백업 (git 등을 사용)
2. 분쟁 지역, 시간이 오래 걸리는 지역을 검색
3. 적절한 최적화 방안을 고민, 최적화 가능한 사항이 없다면 1에서 반복
4. 최적화
5. 성능 측정
6. 코드의 성능이 향상되지 않는다면 1에서 저장한 코드로 돌아가 반복

코드의 최적화 방안에는 많은 방법이 있으나 단순히 ‘카더라’ 를 믿지 말고 벤치마킹을 통해 성능 향상을 확인한다

처음으로 최적화를 해 보았던 과제는 container, 그 다음은 최근에 한 voxel 과제였다

앞의 과제는 속도의 기준치를 주었고 뒤의 과제는 원활한 ux 를 위해 스스로 걸어둔 기준이었다

생각한 방법은 많았지만 실제로 효과를 줄 수 있는, 주었던 방법은 몇 안되었고 최적화 성능 한계를 맞추는 것의 어려움을 알았다…

분명 설계부터 문제가 많은 코드였을 것 같은데 처음부터 다시 작성한다는 것이 두려워서 엄두도 못 내었던 것 같다

다시 voxel 과제에 손을 대게 되면 꼭 설계부터 다시 해서 갈아엎어야…

# 26. 코드 최적화 기법

코드의 최적화는 큰 규모에서 설계를 변경하는 것 보다 작은 규모에서 변경을 주로 가리킨다

리팩토링과 유사해 보일 수 있지만 최적화는 ‘내부 구조의 향상’ 과는 거리가 멀고 오히려 성능 향상을 목표로 내부 구조를 손상 시키는 경우가 많다

26.1 논리 구조

논리 식 에서 앞의 결과가 정해지면 뒤의 결과는 계산하지 않는 방법

- ‘단락 회로 평가’라고 불린다
- and, or 앞의 결과에 따라 뒤의 연산을 하지 않는 것
- loop 에서도 break 나 while 의 조건문에 조건을 추가하는 방식으로 불필요한 요소를 검사하지 않도록 한다

빈도에 따른 테스트 정렬

- if, switch 같은 분기문에서 더 일반적인 경우를 앞에 두어 자주 나오지 않는 경우를 자주 검사하는 것을 방지한다
- if-else 문과 switch-case 문의 구현 방식이 언어마다, 컴파일러마다 다르기 때문에 성능 향상에 도움이 될 수도 안 될 수도 있다

유사한 논리 구조의 성능 파악

- case, if-than-else 문과 같은 비슷한 역할을 하는 구문들의 성능을 파악한다
- 언어, 컴파일러마다 다를 수 있다

복잡한 표현식을 테이블 참조로 대체

- 논리 구조가 복잡해지면 테이블 참조를 고려해 본다

소극적 평가(lazy evaluation)

- 한번에 모든 것을 계산하는 것이 아닌 그때그때 필요한 부분을 계산 후 저장
- 후에 필요한 부분을 찾아 존재하면 사용, 없으면 계산
- DP 알고리즘과 유사한듯…

26.2 루프

Unswitching

- 루프 안의 조건문이 고정되어 있다면 모든 루프에서 이것을 체크하는 것이 아닌 루프 밖에서 한번만 체크하도록 한다

Jamming

- 두 개 이상의 루프에서 결합할 수 있는 부분을 찾아 결합하는 것
- 두 번 이상의 루프를 한번으로 줄인다

Unrolling

- 루프의 반복을 줄이는 방법
- 코드는 더 길어지지만 루프의 반복이 줄어 성능 향상을 노린다

루프 내부 작업의 최소화

- 루프 안에서 작업 되는 양을 줄인다
- 참조, 조건문 등등…

감시 값(sentinel values)

- 복합 테스트를 가지는 루프의 조건문을 단순화하는 방식
- 검색 루프에서 검색되는 범위가 조건에 있을 때 검색완료 && 범위 지나침 을 두번 검사해야 하는 경우가 있다
- 이때 검색되는 자료구조의 마지막 값을 임의로 수정하여 이를 한번에 해결한다

가장 빈번한 루프를 안쪽에 작성한다

- 중첩 된 루프의 순서를 고려한다
- 경우는 안, 밖의 조건의 곱으로 똑같지만 조건문을 검사하는 수는 밖의 루프 + (밖의 루프 * 안의 루프) 이다
- 밖의 루프가 작으면 조건문을 검사하는 수도 적어질 수 있다

강도 감소

- 곱셈과 같이 시간이 많이 걸리는 연산을 덧셈같은 시간이 적게 걸리는 연산으로 바꾸는 것
- 곱셈을 미리 밖에서 해 두는 방식으로 루프 내부에서는 곱셈을 줄인다

26.3 데이터 변환

부동소수점 대신 정수

적은 차수의 배열을 사용

배열 참조를 최소화

보조 인덱스 사용

- c 에서 ‘\0’을 찾아 문자열의 길이를 측정하는 것이 아닌 문자열의 길이를 담고 있는 값을 같이 가지고 있는다
    - 가변 길이 배열에서 통용되는 방식
- 데이터를 직접적으로 움직이는 것이 아닌 참조 형식으로, 혹은 포인터 형식으로 다루어 데이터의 이동을 줄인다

캐싱

- 자주 사용되는 값은 저장 해 둔다

26.4 표현식

논리 연산에서 표현식 (&&, ||) 의 사용을 줄이는 연산식을 사용한다

- !a || !b 보다 !(a && b)

강도 감소를 사용한다

- 곱셈을 덧셈으로
- 제곱을 곱셈으로
- 2 제곱을 shift 연산으로

컴파일 시간에 초기화 하라

- log2 를 직접 계산하는 것이 아니라 magic number 를 박아 넣는 방식

시스템 루틴을 주의하라

- 시스템 상 주어진 함수는 많이 정확하고 많이 느리다
- 좀 더 부정확한 결과여도 괜찮은 경우(log2 의 정수형이 필요하다던가) 더 간단한 루틴을 만들어 사용한다

상수의 정확한 형을 사용하라

- 형 변환 과정에서 오는 시간 손해를 줄인다

결과를 사전에 계산하라

- 계산을 미리 해 두고 사용한다

공통적인 하위 표현식을 제거하라

- 중복되는 표현식을 변수화 하여 중복 계산을 제거한다

26.5 루틴

루틴을 인라인으로 재작성

- 요즘을 루틴 호출에 큰 비용이 들지 않아 크게 효율있지 않다

26.6 저급 언어를 이용한 재구성

고급 언어로 프로그램을 작성한 뒤 속도가 중요한 부분만 저급 언어로 재작성한다

- C# 과 C++ 섞어서 사용한다

26.7 변경이 많을수록 상태는 그대로

코드 최적화는 복잡성, 가독성, 단순성, 유지 보수성 등 많은 측면이 성능과 트레이드 된다

정말 최적화가 필요한 것 인지 고민하면서 사용하자

코드의 성능을 높일 수 있는 최적화 기법들

중간 중간에도 이 방법들이 성능은 좋게 만들 수 있지만 코드의 가독성을 떨어트리는 등 코드 품질을 나쁘게 한다는 얘기를 반복해서 한다

적재적소에 활용해야 한다

최적화에 대해 고민을 하면서 실제로 사용했던 방식도 있지만 처음 보는, 신기한 방식이 더 많았다

정말 성능이 중요한 경우에는 사용을 고려 해 봐도 될 것 같다고 생각했다

# 27. 프로그램의 크기가 구현에 미치는 영향

모든 업무가 프로그램의 크기의 비례해서 커지지 않는다

27.1 의사소통의 크기

사람의 수가 많아지면 의사소통의 수는 사람의 수의 제곱에 비례해 커진다

사람이 많아질 수록 의사소통에 문제가 생길 확률도 제곱에 비례해 커진다

27.2 프로젝트 크기의 범위

27.3 프로젝트의 크기가 오류에 미치는 영향

프로젝트의 크기에 따라 오류의 양과 종류가 달라진다

프로젝트의 크기가 증가할 수록 요구 사항과 설계 상에서 실수에 의한 오류가 많아진다

작은 프로젝트에서는 구현 오류가 상대적으로 많다

프로젝트의 크기가 증가할 수록 오류의 밀도, 즉 줄 당 오류의 수가 증가한다

27.4 프로젝트의 크기가 생산성에 미치는 영향

작은 프로젝트에서는 생산성에 영향을 미치는 가장 큰 요소는 프로그래머의 능력

크기가 증가함에 따라 팀의 크기와 조직이 생산성에 더 많은 영향을 미친다

27.5 프로젝트의 크기가 개발 활동에 미치는 영향

활동 비율과 크기

- 프로젝트의 크기에 따라 프로젝트가 필요로 하는 활동의 비율도 달라진다
- 작은 프로젝트에서는 구현이 제일 중요한 활동이지만 크기가 커지면 아키텍처, 통합 작업, 테스트의 비중이 커진다

프로그램, 제품, 시스템, 시스템 제품

- 프로그램
    - 가장 간단한 소프트웨어의 종류
    - 한 사람, 또는 몇 사람에 의해서 사용되는 작은 소프트웨어
- 제품
    - 개발자가 아닌 다른 사람에 의해서 사용 될 목적으로 만들어진 프로그램
    - 제품이 릴리즈 되기 전에 많은 테스트와 문서화 과정이 필요하다
- 시스템
    - 함께 작동하는 프로그램 그룹
    - 통합되는 부분 사이의 인터페이스를 개발하는 데에 따른 복잡성과 주의가 요구
- 시스템 제품
    - 시스템과 제품
- 크기가 커질수록 구현은 프로젝트에서 적은 비율을 차지하며 그 외의 부분의 비중이 커지게 된다

방법론과 크기

- 크기에 따라 다른 방법론으로 접근 하여야 함
    - 작은 집을 짓는 것과 큰 빌딩을 짓는 것은 다름

프로그램의 크기에 따라 달라지는 것에 대한 이야기 

프로그램의 크기가 커질 때 선형적으로 증가하는 요소들과 비선형적으로 증가하는 요소들

크기에 따라 다르게 접근해야 함을 알려줌

단순히 코드의 줄 수에 따른 접근이 아닌 제품인지의 여부, 팀의 크기 등에 따라 프로젝트의 크기가 달라진다

프로그램의 크기에 따라 달라지는 것은 실제로 체감을 해 봤다

작은 cli 프로그램을 만들 때와 웹 서비스를 만들 때, gui 프로그램을 만들 때 설계의 중요성이 달라지고, 오류의 종류가 달라지는 것을 체감 하였다

# 28. 구현 관리

소프트웨어 개발 관리

구현에 적용되는 관리 주제

28.1 좋은 코드 작성의 장려

좋은 코드 습관을 어떻게 장려 할 것 인가?

- 엄격한 표준은 좋지 않다
- 표준을 정해야 한다면 훌륭한 설계자가 표준을 정하자

개발자가 정하는 프로젝트 표준

표준 설정 시 고려할 점

좋은 코드 작성을 장려하기 위한 기법

- 짝 프로그래밍
- 코드 검토 - 동료에 의한 압박
- 코드의 서명 - 상위 권한자에 의한 승인
- 검토를 위한 좋은 예제 코드를 공부
- 코드의 공용 재산화 강조
- 좋은 코드에 대한 보상
- 쉬운 표준

28.2 형상 관리

시스템이 오랜 시간 무결성을 유지할 수 있도록 체계적으로 프로젝트의 부산물을 규명하고 변화를 처리하기 위한 행위

변경 제어

요구 사항과 설계의 변경

- 변경이 필요할 때 마다 변경을 하게 되면 제어되지 않은 변경으로 인해 불필요한 작업을 반복하게 된다

소프트웨어 코드 변경

- 소스 코드의 제어

도구 버전

- 사용하는 도구(라이브러리 등)의 버전 제어

기계 구성

백업 계획

28.3 구현 일정의 예측

실제로 예측하는 것은 어느 정도의 낙관이 들어간 예측

예측 방법, 예측을 하는데 있어 좋은 접근 방법

구현 양에 대한 예측

일정에 미치는 영향들

예측 vs 제어

일정에 늦었을 경우

28.4 측정

프로젝트를 측정하는 이유

- 무엇이건 간에 측정을 하는 것이 하지 않는 것 보다 낫다
- 측정의 부작용을 주의하라
- 측정을 반대하는 것은 프로젝트에 무슨 일이 일어나는 지 모르는 게 낫다고 주장하는 것

28.5 프로그래머를 사람으로 대우하기

프로그래머들이 시간을 보내는 방식

성능과 품질의 다양성

개인차

팀 간의 차이

프로그래머의 신앙적인 문제

물리적인 환경

28.6 관리자 관리

직원도 관리자를 다룰 줄 알아야 한다

좋은 환경을 만들고 좋은 코드를 만드는 코드 외 적인 이야기들

# 29. 통합

개별적인 소프트웨어 컴포넌트를 하나의 시스템으로 결합하는 행위

29.1 통합 접근 방법의 중요성

29.2 통합 횟수 - 단계별 또는 점증적?

단계별 통합

- 각 클래스를 설계, 작성, 테스트, 디버깅 - 단위 계발
- 클래스들을 하나의 큰 시스템으로 결합 - 시스템 통합
- 전체 시스템을 테스트, 디버깅
- 시스템에 있는 클래스들이 처음으로 통합될 때 새로운 문제점들이 발생하고 원인을 예상할 수 없다는 문제
- 문제들이 한순간에 여러 곳에서 발생 한다는 문제
- 한번에 문제가 불거져 나온다는 점에서 빅뱅 통합이라고 불리기도 함
- 작은 프로그램에서는 시간을 아끼는 좋은 방식

점증적 통합

- 작은 단위로 프로그램을 작성, 테스트 한 다음 한 번에 하나씩 결합
- 시스템 크기가 작으면서 적은 기능을 수행하는 부분을 개발, 테스트, 디버깅
- 클래스를 설계, 작성, 디버깅
- 클래스를 뼈대에 통합, 테스트, 디버깅
- 새로운 클래스를 추가하기전 확인
- 눈덩이가 점점 커지는 모양

점증적 통합의 이점

29.3 점증적 통합 전략

단계별 통합은 모든 클래스가 한번에 합쳐지며 마감 전까지 순서에 상관없이 모든 작업을 해도 된다

점증적 통합은 순차적으로 클래스가 합쳐지므로 순서가 중요하다

구현 계획을 세워 컴포넌트들이 만들어 지는 순서를 정해 통합하여야 한다

하향식 통합

- 상위 객체, 루틴을 먼저 작성, 통합한다
- 하위 객체를 대신 해 줄 stub 객체를 만들어 테스트 한다
- 시간이 지남에 따라 해당 stub 객체들을 실제 객체로 바꾸어 나간다
- 하향식 통합의 단점을 보완하고자 전체를 수직적인 부분으로 나누어 각각 하향식 통합을 하는 방식을 사용한다

상향식 통합

- 계층의 밑단에서 부터 클래스를 작성하고 통합한다
- 한번에 하나씩 저수준의 클래스들을 추가 해 나간다
- 저수준의 클래스들을 테스트 하기 위한 드라이버(비계)들을 작성한 다음 클래스를 추가한다
- 시간이 지남에 따라 테스트 드라이버들을 상위 클래스로 바꾼다
- 상향식 통합의 단점을 보완하고자 전체를 수직적인 부분으로 나누어 각각 상향식 통합을 하는 방식을 사용한다

샌드위치 통합

- 상향적 통합과 하향적 통합의 문제를 해결하기 위한 방법
- 상위 수준에서 고 수준 비즈니스 객체를 통합
- 장치-인터페이스 클래스들과 하위 클래스 객체를 통합
- 상위, 하위 수준의 통합을 위 아래로 진행한 뒤 중간 단계의 통합을 진행

위험 지향적인 통합

- 어려운 부분을 우선 통합한다
- 각 클래스와 연결된 위험 수준을 규명 한 뒤 구현이 어려운 부분을 우선 구현한다
- 일반적으로 최상위, 최하위 부분이 먼저 구현, 통합된다

기능 지향적인 통합

- 한번에 하나의 ‘기능’ 을 통합
- 시스템의 구체적인 기능 별로 구현, 통합한다

T 자형 통합

- 초기 기초 개발을 한 뒤 상세 부분을 수직적으로 개발, 통합한다

29.4 일별 빌드와 스모크 테스트

daily build, smoke test

모든 코드를 ‘매일’ 컴파일 해 동작을 확인하는 ‘스모크 테스트’ 을 한다

일별 빌드

- 매일 빌드를 함으로써 개발자들의 일정 동기화를 돕는다

망가진 빌드 검사

- 매일 빌드를 해 빌드를 망치는 지점을 찾아 고친다

일별 스모크 테스트

- 전체 시스템을 처음부터 끝까지 사용한다
- 중요한 문제점을 노출시킨다

테스트를 최신으로 유지

- 시스템이 커질수록 테스트도 커져야 한다

스스로 테스트

- 수정 된 코드를 추가하기 전 스스로 테스트 한다

어디에 사용할까?

지속적인 통합

# 30. 프로그래밍 도구들

30.1 설계 도구

설계 다이어그램을 만드는 도구들

- UML(아키텍처 블록 다이어그램, 계층적 차트, 엔티티 관계 다이어그램, 클래스 다이어그램)

30.2 소스 코드 도구

편집

- 통합 개발 환경, IDE
- 다중 파일 문자열 검색, 바꾸기
- 비교 도구
- 병합 도구
- 소스 코드 정돈 도구
- 인터페이스 문서화 도구
- 템플릿
- 상호 참조 도구
- 클래스 계층 구조 생성기

코드 품질 분석

- 까다로운 문법, 의미 검사기
- 매트릭스 보고 도구

소스 코드 리팩토링

- 리팩토링 도구
- 재구성 도구
- 코드 변환 도구

버전 관리

데이터 사전

30.3 실행 코드 도구

코드 생성

- 컴파일러
- 링커
- 빌드 도구
- 코드 라이브러리
- 코드 생성 마법사
- 셋업, 설치
- 전처리기

디버깅

테스트

코드 최적화

- 프로파일러
- 어셈블러, 디스 어셈블러

30.4 도구 지향적인 환경

unix 환경의 도움을 받을 수 있는 도구를 windows 에서도 사

30.5 자신만의 프로그래밍 도구 개발하기

스크립트

30.6 프로그래밍 도구에 대한 환상

프로그래밍 도구로 인해 프로그래머의 필요성이 사라진다?

프로그래머가 그러한 도구를 사용해서 더 좋은 결과를 낸다

우리는 이미 많은 도구들을 사용하고 있고 더 좋은 도구, 더 편해질 수 있는 도구를 찾는 중이다

새로운 도구를 들이는데 망설임을 갖지 말자

# 31. 배치와 방식

미적인 측면

성능과는 상관없음

31.1 배치 기초

가독성!!

기본적인 형식화 법칙

- 논리적인 구조를 보여주는 배치
- 코드의 구조를 보여주는 배치

프로그램에 대한 사람과 컴퓨터의 해석

- 사람의 눈으로 보는 것과 컴퓨터가 해석하는 것의 차이
- 사람과 컴퓨터가 모드 잘 이해할 수 있도록, 같은 것을 이해할 수 있도록 하는 것이 좋은 배치

좋은 배치의 가치

- 작성 규칙이 이해력에 큰 영향을 줄 수 있다

종교

- 본인의 배치에 대해 종교적인 믿음, 맹신을 가지는 경우…
- 더 좋은 방식이 있다면 적응하는데 시간이 걸리더라고 수용하자

목표

- 코드의 논리적인 구조를 정확하고 일관되게 표현
- 가독성
- 변경 사항에 대한 내성

31.2 배치 기술

공백

- 그룹화
- 빈 줄
- 들여쓰기

괄호

31.3 배치 방식

순수 블록

순수 블록 흉내 내기

블록 경계를 나타내기 위해 중괄호 사용

줄 끝 배치

어떤 방식이 가장 좋을까?

31.4 제어 구조의 배치

이해, 가독성을 위해 사용

31.5 단일 명령문의 배치

31.6 주석의 배치

31.7 루틴의 배치

31.8 클래스의 배치

# 32. 스스로를 설명하는 코드

프로젝트의 문서화

- 소스 코드 내부
- 소스 코드 외부
- 별도의 문서
- 단위 개발 일지의 코드

32.1 외부 문서

단위 개발 일지(Unit Development Folders, UDF)

또는

소프트웨어 개발 일지(Software Development Folder, SDF)

- 개발자가 구현 중에 사용했던 기록들을 포함한 비 형식적인 문서
- 패키지, 컴포넌트, 클래스를 의미
- 설계 시의 결정 사항들에 대한 기록
- 상세 설계 문서
    - 저수준 설계 문서

32.2 문서화를 위한 프로그래밍 방식

코드 내부에 존재하는 문서

주석, 또는 코드 그 자체

코드의 명료화

32.3 주석을 작성 할 것인가? 작성하지 않을 것인가?

32.4 효율적인 주석을 위한 핵심 사항

주석의 종류

- 코드의 반복
- 코드의 설명
- 코드에서의 표시 기능
- 코드의 요약
- 코드의 의도를 기술
- 코드 자체 만으로 표현할 수 없는 정보

효율적인 주석 작성하기

- 유지 보수하기 어려운 주석은 지양한다
- 코드 작성 이전에 주석을 작성한다
- 주석을 개발 방식에 포함해라 - 주석 개발
- 성능 때문에 주석을 달지 않는 것은 핑계다

적당한 수의 주석

32.5 주석 작성 기법

32.6 IEEE 표준

IEEE std

Institute for Electric and Electrical Engineers Software Engineering Standards

# 33. 개인 성격

33.1 개인 성격은 주제를 벗어난 것 아닌가?

33.2 지성과 겸손

33.3 호기심

33.4 지적인 정직함

33.5 의사 소통과 협동

33.6 창의성과 훈련

33.7 게으름

33.8 생각만큼 중요하지 않은 특성

- 인내력
- 경험
- 별난 프로그래밍

33.9 습관

# 34. 소프트웨어 장인에 대한 주제

34.1 복잡성 정복

소프트웨어 설계, 구현의 주요 목적은 복잡성을 정복 하는 것

많은 프로그래밍 습관의 목적은 복잡성을 줄이는 것

복잡성을 줄이는 것은 효율적인 프로그래머가 되기 위한 가장 중요한 핵심 요소

34.2 자신에게 맞는 프로세스 선택

알맞은 프로세스가 코드 작성의 기반

34.3 컴퓨터보다 사람을 위한 프로그램을 작성하라

스스로 설명하는 코드

코드의 가독성

코드는 작성보다 읽는데 오랜 시간을 쓴다

34.4 언어에 얽매이지 말고 언어를 활용하는 프로그램을 작성하라

언어가 제공하는 기본적인 개념들에 사고를 제한하지 말아라

34.5 규약을 이용하여 주의를 집중하라

규약은 복잡성을 관리하기 위한 지적인 도구 중 하나

정보를 간결하게 전달

알려진 위험을 예방

코드의 예측 가능성 증가

언어의 약점을 보충

34.6 문제 중심의 프로그램

높은 추상화 단계에서 작업하여야 한다

해결책 보다는 프로그래밍 문제 중심적으로

프로그램을 추상화 수준으로 나누기

- 0 수준 : 운영체제 연산과 기계 명령
- 1 수준 : 프로그래밍 언어 구조와 도구
- 2 수준 : 저수준 구현 구조
- 3 수준 : 저수준 문제 도메인 용어
- 4 수준 : 고수준 문제 도메인 용어

문제 도메인에서 작업하기 위한 저수준 기술들

34.7 낙석을 주의하라

경고를 주의해서 보자

프로그래밍은 과학이 아닌 기술이기 때문에 경고 표시는 직접적이 아닌 간접적으로 나타난다

경고가 될 수 있는 다양한 지표

- 교묘한 코드
- 많은 오류를 가지고 있는 클래스
- 코드의 작성 시간보다 긴 디버깅 시간
- 설계 측정법(design metrics)
    - 클래스 멤버의 수
    - 루틴의 결정점의 수
    - 지역 중첩의 수
    - 변수의 수
    - 응집력
    - 결합의 정도
- 반복되는 같은 수정
- 테스트 케이스의 복잡함
- 설계의 난해함
- 주석을 적기 어려움

경고 표시를 눈의 띄기 쉽도록 해라

- 코드가 경고를 쉽게 보이게끔 한다
    - 잘못된 참조를 막기 위해 free 한 포인터는 null 로 초기화하여 null 참조를 하도록 만든다

컴파일러 경고를 눈여겨 봐라

34.8 반복，반복，또 반복

34.9 소프트웨어와 신조를 떼어 놓아라

신조, 신념을 넣어둬라

소프트웨어 계시(Oracles)

절충주의

- 한 가지의 방법을 고집하지 말자

실험