# OOP 상속성 inheritance

**파생 클래스**

- 기초 클래스의 특성을 물려받아 새롭게 작성 된 클래스를 말한다
- 상속 (inheritance)
    - 코드 재활용성 제공
    - 클래스 간의 계층 생성
- 클래스 상속
    - 기존에 정의 된 클래스의 모든 멤버 변수와 멤버 함수를 물려받아 새로운 클래스를 작성하는 것
    - 기존에 정의 된 클래스 : 부모 클래스, 상위 클래스
    - 새롭게 작성 된 클래스 : 파생 클래스, 자식 클래스, 하위 클래스
- 기존에 작성 된 클래스를 재활용 한다
- 공통 부분은 상위 클래스에 미리 작성하여 파생 클래스들의 중복되는 부분을 제거
- 선언
    - class 파생클래스이름 : 접근제어지시자 기초클래스이름[, 접근제어지시자, 기초클래스이름…] { 파생 클래스 멤버 리스트 };
    - 접근제어지시자를 생략하면 private 로 기본 설정
        - 파생 클래스가 기초 클래스에 접근할 수 있는 권한
    - ,(쉼표) 를 사용해 다중 상속이 가능
- 기초 클래스에서 접근할 수 있는 모든 멤버 변수가 저장되고 사용할 수 있다
- 멤버 변수를 추가할 수 있다
- 파생 클래스만의 생성자를 따로 만들어야 한다
    - 정의
        - 파생 클래스 생성자 정의 : 기초클래스 생성자 이용
        - ex) Student::Student(int id, const string& name, int age) : Person(name, age) { somethine };
        - Student 클래스의 생성자를 만들기 위해 기초 클래스인 Person 의 생성자를 이용한다
- 파생 클래스의 생성과 소멸
    - 생성
        - 기초 클래스의 생성자를 이용해 기초 클래스 객체 생성
        - 파생 클래스의 생성자와 기초 클래스의 객체를 이용해 파생 클래스 객체 생성
    - 소멸
        - 생성의 역순

**오버라이딩 (overriding)**

- 오버로딩은 같은 이름 다른 시그니처를 가진 여러 함수
- 오버라이딩은 이미 정의된 함수를 무시하고 재정의 하는 것
- 멤버 함수 오버라이딩
    - 상속 받은 멤버 함수를 필요에 따라 재정의 하는 것
    - 기초 클래스의 멤버 함수의 동작만을 재정의 하는 것이기 때문에 함수의 원형은 유지한다
- 방식
    - 파생 클래스에서 직접
    - 가상함수를 이용하여
- 파생 클래스에서 오버라이딩하기
    - 범위 지정 연산자를 이용하여 파생 클래스의 멤버 함수를 따로 정의한다
        - void Person::func() {};
        - void Student::func() {};
    - 또한 범위지정 연산자에서 파생 클래스의 객체에서 기초 클래스의 함수를 호출할 수 있다
        - hong.func(); // Student 객체의 func 호출
        - hong.Person::func(); // Student 객체의 Person 클래스 func 호출
    - 문제점
        - 기초 클래스형의 포인터에 파생 클래스 객체를 넣고 포인터객체로 사용 시 포인터에 대입한 클래스의 형에 상관 없이 포인터의 형, 즉 기초 클래스의 함수만을 사용하게 된다
- 가상함수로 오버라이딩 하기
    - 위의 문제점을 해결하는 가상 함수 사용
    - 기초 클래스와 파생 클래스에서 오버라이딩 할 함수 선언 시 각각 virtual 키워드를 앞에 붙여 가상함수로 선언

**다중상속**

- 파생 클래스 선언 시 ,(쉼표) 를 사용해 여러 클래스를 상속할 수 있다
- 문제점
    - 기초 클래스 간의 충돌 가능
    - 하나의 클래스를 두번 이상 상속받을 가능성
    - 파생클래스를 상속받을 경우 기초클래스의 포인터로 파생 클래스를 가리킬 수 없다
- 문제점이 많기에 지양하는 것이 좋음