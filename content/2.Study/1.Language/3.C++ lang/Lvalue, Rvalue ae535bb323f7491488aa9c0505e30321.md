# Lvalue, Rvalue

# value

C++ 에서는 value(값)을 크게 둘로 나눈다

1. l-value
    - 좌측값
    - = 연산의 왼쪽에 올 수 있는 값
    - 주로 변수, 객체같은 **주소값** 을 가지는 값
    - 우측에도 올 수 있으며 참조자(&)가 올 수 있다
2. r-value
    - 우측값
    - = 연산의 오른쪽에만 올 수 있는 값
    - 임시로 메모리를 할당받는 값들
    - 숫자, 리터럴 문자열, 생성자호출로 인한 임시변수등이 포함된다
    - 생성 후 바로 사라질 변수들
    - 좌측에는 있을 수 없으며 참조자를 사용할 수 없다
    - C++ 11
        - &&
        - C++ 11 이후로 우측값 (r-value ref) 참조자가 생겼다

더 세세하게 나누게 나누면 [[Programming/Language/C++/c++ value.png|1000]]

# Rvalue reference

우측값의 참조자

## 탄생이유

### 복사생성자 <-> 이동생성자

- 일반적인 복사생성자는 원본을 **유지** 하면서 this 객체를 원본과 같게 만든다
- 내부 변수에 대해 깊은 복사를 해야하기 때문에 시간이 오래 걸린다
- 이때 원본이 곧 사라질 **임시변수**, 즉 **rvalue** 일 때, 굳이 원본을 유지하지 않아도 된다
- 이 경우 swap 을 하면 원본과 this 의 값이 바뀌게 되며 원본은 임시변수이기 때문에 곧바로 소멸한다
- rvalue 가 들어왔을 때 기존의 `const T& obj` 과 다른 함수로 오버로딩되어 들어가야 할 필요가 생겼다
- rvalue 가 들어왔을 떄 구분해 줄 목적으로 사용한다

### swap, move

### swap

- swap 을 하는 경우를 생각 해 보자
- 일반적으로 tmp 변수를 만든다음 x 를 tmp 에 **복사**, 한 후 y 를 x 에 **복사**, 마지막으로 x 에 tmp 의 값을 **복사**한다

```cpp
template <typename T>void swap(T& x, T& y) {    T tmp = x;    x = y;    y = tmp;}
```

- 이때 생각해 보면 쓸데없는 **복사**가 세번이 일어났다
- 복사가 아닌 원래의 값을 **이동**하게 된다면 시간, 공간적으로 좋은 효율이 생긴다
- 이때 사용하기 위해 `std::move` 함수가 생기게 되었다

### move

- move 를 사용하면 원본의 값이 **이동**하게된다
- 정확히 말하면 lvalue 인 원래의 값을 주소를 가지면서 이동가능한 값인 xvalue 로 캐스팅한다
- 이렇게 하면 lvalue 이면서 이동가능한 rvalue 가 되어 이동을 하게되고 원래의 변수에서 새로운 변수로 **소유권**이 이전되게 된다