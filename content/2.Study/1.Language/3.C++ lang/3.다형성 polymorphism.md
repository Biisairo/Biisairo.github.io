# 다형성 polymorphism

**가상 함수 (virtual function)**

- 파생 클래스에서 재정의 할 것으로 기대하는 함수; 즉 재정의 하지 않아도 됨
- 호출하는 객체의 타입에 따라 호출하는 함수가 결정됨
- 선언
    - 기초클래스의 멤버 함수에 virtual 키워드를 이용해 가상 함수임을 선언
        - ex) virtual 함수의원형
    - 재정의 되는 파생클래스의 멤버함수는 자동으로 가상함수가 된다
    - 파생클래스의 멤버함수도 virtual 키워드를 사용해 가상함수임을 명시해 주면 좋다
- 가상함수를 사용하면 함수의 호출과정이 복잡해 지며 메모리와 시간에서 모두 손해를 보게된다
- 꼭 필요한 경우가 아니라면 정적 바인딩을 이용하는 것이 좋다

**동적 바인딩 (dynamic binding)**

- 바인딩
    - 함수를 호출하는 과정에서 함수가 어느 블록에 있는지, 함수가 저장된 메모리는 어디인지 알아야 한다
    - 함수를 호출하는 코드가 해당 함수가 있는 위치를 해석하는것을 바인딩 이라고 함
    - 함수를 호출하는 코드는 컴파일 시 고정된 메모리 주소로 변환되며
    - 이를 정적 바인딩 (static bindinga) 또는 초기 바인딩 (early binding) 이라고 한다
- 동적 바인딩
    - 가상함수는 컴파일도중이 아닌 실행 도중에 호출해야 할 함수가 결정이 된다
    - 컴파일 도중이 아닌 런타임 중에 알맞은 함수가 바인딩 된다
    - 이를 동적 바인딩 (dynamic binding) 또는 지연 바인딩 (late binding) 이라고 한다
- 동적바인딩을 사용하는 가상함수의 경우에는 포인터의 형이 기초클래스 이더라도 포인터가 가리키고 있는 값이 파생클래스 라면 파생클래스에서 오버로딩 된 함수가 실행이 된다

**가상 함수 테이블**

- 컴파일러마다 가상함수를 구현하는 방법은 다르나 일반적인 방식은 가상 함수 테이블을 사용함
- 각 객체마다 가상 함수 테이블을 가리키는 포인터를 몰래 저장하는 멤버를 추가하고
- 가상함수를 가지는 클래스는 가상함수 테이블을 생성한다
- 해당 테이블에는 가상함수의 주소가 저장이 된다

**가상 소멸자**

- 기초 클래스 포인터에 파생 클래스 객체를 동적할당해서 초기화를 한 뒤 delete 로 객체를 반환하면
- 기초클래스의 소멸자만 호출이 되고 파생클래스의 소멸자는 호출이 되지 못해 데이터 누수가 발생한다
- 이를 해결하기 위해 기초 클래스의 꼭 소멸자는 가상함수로 선언을 해 준다
- 기초 클래스의 소멸자를 명시해 줄 필요가 없더라도 아무일도 하지 않는 가상 소멸자를 명시해 주어야 한다

**순수 가상 함수**

- 가상함수와 달라 무조건 재정의 해 주어야 하는 함수
- 함수의 본체를 가지지 않는 것이 일반적이다; 즉 무조건 파생클래스에서 재정의를 해 주어야 한다
- 선언
    - virtual 멤버함수의원형=0;
    - 함수만 있고 본체는 없다는 의미의 =0 을 붙여준다

**추상 클래스 (abstract class)**

- 하나 이상의 순수 가상 함수를 포함하는 클래스를 추상 클래스 라고 함
- 다형성을 가진 함수의 집합을 정의해줌
- 해당 클래스로 부터 파생 된 모든 클래스는 함수를 재정의 해야 할 필요가 생김
- 작동하지 않는 순수 가상함수를 포함하므로 인스턴스(객체)를 생성한 수 없음
- 추상클래스 타입의 포인터와 참조는 사용할 수 있음